<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on taewan&#39;s blog</title>
    <link>http://taewan.kim/post.html</link>
    <description>Recent content in Posts on taewan&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 20 Feb 2016 17:04:26 +0900</lastBuildDate>
    <atom:link href="http://taewan.kim/post.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>오라클 Big Data Lite 설치</title>
      <link>http://taewan.kim/blog/2016/02/20/installing_bigdatalite/</link>
      <pubDate>Sat, 20 Feb 2016 17:04:26 +0900</pubDate>
      
      <guid>http://taewan.kim/blog/2016/02/20/installing_bigdatalite/</guid>
      <description>

&lt;p&gt;오라클에서는 빅데이터 플랫폼의 테스트와 학습을 효과적으로 지원하는 것을 목표로 Oracle Big Data Lite를 제공합니다.
Oracle Big Data Lite는 Cloudera의 최신 CDH와 오라클 연계 솔루션을 하나의 VitrualBox 이미지에 담고 있습니다.
오라클 Big Data Lite는 빅데이터 소프트웨어에 대한 모든 설치와 구성이 완성된 상태로 배포되기 때문에, 하둡을 막 시작하는 엔지니어가 Hadoop Eco를 학습하기에 가장 이상적인 시작점입니다.&lt;/p&gt;

&lt;p&gt;오라클 Big Data Lite의 메인 페이지의 URL은 다음과 같습니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.oracle.com/technetwork/database/bigdata-appliance/oracle-bigdatalite-2104726.html&#34;&gt;http://www.oracle.com/technetwork/database/bigdata-appliance/oracle-bigdatalite-2104726.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;http://taewan.kim/images/BigDataLite/01.otn_bigdatalite.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h1 id=&#34;오라클-big-data-lite-버전과-구성-컴포넌트:2dadf6bc939cbc50ba4be64b2cbf5c45&#34;&gt;오라클 Big Data Lite 버전과 구성 컴포넌트&lt;/h1&gt;

&lt;p&gt;2016년 2월 현재 오라클 Big Data Lite의 최신 버전은 4.4.0 입니다. 오라클 Big Data Lite는 VirtualBox 이미지 입니다. 이 가상 이미지에는 다음과 같은 소프트웨어가 포함되어 있습니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Oracle Enterprise Linux 6.7&lt;/li&gt;
&lt;li&gt;Cloudera CDH 5.5.1&lt;/li&gt;
&lt;li&gt;Oracle Database 12c Release 1 Enterprise Edition (12.1.0.2)

&lt;ul&gt;
&lt;li&gt;옵션&lt;/li&gt;
&lt;li&gt;Oracle Big Data SQL&lt;/li&gt;
&lt;li&gt;Oracle Multitenant&lt;/li&gt;
&lt;li&gt;Advanced Analytics&lt;/li&gt;
&lt;li&gt;OLAP&lt;/li&gt;
&lt;li&gt;Oracle Partitioning&lt;/li&gt;
&lt;li&gt;Oracle Spatial and Graph&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Cloudera Manager (5.5.1)&lt;/li&gt;
&lt;li&gt;Oracle Big Data Spatial and Graph 1.1.2&lt;/li&gt;
&lt;li&gt;Oracle Big Data Discovery 1.1.1&lt;/li&gt;
&lt;li&gt;Oracle Big Data Connectors 4.4

&lt;ul&gt;
&lt;li&gt;Oracle SQL Connector for HDFS 3.4.0&lt;/li&gt;
&lt;li&gt;Oracle Loader for Hadoop 3.5.0&lt;/li&gt;
&lt;li&gt;Oracle Data Integrator 12c&lt;/li&gt;
&lt;li&gt;Oracle R Advanced Analytics for Hadoop 2.5.1&lt;/li&gt;
&lt;li&gt;Oracle XQuery for Hadoop 4.2.1&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Oracle NoSQL Database Enterprise Edition 12cR1 (3.5.2)&lt;/li&gt;
&lt;li&gt;Oracle JDeveloper 12c (12.1.3)&lt;/li&gt;
&lt;li&gt;Oracle SQL Developer and Data Modeler 4.1.3&lt;/li&gt;
&lt;li&gt;Oracle Data Integrator 12cR1 (12.2.1)&lt;/li&gt;
&lt;li&gt;Oracle GoldenGate 12c&lt;/li&gt;
&lt;li&gt;Oracle R Distribution 3.2.0&lt;/li&gt;
&lt;li&gt;Oracle Perfect Balance 2.6.0&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;big-data-lite-설치:2dadf6bc939cbc50ba4be64b2cbf5c45&#34;&gt;Big Data Lite 설치&lt;/h1&gt;

&lt;p&gt;Big Data Lite를 설치하기 위해서는 다음과 같은 사전 준비가 필요합니다.&lt;/p&gt;

&lt;h2 id=&#34;big-data-lite를-위한-사전-준비사항:2dadf6bc939cbc50ba4be64b2cbf5c45&#34;&gt;Big Data Lite를 위한 사전 준비사항&lt;/h2&gt;

&lt;h3 id=&#34;소프트웨어:2dadf6bc939cbc50ba4be64b2cbf5c45&#34;&gt;소프트웨어&lt;/h3&gt;

&lt;p&gt;VirtualBox를 운영 할 호스트 머신에는 다음과 같은 소프트웨어가 사전에 설치되어 있어야 합니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;VirtualBox와 VirtualBox Extension Pack

&lt;ul&gt;
&lt;li&gt;4.3.26 이상의 버전이 권장&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.oracle.com/technetwork/server-storage/virtualbox/downloads/index.html&#34;&gt;http://www.oracle.com/technetwork/server-storage/virtualbox/downloads/index.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;7zip

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.7-zip.org/download.html&#34;&gt;http://www.7-zip.org/download.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Big Data Lite는 오라클 Big Data Lite메인 페이지에서 13개의 7zip 분할 파일로 제공&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;하드웨어:2dadf6bc939cbc50ba4be64b2cbf5c45&#34;&gt;하드웨어&lt;/h3&gt;

&lt;p&gt;Big Data Lite 가상 인스턴스를 운영 할 호스트 머신에는 디스크, 메모리, CPU에 대하여 다음과 같은 조건을 충족해야 합니다.&lt;/p&gt;

&lt;h4 id=&#34;디스크:2dadf6bc939cbc50ba4be64b2cbf5c45&#34;&gt;디스크&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;최소 50 GB, 최대 80GB

&lt;ul&gt;
&lt;li&gt;7zip 분할 파일: 13개, 26Gb - OVA 생성 후 삭제 가능&lt;/li&gt;
&lt;li&gt;OVA 파일 - 7zip 분할 파일로 부터 생성된 파일, 30GB (VirtalBox 임포트 후 삭제 가능)&lt;/li&gt;
&lt;li&gt;VirtualBox 인스턴스 파일 - OVA를 임포트한 결과, 30GB&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;cpu:2dadf6bc939cbc50ba4be64b2cbf5c45&#34;&gt;CPU&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;4 core 이상&lt;/li&gt;
&lt;li&gt;2 core를 VirtualBox 인스턴스에 할당&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;추가로 VirtualBox는 하드웨어 가상화가 활성화 되어있어야 합니다. Intel CPU를 사용한다면 다음과 같은 항목이 BIOS 설정에서 활성화 되어 있어야 합니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Intel CPU 사용시 BIOS에서 &amp;ldquo;Intel VT-d&amp;rdquo; 와 &amp;ldquo;Intel Virtualization Tehcnology&amp;rdquo;가 활성화 되어 있는지를 확인 합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;http://taewan.kim/images/BigDataLite/03.VTD.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;AMD CPU를 사용중이라면 BIOS에서 Secure Virtual Machine이 활성화 되어 있는지를 확인 합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;http://taewan.kim/images/BigDataLite/04.amd_svm.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;memory:2dadf6bc939cbc50ba4be64b2cbf5c45&#34;&gt;Memory&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Host의 Memory: 최소 8GB 이상&lt;/li&gt;
&lt;li&gt;인스턴스 할당 최소 메모리 사이즈: 5GB&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;가상 인스턴스에 할당하는 메모리의 경우 메모리 할당 사이즈에 따라서 다음과 같은 컴포넌트를 추가로 사용할 수 있습니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;10GB 이상: Cloudera Manager 활성화 가능&lt;/li&gt;
&lt;li&gt;12GB 이상: BDD (Big Data Discovery) 활성화

&lt;ul&gt;
&lt;li&gt;BDD 활성화 시 Cloudera Manager는 비 활성화 됩니다.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;big-data-lite-다운로드:2dadf6bc939cbc50ba4be64b2cbf5c45&#34;&gt;Big Data Lite 다운로드&lt;/h2&gt;

&lt;p&gt;Big Data Lite 메인 페이지에서 7zip으로 분할된 파일 13개를 다운로드 받습니다. 파일을 다운로드 받기 위해서는 oracle.com에 대한 계정 인증 절차를 거쳐야 합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://taewan.kim/images/BigDataLite/02.download.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;가상-이미지-설치:2dadf6bc939cbc50ba4be64b2cbf5c45&#34;&gt;가상 이미지 설치&lt;/h2&gt;

&lt;p&gt;13개로 분할된 파일을 7zip을 지원하는 툴로 압축을 풀어고 설치를 진행합니다. 13개의 분할 파일의 압축을 풀면 30기가 파일이 하나 생성됩니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://taewan.kim/images/BigDataLite/05.extract.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;7Zip을 지원하는 툴로 BigDataLite440.7z.001 파일을 선택하고 압축 풀면 27.9GB의 BigDataLite440.ova파일이 하나 생성됩니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://taewan.kim/images/BigDataLite/06.ova.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;이렇게 만들어진 ova를 임포트하기 위해서 &amp;ldquo;파일&amp;rdquo;-&amp;gt;&amp;ldquo;가상 시스템 가져오기&amp;rdquo;를 실행합니다.
&lt;img src=&#34;http://taewan.kim/images/BigDataLite/07.import.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;앞에서 만든 OVA파일을 선택하고 &amp;ldquo;계속&amp;rdquo;을 클립합니다.
&lt;img src=&#34;http://taewan.kim/images/BigDataLite/08.ovafile.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;OVA에 사전에 설치된 가상 이미지의 속성 값을 확인하고 &amp;ldquo;가져오기&amp;rdquo;를 선택합니다.
&lt;img src=&#34;http://taewan.kim/images/BigDataLite/09.setting.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;마지막으로 라이센스 동의를 클릭합니다.
&lt;img src=&#34;http://taewan.kim/images/BigDataLite/10.agreement.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;지금까지의 절차로 가상 이미지 임포트 작업이 수행됩니다.
&lt;img src=&#34;http://taewan.kim/images/BigDataLite/11.importing.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;가상 이미지가 임포트 된 후 메모리 설정을 변경하기 위하여 &amp;ldquo;설정&amp;rdquo; 메뉴를 실행합니다.
&lt;img src=&#34;http://taewan.kim/images/BigDataLite/12.imported.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&amp;ldquo;시스템&amp;rdquo;텝에서 5기가 이상의 메모리를 설정합니다. Cloudera Manager를 사용하고자 한다면 10 기가 이상의 메모리를 설정해야 합니다.
&lt;img src=&#34;http://taewan.kim/images/BigDataLite/13.settingMemory.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&amp;ldquo;시작&amp;rdquo;메뉴를 선택하여 가상 이미지를 시작합니다.
&lt;img src=&#34;http://taewan.kim/images/BigDataLite/14.start.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&amp;ldquo;Big Data Lite&amp;rdquo; 가상 이미지의 기본 계정은 oracle있니다.
&lt;img src=&#34;http://taewan.kim/images/BigDataLite/15.login.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;로그인하기 위한 계정 정보는 다음과 같습니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Account: oracle&lt;/li&gt;
&lt;li&gt;Password: welcome1
&lt;img src=&#34;http://taewan.kim/images/BigDataLite/16.window.png&#34; alt=&#34;&#34; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;big-data-lite-서비스-관리:2dadf6bc939cbc50ba4be64b2cbf5c45&#34;&gt;Big Data Lite 서비스 관리&lt;/h1&gt;

&lt;h2 id=&#34;서비스-접속-정보:2dadf6bc939cbc50ba4be64b2cbf5c45&#34;&gt;서비스 접속 정보&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Linux

&lt;ul&gt;
&lt;li&gt;root/welcome1&lt;/li&gt;
&lt;li&gt;oracle/welcome1&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Oracle Database 12c

&lt;ul&gt;
&lt;li&gt;service: orcl&lt;/li&gt;
&lt;li&gt;port: 1521&lt;/li&gt;
&lt;li&gt;account: moviedemo/welcome1&lt;/li&gt;
&lt;li&gt;기타 모든 패스워드: welcome1&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Oracle Data Integrator

&lt;ul&gt;
&lt;li&gt;ODI User: SUPERVISOR&lt;/li&gt;
&lt;li&gt;ODI Password: welcome1&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Oracle Big Data Discovery

&lt;ul&gt;
&lt;li&gt;http://{BDL_IP}:9003/bdd/web/hoe/index&lt;/li&gt;
&lt;li&gt;user: admin@oracle.com&lt;/li&gt;
&lt;li&gt;password: welcome1&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Oracle NoSQL

&lt;ul&gt;
&lt;li&gt;Administraion Page: http://{BDL_IP}:5001&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Hive Metastore (MySQL)

&lt;ul&gt;
&lt;li&gt;user: hive&lt;/li&gt;
&lt;li&gt;password: welcome1&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Weblogic

&lt;ul&gt;
&lt;li&gt;http://{BDL_IP}:7001/console&lt;/li&gt;
&lt;li&gt;user: weblogic&lt;/li&gt;
&lt;li&gt;password: welcome1&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;RStudio

&lt;ul&gt;
&lt;li&gt;http://{BDL_IP}:8787&lt;/li&gt;
&lt;li&gt;user: oracle&lt;/li&gt;
&lt;li&gt;password: welcome1&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Cloudera Manager

&lt;ul&gt;
&lt;li&gt;http://{BDL_IP}:7180&lt;/li&gt;
&lt;li&gt;user: admin&lt;/li&gt;
&lt;li&gt;password: admin&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Oracle MoviePlex Demo - Sample

&lt;ul&gt;
&lt;li&gt;http://{BDL_IP}:7001/movieplex/index.jsp&lt;/li&gt;
&lt;li&gt;user: guest1&lt;/li&gt;
&lt;li&gt;password: welcome1&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;서비스-시작하기:2dadf6bc939cbc50ba4be64b2cbf5c45&#34;&gt;서비스 시작하기&lt;/h2&gt;

&lt;p&gt;Big Data Lite는 다수의 서비스가 설치되어 있습니다. 각 서비스는 바탕화면의 &amp;ldquo;start/stop Services&amp;rdquo; 아이콘과 Cloudera Manager로 관리할 수 있습니다. 두 방법은 상호 배타적입니다.&lt;/p&gt;

&lt;p&gt;기본  서비스 관리 방법은 &amp;ldquo;start/stop Services&amp;rdquo; 아이콘을 이용한 방법입니다. Cloudera를 사용하고자 한다면 우선 메모리 설정을 10GB 이상을 할당하고 &amp;ldquo;start/stop Services&amp;rdquo;을 시작한 후 모든 서비스를 off하고 리눅스를 재시작합니다. 재시작 이후에 &amp;ldquo;start/stop Services&amp;rdquo; 실행하면 &amp;ldquo;Cloudera Manager 서비스&amp;rdquo;가 나타나는 것을 확인 할 수 있습니다.&lt;/p&gt;

&lt;h3 id=&#34;기본-서비스-관리:2dadf6bc939cbc50ba4be64b2cbf5c45&#34;&gt;기본 서비스 관리&lt;/h3&gt;

&lt;p&gt;&amp;ldquo;start/stop Services&amp;rdquo;를 더블 클릭하면 GUI 형태의 터미널을 볼 수 있습니다. 사용하고자 하는 서비스를 마우스로 선택하고 &lt;OK&gt;를 마우스로 클릭하면 체크된 서비스가 시작됩니다.&lt;br /&gt;
&lt;img src=&#34;http://taewan.kim/images/BigDataLite/17.services.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;cloudera-manager로-관리:2dadf6bc939cbc50ba4be64b2cbf5c45&#34;&gt;Cloudera Manager로 관리&lt;/h3&gt;

&lt;p&gt;바탕화면의 &amp;ldquo;start/stop Services&amp;rdquo;를 실행한 후 모든 서비스를 체크를 해제한 후 &lt;ok&gt;를 클릭하고 리눅스를 재시작 합니다. (sudo reboot)
&lt;img src=&#34;http://taewan.kim/images/BigDataLite/18.uncheck.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;재시작 후에 &amp;ldquo;start/stop Services&amp;rdquo;를 시작해 보면 가장 아래에 Cludera Manager가 나타난 것을 확인 할 수 있습니다.
&lt;img src=&#34;http://taewan.kim/images/BigDataLite/19.cmService.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Cloudera Manager가 시작되면 다음과이 Cloudera Manager URL을 통해서 접근 가능합니다.
&lt;img src=&#34;http://taewan.kim/images/BigDataLite/20.cm.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;로그인 정보는 다음과 같습니다.
* user: admin
* password: admin
&lt;img src=&#34;http://taewan.kim/images/BigDataLite/21.cm.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;이제 부터는 Cloudera Manager로 구성 서비스를 시작 할 수 있습니다.&lt;/p&gt;

&lt;p&gt;리부팅 후 다시 &amp;ldquo;start/stop Services&amp;rdquo;를 시작해 보면 Cloudera Manager와 Oracle, NoSQL만을 제외한 다른 서비스는 사라진 것을 확인 할 수 있습니다.
&lt;img src=&#34;http://taewan.kim/images/BigDataLite/21.service.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h1 id=&#34;네트웍-설정:2dadf6bc939cbc50ba4be64b2cbf5c45&#34;&gt;네트웍 설정&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://taewan.kim/blog/2016/01/31/virtualvox_network_config/&#34;&gt;http://taewan.kim/blog/2016/01/31/virtualvox_network_config/&lt;/a&gt; 의 내용을 참조하여 Host에서 VM에 접근 가능한 네트웍 설정을 할 수 있습니다.&lt;/p&gt;

&lt;p&gt;네트웍 설정을 마치고 가상 머신을 재시작하면 eth2가 설정된 것을 가상 머신에서 확인할 수 있습니다.
&lt;img src=&#34;http://taewan.kim/images/BigDataLite/28.vm_ip.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;호스트에서 이 IP을 이용하여 가상 머신의 서버스에 접근 가능합니다.
&lt;img src=&#34;http://taewan.kim/images/BigDataLite/29.hue.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;다음같이 ssh 접근도 가능합니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;taewan@demo $ssh oracle@192.168.56.101
oracle@192.168.56.101&#39;s password: 
[oracle@bigdatalite ~]$ uname -a
Linux bigdatalite.localdomain 2.6.39-400.264.5.el6uek.x86_64 #1 SMP Tue Nov 3 18:37:52 PST 2015 x86_64 x86_64 x86_64 GNU/Linux
[oracle@bigdatalite ~]$ 

&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;host와-vm의-공유-디렉터리-설정:2dadf6bc939cbc50ba4be64b2cbf5c45&#34;&gt;Host와 VM의 공유 디렉터리 설정&lt;/h1&gt;

&lt;p&gt;테스트를 효과적으로 진행하기 위하여 Host와 가상 머신 간의 공유 디렉터리를 설정하면 효과적입니다.&lt;/p&gt;

&lt;p&gt;VirtualBox의 Big Data Lite 가상 인스턴스를 선택하고 &amp;ldquo;설정&amp;rdquo; 메뉴를 실행합니다.
&lt;img src=&#34;http://taewan.kim/images/BigDataLite/22.setting.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&amp;ldquo;공유폴더&amp;rdquo; 텝에서 설정을 추가합니다.
&lt;img src=&#34;http://taewan.kim/images/BigDataLite/23.shar.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;호스트와 가상머신의 공유 폴더를 지정합니다.
&lt;img src=&#34;http://taewan.kim/images/BigDataLite/24.shreddiredtory.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;설정이 완료되면 다음과 같은 결과를 볼 수 있습니다.
&lt;img src=&#34;http://taewan.kim/images/BigDataLite/25.config.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;공유-폴더-설정-확인:2dadf6bc939cbc50ba4be64b2cbf5c45&#34;&gt;공유 폴더 설정 확인&lt;/h2&gt;

&lt;p&gt;가상 인스턴스를 재시작하면 가상 머신에서 /media/sf_share가 마운트 되어 있는 것을 확인 할 수 있습니다. 테스트를 위해 test파일을 하나 추가합니다.
&lt;img src=&#34;http://taewan.kim/images/BigDataLite/26.share-bdl.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;호스트에서 지정한 폴더에서 가상 머신에서 추가한 파일을 확인 할 수 있습니다.
&lt;img src=&#34;http://taewan.kim/images/BigDataLite/27.share-host.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h1 id=&#34;요약:2dadf6bc939cbc50ba4be64b2cbf5c45&#34;&gt;요약&lt;/h1&gt;

&lt;p&gt;지금까지 Oracle Big Data Lite의 설치 절차에 대하여 정리해 보았습니다. Big data Lite에는 Hadoop, Spark, Hive, Pig, Impala, Hue, 등 빅데이터 에코의 대부분의 최신버전 소프트웨어가 포함되어 있습니다. 추가 예제로 MoviePlex가 포함되어 있고 Big Data Lite의 메인 페이지에는 오라클이 제공하는 다수의 강좌 파일이 올라가 있습니다. 이를 활용하여 초기 빅데이터 학습 및 테스트 환경으로 사용할 경우 상당한 효용성을 볼 수 있습니다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>레이서 민수 (in 코코몽 키즈 랜드)</title>
      <link>http://taewan.kim/blog/2016/02/11/minsu-in-kokomong-lang/</link>
      <pubDate>Thu, 11 Feb 2016 16:58:42 +0900</pubDate>
      
      <guid>http://taewan.kim/blog/2016/02/11/minsu-in-kokomong-lang/</guid>
      <description>

&lt;p&gt;설날 대전 코코몽 키즈 랜드에서 신나게 자동차를 운전하는 민수입니다.&lt;/p&gt;

&lt;p&gt;때로는 너무 빨리 자라는 것 같아 아쉽기도 하네요..&lt;/p&gt;

&lt;p&gt;제발 이대로 건강하게만 자라라..&lt;/p&gt;

&lt;h2 id=&#34;레이서-민수:d13e8eade43ea80f23bf2fc8af3e6a16&#34;&gt;레이서 민수&lt;/h2&gt;


&lt;div style=&#34;position: relative; padding-bottom: 56.25%; padding-top: 30px; height: 0; overflow: hidden;&#34;&gt;
  &lt;iframe src=&#34;//www.youtube.com/embed/8BuqnJxi8CI&#34; style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%;&#34; allowfullscreen frameborder=&#34;0&#34;&gt;&lt;/iframe&gt;
 &lt;/div&gt;


&lt;h2 id=&#34;2016-02-13-아빠-사랑해:d13e8eade43ea80f23bf2fc8af3e6a16&#34;&gt;2016.02.13 아빠 사랑해&amp;hellip;.&lt;/h2&gt;

&lt;p&gt;
&lt;div style=&#34;position: relative; padding-bottom: 56.25%; padding-top: 30px; height: 0; overflow: hidden;&#34;&gt;
  &lt;iframe src=&#34;//www.youtube.com/embed/s_KZ5Fy8s1k&#34; style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%;&#34; allowfullscreen frameborder=&#34;0&#34;&gt;&lt;/iframe&gt;
 &lt;/div&gt;
&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>내 친구 Vagrant를 소개합니다.</title>
      <link>http://taewan.kim/blog/2016/02/06/vagrant_intro/</link>
      <pubDate>Sat, 06 Feb 2016 20:47:54 +0900</pubDate>
      
      <guid>http://taewan.kim/blog/2016/02/06/vagrant_intro/</guid>
      <description>

&lt;p&gt;&lt;img src=&#34;http://taewan.kim/images/vagrant/Vagrant.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Vagrant는 가상화 인스턴스를 관리하는 소프트웨입니다.
Vagrant의 실체는 가상 개발 환경을 생성하고 설정하기 위한 주요 가상화 소프트웨어의 고수준 레퍼입니다.
Vagrant가 지원하는 가상화 기술은 다음과 같습니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;VirtualBox&lt;/li&gt;
&lt;li&gt;VMware&lt;/li&gt;
&lt;li&gt;KVM&lt;/li&gt;
&lt;li&gt;Linux Container(LXC)&lt;/li&gt;
&lt;li&gt;Docker&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Vagrant는 위에서 나열한 프로바이더 기술을 기반으로하여 가상화 인스턴스를 효과적으로 생성하고  관리 일관성을 확보하는 방안을 제공합니다.
Vagrant의 가장 매력적인 부분은 가상 인스턴스를 만들고 실행하는 과정이 매우 빠르고 편리하다는 것입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://taewan.kim/images/vagrant/Vagrantup.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Vagrant의 사전적인 의미는 &amp;ldquo;부랑자&amp;rdquo;/&amp;ldquo;정처없는 사람&amp;rdquo; 이라는 사전적인 의미를 갖습니다.
Vagrant는 가상화 이미지를 효과적으로 만들고 테스트하는 유연한 환경이라는 의미에서 명명된 것이라고 생각됩니다. 쉽게 만들고 쉽게 버릴수 있고 다시 그 상태를 쉽게 복원할 수 있는 &amp;ldquo;Code as a Infrastructure&amp;rdquo; 개념을 반영한 오픈소스 프로젝트입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://taewan.kim/images/vagrant/vagrant_chilling.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;vagrant-프로젝트:47d9242757fa168a76ca0788ab673199&#34;&gt;Vagrant 프로젝트&lt;/h2&gt;

&lt;p&gt;Vagrant는  2010년 3월에 &amp;ldquo;Mitchell Hashimoto&amp;rdquo;가 시작한 오픈소스 프로젝트입니다.
2016년 2월 현재 최신 버전은 1.8.1입니다. 개발 언어는 Ruby이며 지원 플랫폼은 Linux, FreeBDS, OS X와 MS Window입니다. 2016년 현재 Vagrant의 주요 개발사는 HashiCorp입니다. HasiCorp는 샌프란시스코에 위치한 오픈소스 기업으로 2012년에 &amp;ldquo;Mitchell Hashimoto&amp;rdquo;가 설립하였습니다.&lt;/p&gt;

&lt;p&gt;Vagrant는 초기에 VirtualBox만을 지원하는 형태로 개발되었습니다. 그후 1.1버전 부터 다른 가상화 기술을 지원하기 시작했습니다. VMware와 KVM은 1.1버전에서 지원이 추가되었습니다. 1.6버전에서는 Docker를 새롭게 추가하였습니다.&lt;/p&gt;

&lt;h2 id=&#34;vagrant-설치:47d9242757fa168a76ca0788ab673199&#34;&gt;Vagrant 설치&lt;/h2&gt;

&lt;p&gt;앞에서 설명한 것처럼 Vagrant는 여러 가상화 프로바이더를 지원하는 툴입니다.
따라서 Vagrant를 설치하기 전에 사용할 가상화 프로바이더를 사전에 설치해야 합니다.&lt;/p&gt;

&lt;p&gt;Vagrant의 기본 가상화 프로바이더는 VirtualBox입니다.
VirtaulBox는 오라클가 프리웨어로 제공하는 가상화 기술입니다. 지원하는 운영체제는 Window, OS X, Linux, Solaris입니다. VirtualBox 설치 파일은 &lt;a href=&#34;https://www.virtualbox.org&#34;&gt;https://www.virtualbox.org&lt;/a&gt; 에서 다운받을 수 있습니다. VirtualBox 설치 파일의 크기는 운영체제에 따라 약간의 차이는 있지만 약 100Mb 내외 입니다.&lt;/p&gt;

&lt;p&gt;앞에서 설명한 것 처럼 Vagrant는 Ruby로 개발된 소프트웨어 입니다.
따라서 RubyGem으로 설치 가능합니다.
그러나 Vagrant 프로젝트에서는 RubyGem을 이용한 설치하는 방법보다 Vargant 홈페지이에서 바이너리를 다운로드 하는 것을 권장하고 있습니다. RubyGem을 사용할 경우 이전 버전이 설치될 가능성이 높기 때문입니다. Vagrant 다운로드 URL은 다음과 같습니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.vagrantup.com/downloads.html&#34;&gt;https://www.vagrantup.com/downloads.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;다운받은 Vagrant 설치 파일로 부터 설치를 완료한 후, Vagrant의 설치는 다음과 같은 명령으로 확인 할 수 있습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;taewan:demo taewan$ vagrant version
Installed Version: 1.8.1

Vagrant was unable to check for the latest version of Vagrant.
Please check manually at http://www.vagrantup.com
taewan:demo taewan$
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;vagrant-간단-둘러보기:47d9242757fa168a76ca0788ab673199&#34;&gt;Vagrant 간단 둘러보기&lt;/h2&gt;

&lt;p&gt;Vagrant Quick-Start를 하기 앞서 간단히 Vagrant 가 동작하는 방식에 대하여 알아보겠습니다.
Vagrant는 일반적으로 다음과 같은 단계로 작업을 수행합니다.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Box 이미지 다운로드&lt;/li&gt;
&lt;li&gt;Box이미지를 이용하여 프로젝트 생성&lt;/li&gt;
&lt;li&gt;프로젝트 최상위 디렉터리에 위치한 Vagrantfile 파일 수정&lt;/li&gt;
&lt;li&gt;프로젝트의 가상 인스턴스 시작&lt;/li&gt;
&lt;li&gt;가상 이미지 접속 및 작업&lt;/li&gt;
&lt;li&gt;가상 이미지 종료&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Vagrant는 프로젝트를 생성하기 앞서 여러 프로젝트가 공통적으로 사용할 Box를 다운로드합니다.
Box란 Vagrant에서 가상 이미지로 사용할 수 있도록 초기 설정된 바이너리 입니다.
Vagrant의 메인 개발사인 hashicorp는 여러 운영체제로 만든 Box를 제공합니다.
hasicorp의 &amp;ldquo;Atlas box catalog&amp;rdquo;에서 Box를 검색하고 다운로드 할 수 있습니다.
Box를 검색하고 다운로드를 지원하는 &amp;ldquo;Atlas box catalog&amp;rdquo;의 URL은 다음과 같습니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://atlas.hashicorp.com/boxes/search&#34;&gt;https://atlas.hashicorp.com/boxes/search&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;http://taewan.kim/images/vagrant/atlas.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&amp;ldquo;Atlas box catalog&amp;rdquo; 혹은 Box의 URL을 파라미터로 &amp;ldquo;vagrant box add&amp;rdquo; 명령을 이용하여 Box를 다운로드 할 수 있습니다.
다운받은 기본 Box는 ~/vagrant.d/boxes 디렉터리에 저장됩니다.
이 디렉터리에 위치한 각 Box는 프로바이더 별로 디렉터리를 구분하여 저장되며, 각 프로바이더 폴더에는 4개의 파일이 저장되어 있는 것을 확인 할 수 있습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;taewan:demo taewan$ vagrant box add  ubuntu/trusty64
==&amp;gt; box: Loading metadata for box &#39;ubuntu/trusty64&#39;
    box: URL: https://atlas.hashicorp.com/ubuntu/trusty64
==&amp;gt; box: Adding box &#39;ubuntu/trusty64&#39; (v20160206.0.0) for provider: virtualbox
    box: Downloading: https://atlas.hashicorp.com/ubuntu/boxes/trusty64/versions/20160206.0.0/providers/virtualbox.box
==&amp;gt; box: Successfully added box &#39;ubuntu/trusty64&#39; (v20160206.0.0) for &#39;virtualbox&#39;!
taewan:demo taewan$ vagrant box list
ubuntu/trusty64 (virtualbox, 20160206.0.0)
taewan:demo taewan$ 
taewan:demo taewan$ ls -al ~/.vagrant.d/boxes/
total 0
drwxr-xr-x  3 taewan  staff  102  2 10 00:00 .
drwxr-xr-x  9 taewan  staff  306  2 10 00:00 ..
drwxr-xr-x  4 taewan  staff  136  2 10 00:00 ubuntu-VAGRANTSLASH-trusty64
taewan:demo taewan$ tree ~/.vagrant.d/boxes/ubuntu-VAGRANTSLASH-trusty64/
/Users/taewan/.vagrant.d/boxes/ubuntu-VAGRANTSLASH-trusty64/
├── 20160206.0.0
│   └── virtualbox
│       ├── Vagrantfile
│       ├── box-disk1.vmdk
│       ├── box.ovf
│       └── metadata.json
└── metadata_url

2 directories, 5 files
taewan:demo taewan$ 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Vagrant는 가상 이미지 관리하기 위해서 프로젝트를 만듭니다.
각 프로젝트의 최상위 디렉터리에는 Vagrantfile 파일이 위치합니다.
이 파일은 Vagrant로 관리되는 가상 이미지 설정을 포함합니다.&lt;/p&gt;

&lt;p&gt;프로젝트 최상위 디텍터리에서 &amp;ldquo;vagrant up&amp;rdquo; 명령을 최초로 실행하면 vagrant는 &amp;ldquo;~/vagrant.d/boxes&amp;rdquo;에 위치한 box 이미지를 복사하여 지정된 프로바이더에 맞는 가상 이미지를 생성하고 Guest OS를 실행합니다.&lt;/p&gt;

&lt;h2 id=&#34;vagrant-5분-실습:47d9242757fa168a76ca0788ab673199&#34;&gt;Vagrant 5분 실습&lt;/h2&gt;

&lt;p&gt;Vagrant로 CentOS 가상 인스턴스를 만들고 로그인하여 사용하는 간단한 데모를 진행하겠습니다.&lt;/p&gt;

&lt;h3 id=&#34;box-이미지-카탈로그-조회:47d9242757fa168a76ca0788ab673199&#34;&gt;Box 이미지 카탈로그 조회&lt;/h3&gt;

&lt;p&gt;현재 호스트 머신에 설치된 Box이미지의 목록을 조회합니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;demo taewan$ vagrant box list
ubuntu/trusty64 (virtualbox, 20160206.0.0)
demo taewan$ 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;현재 호스트 머신에는 CentOS 이미지가 없는 것을 확인 할 수 있습니다.
&amp;ldquo;Atlas box catalog&amp;rdquo;에서 CentOS를 검색합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://taewan.kim/images/vagrant/box_catalog_centos.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;위 검색 결과에서 &amp;ldquo;centos/7&amp;rdquo;을 사용할 것을 결정합니다.&lt;/p&gt;

&lt;h3 id=&#34;box-이미지-다운로드:47d9242757fa168a76ca0788ab673199&#34;&gt;Box 이미지 다운로드&lt;/h3&gt;

&lt;p&gt;&amp;ldquo;vagrant box add&amp;rdquo; 명령으로 앞으로 사용할 CentOS 기본 이미지를 다운로드 합니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;demo taewan$ vagrant box add centos/7
==&amp;gt; box: Loading metadata for box &#39;centos/7&#39;
    box: URL: https://atlas.hashicorp.com/centos/7
This box can work with multiple providers! The providers that it
can work with are listed below. Please review the list and choose
the provider you will be working with.

1) libvirt
2) virtualbox

Enter your choice: 2
==&amp;gt; box: Adding box &#39;centos/7&#39; (v1509.01) for provider: virtualbox
    box: Downloading: https://atlas.hashicorp.com/centos/boxes/7/versions/1509.01/providers/virtualbox.box
==&amp;gt; box: Successfully added box &#39;centos/7&#39; (v1509.01) for &#39;virtualbox&#39;!
demo taewan$
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;설치가 완료되면 &amp;ldquo;vagrant box list&amp;rdquo;명령으로 설치 결과를 확인할 수 있습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;demo taewan$ vagrant box list
centos/7        (virtualbox, 1509.01)
ubuntu/trusty64 (virtualbox, 20160206.0.0)
demo taewan$
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;vagrant-프로젝트-생성-및-설정-파일-확인:47d9242757fa168a76ca0788ab673199&#34;&gt;Vagrant 프로젝트 생성 및 설정 파일 확인&lt;/h3&gt;

&lt;p&gt;Vagrant 프로젝트를 생성할 디렉터리를 생성한 후 Vagrant 프로젝트 초기화를 수행합니다.
프로젝트 초기화 명령(vagrant init)을 실행할 때 사용할 box를 지정할 수 있습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;workspace taewan$ pwd
/Users/taewan/workspace
workspace taewan$ vagrant init centos/7
A `Vagrantfile` has been placed in this directory. You are now
ready to `vagrant up` your first virtual environment! Please read
the comments in the Vagrantfile as well as documentation on
`vagrantup.com` for more information on using Vagrant.
workspace taewan$ ls
Vagrantfile
workspace taewan$ tree
.
└── Vagrantfile

0 directories, 1 file
workspace taewan$ cat Vagrantfile 
# 주석 제거
Vagrant.configure(2) do |config|
  config.vm.box = &amp;quot;centos/7&amp;quot;
end
workspace taewan$
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;vagrant-가상-이미지-실행-및-ssh-접근:47d9242757fa168a76ca0788ab673199&#34;&gt;Vagrant 가상 이미지 실행 및 ssh 접근&lt;/h3&gt;

&lt;p&gt;&amp;ldquo;vagrant up&amp;rdquo;명령으로 가상 이미지를 실행하고 &amp;ldquo;vagrant ssh&amp;rdquo;명령으로 가상 이미지에 ssh 접근이 가능합니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;workspace taewan$ vagrant up
Bringing machine &#39;default&#39; up with &#39;virtualbox&#39; provider...
==&amp;gt; default: Importing base box &#39;centos/7&#39;...
==&amp;gt; default: Matching MAC address for NAT networking...
==&amp;gt; default: Checking if box &#39;centos/7&#39; is up to date...
==&amp;gt; default: Setting the name of the VM: workspace_default_1455162125926_16977
==&amp;gt; default: Clearing any previously set network interfaces...
==&amp;gt; default: Preparing network interfaces based on configuration...
    default: Adapter 1: nat
==&amp;gt; default: Forwarding ports...
    default: 22 (guest) =&amp;gt; 2222 (host) (adapter 1)
==&amp;gt; default: Booting VM...
==&amp;gt; default: Waiting for machine to boot. This may take a few minutes...
    default: SSH address: 127.0.0.1:2222
    default: SSH username: vagrant
    default: SSH auth method: private key
    default: 
    default: Vagrant insecure key detected. Vagrant will automatically replace
    default: this with a newly generated keypair for better security.
    default: 
    default: Inserting generated public key within guest...
    default: Removing insecure key from the guest if it&#39;s present...
    default: Key inserted! Disconnecting and reconnecting using new SSH key...
==&amp;gt; default: Machine booted and ready!
==&amp;gt; default: Checking for guest additions in VM...
    default: No guest additions were detected on the base box for this VM! Guest
    default: additions are required for forwarded ports, shared folders, host only
    default: networking, and more. If SSH fails on this machine, please install
    default: the guest additions and repackage the box to continue.
    default: 
    default: This is not an error message; everything may continue to work properly,
    default: in which case you may ignore this message.
==&amp;gt; default: Installing rsync to the VM...
==&amp;gt; default: Rsyncing folder: /Users/taewan/workspace/ =&amp;gt; /home/vagrant/sync
workspace taewan$ vagrant ssh
[vagrant@localhost ~]$ uname -a
Linux localhost.localdomain 3.10.0-229.14.1.el7.x86_64 #1 SMP Tue Sep 15 15:05:51 UTC 2015 x86_64 x86_64 x86_64 GNU/Linux
[vagrant@localhost ~]$ exit
logout
Connection to 127.0.0.1 closed.
workspace taewan$  
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;ssh-config-파일-수정:47d9242757fa168a76ca0788ab673199&#34;&gt;ssh config 파일 수정&lt;/h3&gt;

&lt;p&gt;간편한 접근을 위하여 vagant는 ssh config 설정을 제공하는 명령을 제공합니다.
&amp;ldquo;vagrant ssh-config &amp;ndash;host [hostname]&amp;rdquo; 명령으로 ssh config를 위한 내용을 확인할 수 있습니다.
이 결과는 리다이렉션을 이용하여 ~/.ssh/config에 적용할 수 있습니다.
ssh config가 적용된 이후에는 ssh [hostname]으로 접근 가능합니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;workspace taewan$ # ssh config 설정 확인
workspace taewan$ vagrant ssh-config --host demo 
Host demo
  HostName 127.0.0.1
  User vagrant
  Port 2222
  UserKnownHostsFile /dev/null
  StrictHostKeyChecking no
  PasswordAuthentication no
  IdentityFile &amp;quot;/Users/taewan/workspace/.vagrant/machines/default/virtualbox/private_key&amp;quot;
  IdentitiesOnly yes
  LogLevel FATAL

workspace taewan$ # ssh config 적용
workspace taewan$ vagrant ssh-config --host demo &amp;gt;&amp;gt; ~/.ssh/config
workspace taewan$ # ssh 접근
workspace taewan$ ssh demo
Last login: Wed Feb 10 22:43:45 2016 from 10.0.2.2
[vagrant@localhost ~]$ uname -a
Linux localhost.localdomain 3.10.0-229.14.1.el7.x86_64 #1 SMP Tue Sep 15 15:05:51 UTC 2015 x86_64 x86_64 x86_64 GNU/Linux
[vagrant@localhost ~]$ exit
logout
Connection to 127.0.0.1 closed.
workspace taewan$
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;vagrant-상태-확인-및-종료:47d9242757fa168a76ca0788ab673199&#34;&gt;Vagrant 상태 확인 및  종료&lt;/h3&gt;

&lt;p&gt;다음 명령으로 Vagrant 인스턴스의 상태를 확인하고 종료할 수 있습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;workspace taewan$ # 인스턴스 상태 확인
workspace taewan$ vagrant status
Current machine states:

default                   running (virtualbox)

The VM is running. To stop this VM, you can run `vagrant halt` to
shut it down forcefully, or you can run `vagrant suspend` to simply
suspend the virtual machine. In either case, to restart it again,
simply run `vagrant up`.
workspace taewan$ # 인스턴스 종료
workspace taewan$ vagrant destroy
    default: Are you sure you want to destroy the &#39;default&#39; VM? [y/N] y
==&amp;gt; default: Forcing shutdown of VM...
==&amp;gt; default: Destroying VM and associated drives...
workspace taewan$ # 인스턴스 상태 확인
workspace taewan$ vagrant status
Current machine states:

default                   not created (virtualbox)

The environment has not yet been created. Run `vagrant up` to
create the environment. If a machine is not created, only the
default provider will be shown. So if a provider is not listed,
then the machine is not created for that environment.
taewanui-MacBook-Pro:workspace taewan$ 
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;동영상-데모-vagrant-quick-start-4min:47d9242757fa168a76ca0788ab673199&#34;&gt;동영상 데모 - Vagrant Quick-Start (4min)&lt;/h2&gt;


&lt;div style=&#34;position: relative; padding-bottom: 56.25%; padding-top: 30px; height: 0; overflow: hidden;&#34;&gt;
  &lt;iframe src=&#34;//www.youtube.com/embed/K2OFxx4n79w&#34; style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%;&#34; allowfullscreen frameborder=&#34;0&#34;&gt;&lt;/iframe&gt;
 &lt;/div&gt;


&lt;h2 id=&#34;vagrant-명령-요약:47d9242757fa168a76ca0788ab673199&#34;&gt;Vagrant 명령 요약&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;vagrant -v : 버전 확인&lt;/li&gt;
&lt;li&gt;vagrant status : 현재 프로젝트의 가상 이미지 상태 요약&lt;/li&gt;
&lt;li&gt;vagrant global-status : 호스트 머신 전체의 Vagrant 가상 이미지들의 상태 확인&lt;/li&gt;
&lt;li&gt;vagrant up : Vagrant 가상 이미지 시작&lt;/li&gt;
&lt;li&gt;vagrant halt : 가상 인스턴스 강제 종료&lt;/li&gt;
&lt;li&gt;vagrant destroy : 가상 이미지 종료 및 기존 이미지 삭제&lt;/li&gt;
&lt;li&gt;vagrant suspend : 가상 인스턴스 하이버네이트, 상태 보존&lt;/li&gt;
&lt;li&gt;vagrant resume : 중지된 인스턴스 시작&lt;/li&gt;
&lt;li&gt;vagrant reload : 변경된 VagrantFile 적용&lt;/li&gt;
&lt;li&gt;vagrant ssh : 현재 프로젝트의 가상 이미지에 ssh 접근&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;reference:47d9242757fa168a76ca0788ab673199&#34;&gt;Reference&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://gist.github.com/wpscholar/a49594e2e2b918f4d0c4&#34;&gt;https://gist.github.com/wpscholar/a49594e2e2b918f4d0c4&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.vagrantup.com/docs/&#34;&gt;https://www.vagrantup.com/docs/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Webhook 연동: git 서비스 &#43; jenkins</title>
      <link>http://taewan.kim/blog/2016/02/03/bitbucket_jenkins_webhook/</link>
      <pubDate>Wed, 03 Feb 2016 14:01:55 +0900</pubDate>
      
      <guid>http://taewan.kim/blog/2016/02/03/bitbucket_jenkins_webhook/</guid>
      <description>

&lt;p&gt;최근에 git 기반의 서비스들(github, bitbucket, gitlab)은 Webhooks 기능을 기본적으로 제공합니다.
Webhooks는 해당 git repository에 push, commtit, tag와 같은 이벤트가 발생하면 Jenkins와 같은 CI 서버에 이벤트를 전달하는 기능입니다.
Webhooks 이벤트를 전달받은 CI서버는 해당 프로젝트의 빌드 프로세스를 시작하는 방식으로 Git 레파지토리와 CI 서버를 연동하는 방법입니다.
Git 레파지토리가 호출하는 Webhooks는 HTTP URL(Restful 서비스)입니다.&lt;/p&gt;

&lt;h2 id=&#34;jenkins의-빌드-트리거:922394644e1f3ee8cce21149fbcc0a54&#34;&gt;Jenkins의 빌드 트리거&lt;/h2&gt;

&lt;p&gt;Webhooks 기능을 활성화 시키기 위해서 git 서비스에 Jenkins가 제공하는 URL을 등록해야 합니다.
Jenkins는 Job의 설정화면의 &amp;ldquo;빌드 트리거&amp;rdquo;에서 git서비스에 등록할 URL을 만들수 있습니다.&lt;/p&gt;

&lt;p&gt;Jenkins에 로그인하여 대상 Job을 선택한 후 아래 그림과 같이 configuration 메뉴를 클릭합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://taewan.kim/images/bitbucket/jenkins_config_1.png&#34; alt=&#34;BigDataLite&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Configuration 화면에서 아래 그림과 같이 상단 메뉴의 &amp;ldquo;Build Triggers&amp;rdquo;를 선택하여 &amp;ldquo;Build Triggers&amp;rdquo; 설정 부분으로 이동합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://taewan.kim/images/bitbucket/jenkins_config_2.png&#34; alt=&#34;BigDataLite&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&amp;ldquo;Build Triggers&amp;rdquo;영역에서는 지정한 프로젝트의 url을 확인하고 인증토큰을 설정하는 것을 제공합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://taewan.kim/images/bitbucket/jenkins_config_3.png&#34; alt=&#34;BigDataLite&#34; /&gt;&lt;/p&gt;

&lt;p&gt;위 예제를 통해서 인증토큰 값과 그 아래의 안내 URL을 조합하면 다음과 같은 URL을 만들 수 있습니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;TOKEN_NAME: iloveminsu&lt;/li&gt;
&lt;li&gt;URL: JENKINS_URL/job/build%20for%20taewan.kim%20blog/build?token=TOKEN_NAME&lt;/li&gt;
&lt;li&gt;JENKINS_URL: &lt;a href=&#34;http://ci.taewan.kim&#34;&gt;http://ci.taewan.kim&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;최종 URL은 다음과 같습니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://ci.taewan.kim/job/build%20for%20taewan.kim%20blog/build?token=iloveminsu&#34;&gt;http://ci.taewan.kim/job/build%20for%20taewan.kim%20blog/build?token=iloveminsu&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이 값을 git 서비스의 Webhooks에 등록해야 합니다.&lt;/p&gt;

&lt;h2 id=&#34;git-서비스에-webhook-등록:922394644e1f3ee8cce21149fbcc0a54&#34;&gt;git 서비스에 Webhook 등록&lt;/h2&gt;

&lt;p&gt;github, gitlab 그리고 Bitbucket은 유사한 형태의 Webhook 등록을 지원합니다.&lt;/p&gt;

&lt;h3 id=&#34;github의-webhooks-등록:922394644e1f3ee8cce21149fbcc0a54&#34;&gt;github의 webhooks 등록&lt;/h3&gt;

&lt;p&gt;github에서 webhooks를 설정하기 위해서는 github 레파지토리의 settings 텝을 클릭하여 설정 페이지로 이동해야 합니다.
&lt;img src=&#34;http://taewan.kim/images/bitbucket/webhook-github-01.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;settings 페이지에서 &amp;ldquo;Webhooks &amp;amp; Services&amp;rdquo;로 부터 webhooks으로 이동가능합니다.
&lt;img src=&#34;http://taewan.kim/images/bitbucket/webhook-github-02.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;다음과 같이 &amp;ldquo;Add webhook&amp;rdquo; 버튼을 클릭하여 최종 Webhook 등록 폼으로 이동합니다.
&lt;img src=&#34;http://taewan.kim/images/bitbucket/webhook-github-03.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;등록 폼에서 앞에서 알아낸 최종 URL은 등록하고 이벤트 유형을 선택한 후 저장하면 등록이 완료됩니다.
&lt;img src=&#34;http://taewan.kim/images/bitbucket/webhook-github-04.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;위 예제는 push 이벤트가 발생할 때에만 앞에서 지정한 URL을 호출하는 설정입니다.
push 이벤트 이외의 다른 이벤트를 지정하고자 할 경우에는 &amp;ldquo;Let me select individual events&amp;rdquo;를 선택하여 복수개의 다른 이벤트를 선택할 수 있습니다.&lt;/p&gt;

&lt;h3 id=&#34;gitlab의-webhooks-등록:922394644e1f3ee8cce21149fbcc0a54&#34;&gt;gitlab의 webhooks 등록&lt;/h3&gt;

&lt;p&gt;gitlab에서는 프로젝트 settings에서 다음과 같이 설정을 수행합니다.
프로젝트 메뉴에서 settings를 클릭하면 다음과 같은 설정 페이지로 이동합니다.
설정 페이지에서 &amp;ldquo;web hooks&amp;rdquo;를 선택하고 앞에서 정리한 URL과 이벤트를 선택하고 &amp;ldquo;Add Web Hook&amp;rdquo;을 클릭하여 등록합니다.
&lt;img src=&#34;http://taewan.kim/images/bitbucket/gitlab-01.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;bitbucket의-webhooks-등록:922394644e1f3ee8cce21149fbcc0a54&#34;&gt;bitbucket의 webhooks 등록&lt;/h3&gt;

&lt;p&gt;bitbucket에서는 다음과 같이 프로젝트 페이지에서 settings 메뉴를 클릭하여 프로젝트 설정 페이지로 이동합니다.
&lt;img src=&#34;http://taewan.kim/images/bitbucket/bitbucket-01.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;프로젝트 설정 페이지에서 webhooks메뉴와 &amp;ldquo;add webhook&amp;rdquo; 버튼을 클릭하여 webhook 등록 페이지로 이동합니다.
&lt;img src=&#34;http://taewan.kim/images/bitbucket/bitbucket-02.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;webhook 등록페이지에서는 제목, URL, 트리거 유형을 선택한 후 &amp;ldquo;Save&amp;rdquo;버튼을 클릭하여 등록을 완료합니다.
&lt;img src=&#34;http://taewan.kim/images/bitbucket/bitbucket-03.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;등록이 정상적으로 완료되었다면 다음과 같이 등록된 webhook을 확인 할 수 있습니다.
&lt;img src=&#34;http://taewan.kim/images/bitbucket/bitbucket-04.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;summary:922394644e1f3ee8cce21149fbcc0a54&#34;&gt;Summary&lt;/h2&gt;

&lt;p&gt;이렇게 git 서비스가 제공하는 Webhooks 기능을 사용하여 CI 서버와 Git레파지토리를 효과적으로 연동할 수 있습니다.
이 기능이 없다면 CI 서버는 주기적으로 Git 레파지토리를 Polling하여 변경이 감지될 경우 빌드 프로세스를 구동하는 방식을 취해야 합니다.
이는 매우 비효율적인 체계입니다. Webhooks를 사용할 경우 세부적인 이벤트 유형 구분이 가능합니다.
이러한 방식을 통해 원하는 시점을 세부적으로 정의하여 효과적인 Git 레파지토리와 CI 서버의 연동을 구성할 수 있습니다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>VirtualBox: 호스트에서 게스트 접근 네트웍 설정</title>
      <link>http://taewan.kim/blog/2016/01/31/virtualvox_network_config/</link>
      <pubDate>Sun, 31 Jan 2016 12:42:43 +0900</pubDate>
      
      <guid>http://taewan.kim/blog/2016/01/31/virtualvox_network_config/</guid>
      <description>

&lt;p&gt;최근에는 VirtualBox 이미지로 테스트 환경을 구성하거나 배포하는 경우가 많아졌습니다.
특히 오라클에서는 초기 테스트 및 교육 목적으로 다수의 VirtualBox 이미지를 배포하고 있습니다.
이렇게 만들어진 이미지를 사용할 경우 사용자는 새로운 기술을 접할 때 경험해야 하는 설치 및 구성에 대한 난제를 해결 할 수 있습니다.
즉 사용자는 새로운 기술의 기능 테스트 및 활용에 집중할 수 있게됩니다.&lt;/p&gt;

&lt;p&gt;오라클이 제공하는 VirtualBox 이미지는 Oracle Big Data Lite입니다.
Oracle Big Data Lite는 오라클의 빅데이터 소프트웨어 (CHD배포본 + Orale Software)의 최신 구성을 하나의 VirtualBox 이미지에 담아서 제공합니다.
이 이미지의 최신 버전은 4.3.X (2016.01 기준) 입니다.
Oracle Big Data Lite는 완전한 설정이 반영된 이미지이기 때문에, 사용자는 설치 및 번거로운 작업을 거치지 않고 바로 기능 테스트를 할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://taewan.kim/images/BigDataLite-Initial.png&#34; alt=&#34;BigDataLite&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;호스트에서-가상화-이미지에-접근할-수-있다면:e504ff6a47b9ec67ec6136666189d988&#34;&gt;호스트에서 가상화 이미지에 접근할 수 있다면&amp;hellip;&lt;/h2&gt;

&lt;p&gt;VirtualBox를 통해서 이미지를 실행한 후에는 VirtualBox가 제공하는 윈도우를 통해서 Guest OS에 접근을 할 수 있습니다.
그러나 Guest OS를 윈도우로 접근하는 방식은 비 효율적입니다.
Guest OS가 리눅스라면 VirtualBox가 구동하는 호스트에서 터미널로 Guest OS에 접근하여 작업하는 것이 더 효율적 입니다.
VirtualBox에 &amp;ldquo;Host Only Adapter&amp;rdquo;를 설정하면, Host OS에서 Guest OS에 접근할 수 있습니다.&lt;/p&gt;

&lt;h2 id=&#34;virtualbox의-host-only-adapter-설정:e504ff6a47b9ec67ec6136666189d988&#34;&gt;VirtualBox의 Host Only Adapter 설정&lt;/h2&gt;

&lt;p&gt;Host Only Adapter 설정은 VirtualBox 레벨에서 &amp;ldquo;새 호스트 전용 네트워크&amp;rdquo; 설정 단계와 Guest OS에서 Host Only Adapter 설정 단계로 구분됩니다.&lt;/p&gt;

&lt;h3 id=&#34;새-호스트-전용-네트워크-설정:e504ff6a47b9ec67ec6136666189d988&#34;&gt;새 호스트 전용 네트워크 설정&lt;/h3&gt;

&lt;p&gt;OS X를 기준으로 메뉴:VirtualBox -&amp;gt; 환경설정 -&amp;gt; 네트워크 텝 -&amp;gt; &amp;ldquo;호스트 전용 네트워크&amp;rdquo;에서 오른쪽의 &amp;ldquo;+&amp;ldquo;아이콘을 선택합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://taewan.kim/images/hostonlynetwork.png&#34; alt=&#34;Host Only Networks&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&amp;rdquo;+&amp;ldquo;아이콘을 선택하면 &amp;ldquo;vboxnet0&amp;rdquo;가 생성됩니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://taewan.kim/images/vboxnet0.png&#34; alt=&#34;vboxnet0&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&amp;ldquo;vboxnet0&amp;rdquo;를 더블클릭하여 아래와 같이 DHCP 설정을 합니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;서버사용: 선택&lt;/li&gt;
&lt;li&gt;서버주소: 192.168.56.100&lt;/li&gt;
&lt;li&gt;서버마스크: 255.255.255.0&lt;/li&gt;
&lt;li&gt;최저주소한계: 192.168.56.101&lt;/li&gt;
&lt;li&gt;최고주소한계: 192.168.56.154&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;http://taewan.kim/images/dscp.png&#34; alt=&#34;vboxnet0&#34; /&gt;
위와 같이 설정을 마치고 &amp;ldquo;저장&amp;rdquo;&amp;rdquo; 및 &amp;ldquo;확인&amp;rdquo;&amp;rdquo; 버튼을 클릭하여 네트워크 등록을 완료합니다.&lt;/p&gt;

&lt;h3 id=&#34;guest-os에-adapter-추가-host-only-adapter:e504ff6a47b9ec67ec6136666189d988&#34;&gt;Guest OS에 Adapter 추가 (Host Only Adapter)&lt;/h3&gt;

&lt;p&gt;Guest OS 선택 후 설정 메뉴 오픈, 네트워크 텝-&amp;gt;어탭터2를 선택하고 다음과 같은 설정을 합니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;네트워크 어뎁터 사용하기: 선택&lt;/li&gt;
&lt;li&gt;다음에 연결: Host Only Adapter 선택&lt;/li&gt;
&lt;li&gt;이름: vboxnet0&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;http://taewan.kim/images/adapter2.png&#34; alt=&#34;adapter2&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;새-호스트-전용-네트워크-설정-1:e504ff6a47b9ec67ec6136666189d988&#34;&gt;새 호스트 전용 네트워크 설정&lt;/h3&gt;

&lt;p&gt;Guest OS에 로그인하여 네트웍 정보를 확인 합니다.
terminal 상에서 ifconfig 명령으로 호스트에서 접근 할 IP를 확인할 수 있습니다.
(192.168.56.101)&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://taewan.kim/images/ipcheck.png&#34; alt=&#34;ipcheck&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;host-os에서-guest-os에-접근:e504ff6a47b9ec67ec6136666189d988&#34;&gt;Host OS에서 Guest OS에 접근&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;ssh 접근 결과&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;taewanui-MacBook-Pro:demo taewan$ ssh oracle@192.168.56.101
oracle@192.168.56.101&#39;s password: 
Last login: Thu Jan 28 16:00:34 2016 from 192.168.56.1
[oracle@bigdatalite ~]$
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;hue 접근 결과

&lt;ul&gt;
&lt;li&gt;Big Data Lite는 8888포트로 Hue를 제공합니다.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;http://taewan.kim/images/hue.png&#34; alt=&#34;ipcheck&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;요약:e504ff6a47b9ec67ec6136666189d988&#34;&gt;요약&lt;/h2&gt;

&lt;p&gt;VirtualBox에 Host Only Network를 추가하고 DHCP를 설정한 후 Guest OS에 Host Only Adapter를 등록하면 Host OS에서 Guest OS에 네트웍 접근이 가능합니다. 설정 절차를 요약하면 다음곽 같습니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;VirtualBox에 Host Only Network 추가

&lt;ul&gt;
&lt;li&gt;추가된 네트워크에 DHCP 설정&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;접근할 Guest OS에 네트웍 어뎁터 추가

&lt;ul&gt;
&lt;li&gt;Host Only Adapter&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Guest OS에 로그인하여 접속 IP체크

&lt;ul&gt;
&lt;li&gt;ifconfig command in terminal&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Host OS에서 Guest OS에 접근&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>ssh 사용을 단순화하기 위한 ssh config 설정</title>
      <link>http://taewan.kim/blog/2016/01/28/ssh_config/</link>
      <pubDate>Thu, 28 Jan 2016 13:12:54 +0900</pubDate>
      
      <guid>http://taewan.kim/blog/2016/01/28/ssh_config/</guid>
      <description>

&lt;p&gt;사용자 홈디렉터리의 ~/.ssh/config 파일에 host 별 설정을 추가하면 ssh 명령 사용을 단순화 할 수 있습니다.
본 문서는 ~/.ssh/config 파일의 설정만을 다룹니다. ssh와 ssh key에 대해서는 궁굼하시다면 다음 문서를 참조하시기 바랍니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ssh 원격제어: &lt;a href=&#34;https://opentutorials.org/module/432/3738&#34;&gt;https://opentutorials.org/module/432/3738&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;ssh key: &lt;a href=&#34;https://opentutorials.org/module/432/3742&#34;&gt;https://opentutorials.org/module/432/3742&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ssh의 기본 사용법은 다음과 같습니다 .
다음과 같은 명령을 내릴때 ssh 명령은 &amp;ldquo;~/.ssh/id_rsa&amp;rdquo; 인증서를 사용하여, 52.79.103.139 서버에 ubuntu로 로그인을 시도합니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;taewanui-MacBook-Pro:~ taewan$ ssh ubuntu@52.79.103.139
Welcome to Ubuntu 14.04.3 LTS (GNU/Linux 3.13.0-74-generic x86_64)

Last login: Mon Feb  1 01:44:13 2016 from 211.210.76.6
ubuntu@ip-172-31-11-175:~$ pwd
/home/ubuntu
ubuntu@ip-172-31-11-175:~$ 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;기본 인증서가 다른 인증서를 사용해야 할 경우에는 다음과 같이 -i 옵션을 사용해야 합니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;taewanui-MacBook-Pro:demo taewan$ ssh ubuntu@52.79.103.139 -i ~/.ssh/aws-seoul.pem
Welcome to Ubuntu 14.04.3 LTS (GNU/Linux 3.13.0-74-generic x86_64)

Last login: Mon Feb  1 02:10:40 2016 from 211.210.76.6
ubuntu@ip-172-31-11-175:~$ 

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;위 명령의 경우 인증서를 직접 지정해야 하기 때문에 사용하기 부담스러운 면이 있습니다. ssh을 단순하게 사용하는 방법중에 하나는 다음과 같은 alias를 사용하는 것 입니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;taewanui-MacBook-Pro:demo taewan$ alias awsssh=&amp;quot;ssh ubuntu@52.79.103.139 -i ~/.ssh/aws-seoul.pem&amp;quot;
taewanui-MacBook-Pro:demo taewan$ awsssh
Welcome to Ubuntu 14.04.3 LTS (GNU/Linux 3.13.0-74-generic x86_64)

Last login: Mon Feb  1 02:23:47 2016 from 211.210.76.6
ubuntu@ip-172-31-11-175:~$
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;alias를 사용하면 명령을 쉽게 입력할 수 는 있지만 관리 비용이 증가합니다. 또한 ssh 명령은 인증서, 서버 포트, 포트포워딩 등 다양한 설정 옵션이 있기 때문에 이러한 변경을 효과적으로 대응하기에 어렵다는 단점이 있습니다.&lt;/p&gt;

&lt;h1 id=&#34;ssh-사용-단순화-ssh-config:0984e7ebd3dce43c74ff94df48f1ae75&#34;&gt;ssh 사용 단순화:~/.ssh/config&lt;/h1&gt;

&lt;p&gt;이러한 문제를 해법은 &amp;ldquo;~/.ssh/config&amp;rdquo;을 사용하는 것 입니다. 다음은 일반적인 형태의 ~/.ssh/config 파일의 내용입니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;### for aws
Host aws-ubuntu1
    HostName 52.79.103.139
    IdentityFile ~/.ssh/aws-seoul.pem

Host aws-ubuntu2
    HostName 52.79.103.139
    User ubuntu
    IdentityFile ~/.ssh/aws-seoul.pem   

## for git
Host github.com 
    User git
    IdentityFile ~/.ssh/id_rsa_XXXXXXXXXXXX
Host bitbucket.org
    User git
    IdentityFile ~/.ssh/id_rsa_@@@@@@@@@@@@
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;위 config에서는 2개의 아마존 서버와 github 및 bitbucket 서버 4개의 서버에 대한 ssh 설정이 서버 별로 등록되어 있습니다.
위 예제에서 아마존 aws 서버는 다음의 두 가지 방법으로 로그인 할 수 있습니다.
ssh config 설정을 사용 할 경우 복수의 인증서를 사용하는 상황에서도 ssh 명령을 단순하게 유지할 수 있습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;taewanui-MacBook-Pro:demo taewan$ ssh ubuntu@aws-ubuntu1
Welcome to Ubuntu 14.04.3 LTS (GNU/Linux 3.13.0-74-generic x86_64)

Last login: Mon Feb  1 02:37:28 2016 from 211.210.76.6
ubuntu@ip-172-31-11-175:~$ 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;아래의 경우 aws-ubuntu2에 로그인 계정 명을 등록하였기 때문에 ssh 명령을 더욱 단순하게 사용 가능합니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;taewanui-MacBook-Pro:demo taewan$ ssh aws-ubuntu2
Welcome to Ubuntu 14.04.3 LTS (GNU/Linux 3.13.0-74-generic x86_64)

Last login: Mon Feb  1 02:56:27 2016 from 211.210.76.6
ubuntu@ip-172-31-11-175:~$ 
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;ssh-config-파일:0984e7ebd3dce43c74ff94df48f1ae75&#34;&gt;~/.ssh/config 파일&lt;/h2&gt;

&lt;p&gt;ssh config 설정 파일의 사용자별 위치는 &amp;ldquo;~/.ssh/config&amp;rdquo;입니다.&lt;/p&gt;

&lt;h3 id=&#34;설정-파일-권한:0984e7ebd3dce43c74ff94df48f1ae75&#34;&gt;설정 파일 권한&lt;/h3&gt;

&lt;p&gt;ssh 설정 파일은 다른 사용자가 사용할 경우 심각한 권한 문제가 발생할 수 있습니다.
따라서 다음과 같은 권한으로 설정되어야 합니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;chmod 440 ~/.ssh/config
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;설정-파일-유형:0984e7ebd3dce43c74ff94df48f1ae75&#34;&gt;설정 파일 유형&lt;/h3&gt;

&lt;p&gt;ssh 설정 파일의 기본 형태는 다음과 같습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Host firsthost
    SSH_OPTION_1 custom_value
    SSH_OPTION_2 custom_value
    SSH_OPTION_3 custom_value

Host secondhost
    ANOTHER_OPTION custom_value

Host *host
    ANOTHER_OPTION custom_value

Host *
    CHANGE_DEFAULT custom_value
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ssh 설정 파일의 옵션 값은 다음과 같이 3가지 방법으로 값을 설정 할 수 있습니다.
다음 3 가지는 모두 유효한 설정입니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Port 4567
Port=4567
Port = 4567
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;호스트-맵핑:0984e7ebd3dce43c74ff94df48f1ae75&#34;&gt;호스트 맵핑&lt;/h3&gt;

&lt;p&gt;호스트 맵핑은 Host 속성과 Hostname 속성을 이용하여 실제 호스트 URL에 맵핑을 합니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Host: ssh 명령에 사용하는 이름&lt;/li&gt;
&lt;li&gt;Hostname: Host에 지정된 이름이 매핑되는 실제 호스트 명&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;Host dev
	HostName dev.taewan.kim
	Uset admin
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;위와 같이 설정된 상태에서 &amp;ldquo;ssh dev&amp;rdquo;이 실행된다면 다음과 같은 명령으로 변환되어 실행됩니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ssh admin@dev.taewan.kim -i ~/.ssh/id_rsa&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;2차-도메인-등-와일드카드-문자-지정:0984e7ebd3dce43c74ff94df48f1ae75&#34;&gt;2차 도메인 등 와일드카드 문자 지정&lt;/h3&gt;

&lt;p&gt;다음과 같이 와일드카드 문자로 호스트 명을 지정 할 수 있습니다. 이 경우 taewan.kim의 서브 도메인에 모두 적용됩니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Host *.taewan.kim
    User taewan
    PreferredAuthentications publickey
    IdentityFile ~/.ssh/taewan.dev
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;설정-파일-주요-속성:0984e7ebd3dce43c74ff94df48f1ae75&#34;&gt;설정 파일 주요 속성&lt;/h2&gt;

&lt;h3 id=&#34;일반-설정:0984e7ebd3dce43c74ff94df48f1ae75&#34;&gt;일반 설정&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Hostname: 연결될 서버 호스트 명으로 사용됨.

&lt;ul&gt;
&lt;li&gt;선택적 속성&lt;/li&gt;
&lt;li&gt;미 설정시 Host 값이 Hostname으로 사용됨&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;User: 네트웍 커넥션에 사용되는 계정 명&lt;/li&gt;
&lt;li&gt;Port: 원격 ssh 데몬이 사용하는 포트, 기본 값=22&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;네트웍-설정:0984e7ebd3dce43c74ff94df48f1ae75&#34;&gt;네트웍 설정&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;ServerAliveInterval

&lt;ul&gt;
&lt;li&gt;서버에 테스트 패킷을 전송하는 주기 설정&lt;/li&gt;
&lt;li&gt;초단위 설정&lt;/li&gt;
&lt;li&gt;기본 값: 0&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;ServerAliveCountMax

&lt;ul&gt;
&lt;li&gt;서버에 테스트용 패킷을 전송하는 횟수를 설정&lt;/li&gt;
&lt;li&gt;서버에 추가적인 데이터 전송 없이 ServerAliveInterval의 최대 임계 값을 초과할 경우 커넥션 종료&lt;/li&gt;
&lt;li&gt;기본값: 3&lt;/li&gt;
&lt;li&gt;예: ServerAliveInterval 15, ServerAliveCountMax 3

&lt;ul&gt;
&lt;li&gt;통신없이 45초 결과후 커넥션 종료&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;LogLevel

&lt;ul&gt;
&lt;li&gt;클라이언트 측의 로그 레벨&lt;/li&gt;
&lt;li&gt;최소 로그: QUIET&lt;/li&gt;
&lt;li&gt;최대 로그: DEBUG3&lt;/li&gt;
&lt;li&gt;설정 가능 값

&lt;ul&gt;
&lt;li&gt;QUIET&lt;/li&gt;
&lt;li&gt;FATAL&lt;/li&gt;
&lt;li&gt;ERROR&lt;/li&gt;
&lt;li&gt;INFO&lt;/li&gt;
&lt;li&gt;VERBOSE&lt;/li&gt;
&lt;li&gt;DEBUG1&lt;/li&gt;
&lt;li&gt;DEBUG2&lt;/li&gt;
&lt;li&gt;DEBUG3&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;StrictHostKeyChecking

&lt;ul&gt;
&lt;li&gt;~/.ssh/known_hosts에 자동으로 호스트를 추가하는 설정&lt;/li&gt;
&lt;li&gt;기본 설정은 저장을 질문 함&lt;/li&gt;
&lt;li&gt;비활성 설정: &amp;ldquo;no&amp;rdquo;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;UserKnownHostsFile

&lt;ul&gt;
&lt;li&gt;연결된 호스트에 대한 정보를 남기는 파일을 지정하는 설정&lt;/li&gt;
&lt;li&gt;기본 값: ~/.ssh/known_hosts&lt;/li&gt;
&lt;li&gt;일반적으로 이 설정을 변경하지 않음&lt;/li&gt;
&lt;li&gt;StrictHostKeyChecking을 &amp;ldquo;no&amp;rdquo;로 설정할 경우에 이 설정을 &amp;ldquo;/dev/null&amp;rdquo;로 설정ㄱㄷ유&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;VisualHostKey

&lt;ul&gt;
&lt;li&gt;원격지의 호스트 키를 클라이언트 접속시 출력&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Compression

&lt;ul&gt;
&lt;li&gt;느린 네트웍 상에서 네트웍 패킷을 압축하는 옵션&lt;/li&gt;
&lt;li&gt;일반적인 상황에서 사용하지 않음&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;키-지정:0984e7ebd3dce43c74ff94df48f1ae75&#34;&gt;키 지정&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;IdentityFile

&lt;ul&gt;
&lt;li&gt;Host 별로 사용할 키의 위치를 지정&lt;/li&gt;
&lt;li&gt;기본값: 프로토콜에 따라 결정 됨

&lt;ul&gt;
&lt;li&gt;~/.ssh/id_rsa&lt;/li&gt;
&lt;li&gt;~/.ssh/id_dsa&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;multiplexing:0984e7ebd3dce43c74ff94df48f1ae75&#34;&gt;Multiplexing&lt;/h3&gt;

&lt;p&gt;ssh는 하나의 서버에 접속하는 여러 ssh 커넥션을 하나의 TCP 커넥션을 사용하여 연결하는 기능을 제공합니다.
복수의 SSH 커넥션으로 발생하는 부하를 제거하는 용도로 적합&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ControlMaster

&lt;ul&gt;
&lt;li&gt;Multiplexing을 허용하는 옵션&lt;/li&gt;
&lt;li&gt;허용 설정 값: auto&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;ControlPath

&lt;ul&gt;
&lt;li&gt;커넥션을 제어하는 용도로 사용하는 socket 파일 지정&lt;/li&gt;
&lt;li&gt;/path/to/socket/%r@%h:%p

&lt;ul&gt;
&lt;li&gt;r: username&lt;/li&gt;
&lt;li&gt;h: remote host&lt;/li&gt;
&lt;li&gt;p: port&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;ControlPersist

&lt;ul&gt;
&lt;li&gt;커넥션이 유지해야 할 시간을 초단위로 지정&lt;/li&gt;
&lt;li&gt;초단위 설정&lt;/li&gt;
&lt;li&gt;낮은 값을 설정할 경우 불필요한 커넥션 연결 오픈을 방지할 수 있음&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>JBoss Seam 로고의 의미</title>
      <link>http://taewan.kim/blog/2016/01/27/seam_log/</link>
      <pubDate>Wed, 27 Jan 2016 10:50:36 +0900</pubDate>
      
      <guid>http://taewan.kim/blog/2016/01/27/seam_log/</guid>
      <description>

&lt;p&gt;2008~2009년도에는 JBoss Seam에 몰입했던 기시였습니다. 그 당시에 작성했던 글입니다. 오픈소스를 이해할 때 오픈소스의 이름과 로고가 담고 있는 의미를 이해하는 성움이 됩니다. 오픈소스 이름과 로고를 이렇게 해석했구나 라는 사례로 봐 주시면 좋을 것 같습니다. 그럼 2009년으로 들어가 보겠습니다.&lt;/p&gt;

&lt;h1 id=&#34;seam-framework-로고는-어떤-의미일까요:f19f716c8aeb01c785b0b485dd6debca&#34;&gt;Seam Framework 로고는 어떤 의미일까요?&lt;/h1&gt;

&lt;p&gt;Seam Framework은 기존과 차별되는 독특한 컴포넌트 관리 모델을 제안하고 있습니다. 기존에 Java EE 애플리케이션은 Web 티어와 EJB 티어로 구분되어 있기 때문어 상호간에 참조하기가 어려웠습니다. 웹 에서 EJB 컴포넌트를 참조하기 위해서는 JNDI Lookup과 Casting 작업이 선행되어야 했습니다.&lt;/p&gt;

&lt;p&gt;이렇다 보니 Java EE의 핵심 컴포넌트인 JSF 컴포넌트와 EJB 컴포넌트는 Java EE의 핵심 컴포넌트이기는 하지만 상호간을 참조하는 것은 여간 번거로운 작업이 아닐수 없었습니다.&lt;/p&gt;

&lt;p&gt;왜 이런일이 발생할까? 라는 고민에서 Seam Framework이 시작되었다고 보셔도 좋을것 같습니다.&lt;/p&gt;

&lt;p&gt;처음 Seam을 접할때 Seam이란 의미는 Seamless의 약자가 아닐까? 라는 생각을 했습니다. Seam의 컴포넌트 모델을 보다 보면 다음과 같은 이미지를 연상하게 됩니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://taewan.kim/images/seamlogo.png&#34; alt=&#34;Seam Logo&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;seam-framework-logo는-이런-의미를-담고-있지-않을까요:f19f716c8aeb01c785b0b485dd6debca&#34;&gt;Seam Framework Logo는 이런 의미를 담고 있지 않을까요?&lt;/h2&gt;

&lt;p&gt;개인적인 추측에 불과하지만 Seam Framework의 빗살 무늬 로고는 이런 의미를 담고 있는 것이 아닌가라는 생각을 해 보았습니다.&lt;/p&gt;

&lt;p&gt;동일한 JVM에서 구동하는 WAS의 컴포넌트를 통합하여 사용할 수 있도록 지원하는 것이 Seam 프레임웍의 시작점 입니다. 이렇게 Java EE 컴포넌트를 통합하는 모델위에 컴포넌트가 서로를 상호 참조하는 의존성 주입 모델이 결합되면 이것이 최종 Seam 컴포넌트 관리 모델이 됩니다.&lt;/p&gt;

&lt;p&gt;Seam 컴포넌트 모델은 지난 번에 말씀 드렸던 것 처럼 JSR - 299 스펙 CDI (Context and Dependency Injection)의 토대가 되고 있고, 현재 Seam의 모습으로 JSR - 299가 정의 되고 있습니다.&lt;/p&gt;

&lt;p&gt;웹컴포넌트와 EJB 컴포넌트가 통합되어 관리 된다는 것은 어떤 의미일까요?&lt;/p&gt;

&lt;p&gt;이것은 다음과 같은 코드를 보시면 좋을 것 같습니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;JSP 코드 예제&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-jsp&#34;&gt; &amp;lt;h:form&amp;gt;
    &amp;lt;h:inputText value=&amp;quot;#{person.name}&amp;quot; /&amp;gt;&amp;lt;br/&amp;gt;
    &amp;lt;h:commandButton type=&amp;quot;submit&amp;quot;  value=&amp;quot;submit&amp;quot; 
        action=&amp;quot;#{manager.sayHello}&amp;quot; /&amp;gt;
&amp;lt;/h:form&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;위와 같은 JSP 코드가 존재한다고 생각해 보시기바랍니다.
이코드를 보면 다음과 같은 것을 추측할 수 있습니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;폼에 하나의 입력 텍스트와 하나의 버튼으로 구성&lt;/li&gt;
&lt;li&gt;입력 텍스트에 입력된 값은 person 객체의 name 필드에 저장됨&lt;/li&gt;
&lt;li&gt;버튼을 클릭하면 manager 객체의 sayHello 메서드가 실행됨&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;person과 manager 객체의 실체는 무엇일까요? person 객체는 다음과 같을 수 있습니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Person 객체&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Entity
@Name(&amp;quot;person&amp;quot;)
public class Person implements Serializable{
  private long id;
  private String name;
  //이하 코드 생략
  //getter-setter
  //Annotation
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;person 객체의 실체는 위와 같을 수 있습니다. 실제 Person 객체는 Seam Person 컴포넌트라고 하는 것이 정확한 표현입니다. Person 객체를 person 이라는 이름으로 참조 할 수 있는 것은  바로 Seam이 제공하는 컴포넌트 관리 모델때문입니다.&lt;/p&gt;

&lt;p&gt;그런데 Person 객체는 실제로 Entity Bean입니다. JPA에서 ORM으로 사용하는 POJO 객체입니다. JPA는 Java SE에서도 구동되는 기술임을 감안하면 아직까지는 크게 이상할 것은 없는 코드 입니다.&lt;/p&gt;

&lt;p&gt;그렇다면 manager 객체, 더 정확히 말해서 manager 컴포넌트의 실체는 무엇일까요?&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;manager 컴포넌트&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Stateless
@Name(&amp;quot;manager&amp;quot;)
public class ManagerAction implements Manager{
    @In @Out Person person;
    @Out List&amp;lt;Person&amp;gt; personList;
    @PersistenceContext EntityManager em;

    public String sayHello(){
      em.persist(person);
      person = null;
      return null;
    }
   //이하 코드 생략
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;여러가지 manager 컴포넌트 스타일을 생각해 볼 수 있지만 위와 같은 코드가 일반적입니다. 놀라운 것은 manager 컴포넌트는 실제 무상태 세션 빈이라는 것입니다. JSP 페이지의 테그라이브러리의 Expression Language 형태로 설정한 형태는 실제 세션빈의 메서드를 호출하는 것이었습니다.&lt;/p&gt;

&lt;p&gt;JSP를 통하여 별다른 작업 없이 ejb를 직접 호출하는 형태 입니다. JSF에 익숙하신 분들에게는 이렇게 표현하실 수 있습니다. (위 JSP는 실제 JSF 페이지 코드의 일부 입니다. )&lt;/p&gt;

&lt;h2 id=&#34;seam은-세션빈을-액션-리스너로-직접-사용할-수-있다:f19f716c8aeb01c785b0b485dd6debca&#34;&gt;Seam은 세션빈을 액션 리스너로 직접 사용할 수 있다.&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;JSF로 이런한 기능을 구현하기 위해서는 다음과 같은 작업을 거치게 됩니다&lt;/li&gt;
&lt;li&gt;JSF페이지에서 managed bean으로 등록된 컴포넌트의 메소드를 호출 그 메서드가 JDNI 룩업을 하고 전처리를 수행&lt;/li&gt;
&lt;li&gt;ejb를 호출&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Seam은 이런 절차를 모두 생략하고 직접 세션빈을 액션 리스너로 사용할 수 있는 방법을 제공합니다.&lt;/p&gt;

&lt;p&gt;이것이 Seam에서 이야기하는 컴포넌트 통합 모델의 근간 입니다.&lt;/p&gt;

&lt;p&gt;Seam은 기존에 경험하지 못했던 새로운 개념의 통합 컴포넌트 모델 관리 개념을 제공합니다. 컴포넌트를 직접 참조하는 것이 아니라 컴포넌트 이름으로 참조하고 이것을 관리하는 것은 Seam 프레임웍이 전담하는 형태입니다.&lt;/p&gt;

&lt;p&gt;사실 EJB 컴포넌트와 Web 컴포넌트를 통합하는 것은 Seam의 핵심 기능이기는 하지만 가장 밑바탕이 되는 기능중의 일부 입니다. Seam은 기존의 Dependency Injection을 확장하여 Bijection이라는 개념과 Context 개념을 강화하여 진보된 컴포넌트 관리 모델을 제공합니다.&lt;/p&gt;

&lt;p&gt;이런 의미에서 앞에서 살펴 보았던 Seam Logo 이미지를 다시 한번 살펴 보도록 하겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://taewan.kim/images/seamlogo.png&#34; alt=&#34;Seam Logo&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Seam 프레임웍 로고로 사용하는 빗살 무늬 로고는 아마도 두 개의 Tier로 나누어져 있는 컴포넌트를 서로 연결하는 상호작용 할 수 있도록 지원한다는 의미라고 저는 생각하고 있습니다.&lt;/p&gt;

&lt;p&gt;여러분들은 어떻게 보이시나요?&lt;/p&gt;

&lt;p&gt;간혹 이런 의미를 생각해 보는 것도 재미있는 것 같습니다.^^&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Hugo의 Syntax Highlight기능 구성</title>
      <link>http://taewan.kim/blog/2016/01/25/codehighlight/</link>
      <pubDate>Mon, 25 Jan 2016 17:19:38 +0900</pubDate>
      
      <guid>http://taewan.kim/blog/2016/01/25/codehighlight/</guid>
      <description>

&lt;p&gt;현재 taewan.kim은 블러그 생성 엔진으로 Hugo를 테마로는 Hyde-x를 사용하고 있습니다.
제가 Hugo를 처음 사용하면서 가장 혼동된 부분은 Syntax Hightlight를 구성하는 과정이었습니다.
Hugo에 대한 배경 지식이 부족하다 보니 Hugo의 Syntax Hightlight 기능에 대한 혼돈이 있었습니다.
이 부분에 대하여 간략히 정리해 보겠습니다.&lt;/p&gt;

&lt;h1 id=&#34;hugo의-syntax-highlight기능-지원-타입:8249a9659163c14ad6dd21231787110e&#34;&gt;Hugo의 Syntax Highlight기능 지원 타입&lt;/h1&gt;

&lt;p&gt;Hugo는 서버사이드 모드와 클라이언트 모드로 Syntax Highlight기능을 제공합니다.
서버사이드/클라이언트 모드는 Hugo의 config 파일에서 설정 됩니다.&lt;/p&gt;

&lt;h2 id=&#34;서버사이드-모드의-syntax-highlight:8249a9659163c14ad6dd21231787110e&#34;&gt;서버사이드 모드의 Syntax Highlight&lt;/h2&gt;

&lt;p&gt;서버사이드 모드는 빌드 시점에 Syntax Hightlight가 적용된 HTML을 생성하는 방식으로 pygments를 사용합니다.
pygments는 파이썬으로 만들어진 툴로 일반 코드에 syntax highlight를 적용하는 툴입니다.
서버사이드 모드를 사용하기 위해서는 hugo 빌드에 앞서 pygments가 사전에 설치되어 있어야 합니다.(pip install pygments)&lt;/p&gt;

&lt;h2 id=&#34;클라이언트-모드의-syntax-highlight:8249a9659163c14ad6dd21231787110e&#34;&gt;클라이언트 모드의 Syntax Highlight&lt;/h2&gt;

&lt;p&gt;클라이언트 모드는 브라우저에서 페이지를 로딩할 때 Syntax Highlight가 적용되는 방식으로,
다음과 같은 라이브러리를 사용합니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Highlight.js&lt;/li&gt;
&lt;li&gt;Prism&lt;/li&gt;
&lt;li&gt;Rainbow&lt;/li&gt;
&lt;li&gt;Syntax Highlighter&lt;/li&gt;
&lt;li&gt;Google Prettify&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;클라이언트-모드와-서버-모드의-syntax-highlight-기능-지원:8249a9659163c14ad6dd21231787110e&#34;&gt;클라이언트 모드와 서버 모드의 Syntax Highlight 기능 지원&lt;/h2&gt;

&lt;p&gt;Hugo는 두가지 모드에 대하여 적합한 변환을 Hugo 빌드 시 적용합니다.
그러나 두 변환 방식 중 어떤 것을 사용할 것인가는 일반적으로 테마가 결정합니다.
일반적으로 Theme의 README.md파일에 보면 어떤 방식을 지원하는지에 대한 설명이 기술되어 있습니다.&lt;/p&gt;

&lt;p&gt;현재 사용하고 있는 Hyde-X는 클라이언트 모드 만을 지원합니다.
Hyde-X는 Hightlight.js를 이용하여 Highlight기능을 구현합니다.
사실 Hyde-X가 서버사이드 모드도 지원하지만, 최종 빌드된 결과가 투박하고 가독성이 떨어집니다.
따라서 Hyde-x를 사용할 경우에는 클라이언트 모드를 사용하는 것이 효과적입니다.&lt;/p&gt;

&lt;h2 id=&#34;각-모드-별-설정-옵션-및-표기법:8249a9659163c14ad6dd21231787110e&#34;&gt;각 모드 별 설정 옵션 및 표기법&lt;/h2&gt;

&lt;h3 id=&#34;클라이언트-모드:8249a9659163c14ad6dd21231787110e&#34;&gt;클라이언트 모드&lt;/h3&gt;

&lt;p&gt;클라이언트 모드 설정은 config 파일에 highlight 속성으로 표시합니다.
highlight에 설정 가능한 값은 &lt;hugo_site&gt;/themes/static/css/highlight에서 확인 할 수 있습니다.
다음은 설정 예입니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; # Check the static/css/highlight directory for options.
 highlight = &amp;quot;github&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;~~~java
public static void main(String args[]){

}
~~~
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;위 설정에 대한 결과는 다음과 같습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static void main(String args[]){

}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;서버사이드-모드:8249a9659163c14ad6dd21231787110e&#34;&gt;서버사이드 모드&lt;/h3&gt;

&lt;p&gt;설정 옵션은 다음과 같습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pygmentsstyle = &amp;quot;monokai&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;유효한 설정 값은 &lt;a href=&#34;http://pygments.org/&#34;&gt;http://pygments.org/&lt;/a&gt; 에서 확인 할 수 있습니다.&lt;/p&gt;

&lt;h2 id=&#34;삽질-요약:8249a9659163c14ad6dd21231787110e&#34;&gt;삽질 요약&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Hugo는 클라이언트 모드와 서버사이드 모드의 Highlight를 지원한다.&lt;/li&gt;
&lt;li&gt;두 모드 중에서 사용 가능한 방식은 현재 사이트의 적용 테마가 결정한다.&lt;/li&gt;
&lt;li&gt;테마가 클라이언트 모드를 지원할 경우, highlisht 스타일은 static/css/highlight에서 확인 가능하다.&lt;/li&gt;
&lt;li&gt;테마가 서버사이드 모드를 지원할 경우, hugo 빌드를 수행하는 곳에는 pygments가 설치되어 있어야 한다.&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>taewan.kim을 오픈합니다.</title>
      <link>http://taewan.kim/blog/2016/01/25/first/</link>
      <pubDate>Mon, 25 Jan 2016 13:09:53 +0900</pubDate>
      
      <guid>http://taewan.kim/blog/2016/01/25/first/</guid>
      <description>&lt;p&gt;안녕하세요 김태완입니다.&lt;/p&gt;

&lt;p&gt;여러 블러그를 떠돌다 이번에 Hugo로 만든 정적 블러그에 정착하기로 했습니다.
이젠 힘들어서 이 녀석에 최대한 의지할 예정입니다.&lt;/p&gt;

&lt;p&gt;taewan.kim의 구성은 다음과 같습니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Hugo

&lt;ul&gt;
&lt;li&gt;theme: Hyde-X&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Host: github.io&lt;/li&gt;
&lt;li&gt;version control

&lt;ul&gt;
&lt;li&gt;github.com&lt;/li&gt;
&lt;li&gt;bitbucket.org&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Publishing: Jenkins at AWS&lt;/li&gt;
&lt;li&gt;Others

&lt;ul&gt;
&lt;li&gt;Google Analytics&lt;/li&gt;
&lt;li&gt;Disqus&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;taewan.kim은 기술과 소소한 일상을 주제로 운영될 블러그입니다. 많은 관심 부탁드립니다.&lt;/p&gt;

&lt;p&gt;감사합니다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>[Vagrant]Guest 인스턴스들 사이의 네트웍 설정</title>
      <link>http://taewan.kim/blog/2015/02/01/vagrant_comm_between_vms/</link>
      <pubDate>Sun, 01 Feb 2015 18:05:10 +0900</pubDate>
      
      <guid>http://taewan.kim/blog/2015/02/01/vagrant_comm_between_vms/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Vagrant를 이용한 개발 환경 구성</title>
      <link>http://taewan.kim/blog/2015/02/01/vagrant_introduction/</link>
      <pubDate>Sun, 01 Feb 2015 18:04:41 +0900</pubDate>
      
      <guid>http://taewan.kim/blog/2015/02/01/vagrant_introduction/</guid>
      <description>

&lt;p&gt;Vagrant는 가상화 인스턴스인 Virtual Machine(VM)을 관리하는 소프트웨어입니다.
Vagrant는 &amp;ldquo;부랑자&amp;rdquo;/&amp;ldquo;정처없는 사람&amp;rdquo; 이라는 사전적인 의미를 갖습니다.
Vagrant는 가상화 이미지를 효과적으로 만들고 테스트하는 유연한 환경이라는 의미로 명명된 것으로 생각됩니다.
앞에서 설명한 것 처럼 Vagrant는 VM을 관리하는 소프트웨어로 여러 가상화 기술을 지원는 고수준 래퍼라고 할 수 있습니다.&lt;br /&gt;
Vagrant가 provider로 지원하는 기술은 다음과 같습니다.
- VirtualBox
- Vmware
- KVM
- Linux Container&lt;/p&gt;

&lt;p&gt;Vagrant의 개발 언어는 루비이며 2016.01 현재 최신 버전은 1.8입니다.
Vagrant는 초기에 VirtualBox를 근간으로 만들어 졌습니다.
여기에 버전 1.1부터 VMware와 KVM이 추가되었고, 버전 1.6에서는 Docker 컨테이너가 추가되었습니다.
Vagrant가 여러 Provider를 지원하기는 하지만, 여전히 기본 Provider는 VirtualBox입니다.&lt;/p&gt;

&lt;p&gt;Vagrant가 갖는 주요 특징은 다음과 같습니다.
* VM의 라이프사이클을 지원하면 간단한 CLI(Command-line Interface) 유틸리티
* VirtualBox기반으로 가상 머신 생성 자동화
* Chef와 Puppet을 사용한 프로비저닝 지원
* SSH 완전 지원
* VM에 고정 IP 할당 가능
* 호스트 머신에 포트 포워드 지원
* box로 이미지 배포
* 단일 명령으로 가상 머신을 완전히 리빌드&lt;/p&gt;

&lt;h2 id=&#34;vagrant-설치:5df5018d6687eb59ab586ab578cca973&#34;&gt;Vagrant 설치&lt;/h2&gt;

&lt;h2 id=&#34;quick-start-in-5-minute:5df5018d6687eb59ab586ab578cca973&#34;&gt;Quick Start in 5 Minute&lt;/h2&gt;

&lt;h2 id=&#34;vagrant-명령어-요약:5df5018d6687eb59ab586ab578cca973&#34;&gt;vagrant 명령어 요약&lt;/h2&gt;

&lt;h2 id=&#34;vagrantfile성-설정하기:5df5018d6687eb59ab586ab578cca973&#34;&gt;VagrantFile성 설정하기&lt;/h2&gt;

&lt;p&gt;###
###
###
###
###
###&lt;/p&gt;

&lt;h2 id=&#34;reference:5df5018d6687eb59ab586ab578cca973&#34;&gt;Reference&lt;/h2&gt;


&lt;div style=&#34;position: relative; padding-bottom: 56.25%; padding-top: 30px; height: 0; overflow: hidden;&#34;&gt;
  &lt;iframe src=&#34;//www.youtube.com/embed/w7Ft2ymGmfc&#34; style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%;&#34; allowfullscreen frameborder=&#34;0&#34;&gt;&lt;/iframe&gt;
 &lt;/div&gt;


&lt;hr /&gt;

&lt;p&gt;설치
    - virtualbox 설치
    - vagrant 설치&lt;/p&gt;

&lt;p&gt;gem install vagrant
vagrant box add lucid32 http://&amp;hellip;&amp;hellip;.box
vagrant init
vagrant up&lt;/p&gt;

&lt;p&gt;&amp;mdash;&amp;mdash;-getting started &amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;
* Vagrant가 virtualbox를 선호하는 이유
    * Just Free
    * 주요 플랫폼
    * Vagrant에 빌트-인 되어 있음&lt;/p&gt;

&lt;p&gt;vagrant init bashincorp/predics64
vagrant up
vagrant ssh&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&amp;ldquo;Ubuntu 12.04 LTS 64-bit&amp;rdquo; 가상화 구성 완료&lt;/li&gt;
&lt;li&gt;vagrant ssh&lt;/li&gt;
&lt;li&gt;vagrant destroy&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;vagrant-설정-vagrantfile:5df5018d6687eb59ab586ab578cca973&#34;&gt;Vagrant 설정: Vagrantfile&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Vagrantfile 을 초기화하는 명령&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;vagrant init&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Boxes&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Vagrant가 빠른 가상머신 복제를 위해 사용하는 기본 이미지&lt;/li&gt;
&lt;li&gt;Vagrantfile에 사용할 box를 지정함&lt;/li&gt;
&lt;li&gt;모든 프로젝트는 Box의 초기 이미지를 클론하여 사용&lt;/li&gt;
&lt;li&gt;원본 이미지를 수정하지 않음&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Box 설치&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;vagrant box add hashicorp/precise64&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://atlas.hashicorp.com/boxes/search에서&#34;&gt;https://atlas.hashicorp.com/boxes/search에서&lt;/a&gt; 다운로드&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;설정:5df5018d6687eb59ab586ab578cca973&#34;&gt;설정&lt;/h2&gt;

&lt;p&gt;Vagrant.configure(&amp;ldquo;2&amp;rdquo;) do |config|
  config.vm.box = &amp;ldquo;hashicorp/precise64&amp;rdquo;
end&lt;/p&gt;

&lt;p&gt;HashiCorp&amp;rsquo;s Atlas box catalog: &lt;a href=&#34;https://atlas.hashicorp.com/boxes/search&#34;&gt;https://atlas.hashicorp.com/boxes/search&lt;/a&gt;
bento&lt;/p&gt;

&lt;p&gt;vagrant up
vagrant ssh
vagrant destory box 이미지를 제거하지 않음
vagrant box remove&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;동기화-폴더:5df5018d6687eb59ab586ab578cca973&#34;&gt;동기화 폴더&lt;/h2&gt;

&lt;p&gt;/vagrant&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ vagrant up
$ vagrant ssh
vagrant@precise64:~$ ls /vagrant
Vagrantfile
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;vagrant@precise64:~$ touch /vagrant/foo
vagrant@precise64:~$ exit
$ ls
foo Vagrantfile
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;VAGRANTFILE_API_VERSION = &amp;quot;2&amp;quot;
 
Vagrant.configure(VAGRANTFILE_API_VERSION) do |config|
  config.vm.box = &amp;quot;precise32&amp;quot;
  config.vm.box_url = &amp;quot;http://files.vagrantup.com/precise32.box&amp;quot;
  # config.vm.network :forwarded_port, guest: 80, host: 8080
  # config.vm.network :private_network, ip: &amp;quot;192.168.33.10&amp;quot;
  # config.vm.network :public_network
  # config.ssh.forward_agent = true
  config.vm.provider &amp;quot;virtualbox&amp;quot; do |vm|
        vm.customize [
               &amp;quot;modifyvm&amp;quot;,:id,
               &amp;quot;--memory&amp;quot;,&amp;quot;512&amp;quot;,
               &amp;quot;--name&amp;quot;,&amp;quot;Terry_vagrant0&amp;quot;,
               &amp;quot;--cpus&amp;quot;,&amp;quot;2&amp;quot;,
                       ]
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;shared-folder:5df5018d6687eb59ab586ab578cca973&#34;&gt;shared folder&lt;/h2&gt;

&lt;p&gt;vagrant@precise64:~$ touch /vagrant/foo
vagrant@precise64:~$ exit
$ ls
foo Vagrantfile&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;provisioning:5df5018d6687eb59ab586ab578cca973&#34;&gt;provisioning&lt;/h2&gt;

&lt;p&gt;#!/usr/bin/env bash&lt;/p&gt;

&lt;p&gt;apt-get update
apt-get install -y apache2
if ! [ -L /var/www ]; then
  rm -rf /var/www
  ln -fs /vagrant /var/www&lt;/p&gt;

&lt;h2 id=&#34;fi:5df5018d6687eb59ab586ab578cca973&#34;&gt;fi&lt;/h2&gt;

&lt;p&gt;Vagrant.configure(&amp;ldquo;2&amp;rdquo;) do |config|
  config.vm.box = &amp;ldquo;hashicorp/precise64&amp;rdquo;
  config.vm.provision :shell, path: &amp;ldquo;bootstrap.sh&amp;rdquo;&lt;/p&gt;

&lt;h2 id=&#34;end:5df5018d6687eb59ab586ab578cca973&#34;&gt;end&lt;/h2&gt;

&lt;p&gt;vagrant 파일 기준 상대 경로&lt;/p&gt;

&lt;p&gt;vagrant reload &amp;ndash;provision&lt;/p&gt;

&lt;p&gt;Configuration of communications between VMs&lt;/p&gt;

&lt;p&gt;Vagrant는
- VirtualBox
- VMWare
- AWS&lt;/p&gt;

&lt;p&gt;Provider를 설치한 후
$ vagrant up &amp;ndash;provider=vmware_fusion
$ vagrant up &amp;ndash;provider=aws
&amp;ldquo;vagrant up&amp;rdquo;에서만 provider를 지정하면 옵션을 사용합니다.
다른 vagrant 명령에서는 provider를 별도로 지정할 필요가 없습니다.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>