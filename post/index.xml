<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on taewan&#39;s blog</title>
    <link>http://taewan.kim/post.html</link>
    <description>Recent content in Posts on taewan&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 03 Feb 2016 14:01:55 +0900</lastBuildDate>
    <atom:link href="http://taewan.kim/post.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Webhook 연동: bitbucket &#43; jenkins</title>
      <link>http://taewan.kim/blog/2016/02/03/bitbucket_jenkins_webhook/</link>
      <pubDate>Wed, 03 Feb 2016 14:01:55 +0900</pubDate>
      
      <guid>http://taewan.kim/blog/2016/02/03/bitbucket_jenkins_webhook/</guid>
      <description>

&lt;p&gt;최근에 git 기반의 서비스들(github, bitbucket, gitlab)은 Webhooks 기능을 기본적으로 제공합니다.
Webhooks는 해당 git repository에 push, commtit, tag와 같은 이벤트가 발생하면 Jenkins와 같은 CI 서버에 이벤트를 전달하는 기능입니다.
Webhooks 이벤트를 전달받은 CI서버는 해당 프로젝트의 빌드 프로세스를 시작하는 방식으로 Git 레파지토리와 CI 서버를 연동하는 방법입니다.
Git 레파지토리가 호출하는 Webhooks는 HTTP URL(Restful 서비스)입니다.&lt;/p&gt;

&lt;h2 id=&#34;jenkins의-빌드-트리거:922394644e1f3ee8cce21149fbcc0a54&#34;&gt;Jenkins의 빌드 트리거&lt;/h2&gt;

&lt;p&gt;Webhooks 기능을 활성화 시키기 위해서 git 서비스에 Jenkins가 제공하는 URL을 등록해야 합니다.
Jenkins는 Job의 설정화면의 &amp;ldquo;빌드 트리거&amp;rdquo;에서 git서비스에 등록할 URL을 만들수 있습니다.&lt;/p&gt;

&lt;p&gt;Jenkins에 로그인하여 대상 Job을 선택한 후 아래 그림과 같이 configuration 메뉴를 클릭합니다.
&lt;img src=&#34;http://taewan.kim/images/bitbucket/jenkins_config_1.png&#34; alt=&#34;BigDataLite&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;Configuration 화면에서 아래 그림과 같이 상단 메뉴의 &amp;ldquo;Build Triggers&amp;rdquo;를 선택하여 &amp;ldquo;Build Triggers&amp;rdquo; 설정 부분으로 이동합니다.
&lt;img src=&#34;http://taewan.kim/images/bitbucket/jenkins_config_2.png&#34; alt=&#34;BigDataLite&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;&amp;ldquo;Build Triggers&amp;rdquo;영역에서는 지정한 프로젝트의 url을 확인하고 인증토큰을 설정하는 것을 제공합니다.
&lt;img src=&#34;http://taewan.kim/images/bitbucket/jenkins_config_3.png&#34; alt=&#34;BigDataLite&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;위 예제를 통해서 인증토큰 값과 그 아래의 안내 URL을 조합하면 다음과 같은 URL을 만들 수 있습니다.
- TOKEN_NAME: iloveminsu
- url: JENKINS_URL/job/build%20for%20taewan.kim%20blog/build?token=TOKEN_NAME
- JENKINS_URL: &lt;a href=&#34;http://ci.taewan.kim&#34;&gt;http://ci.taewan.kim&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;최종 URL은 다음과 같습니다.
- &lt;a href=&#34;http://ci.taewan.kim/job/build%20for%20taewan.kim%20blog/build?token=iloveminsu&#34;&gt;http://ci.taewan.kim/job/build%20for%20taewan.kim%20blog/build?token=iloveminsu&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;이 값을 git 서비스의 Webhooks에 등록해야 합니다.&lt;/p&gt;

&lt;h2 id=&#34;git-서비스에-webhook-등록:922394644e1f3ee8cce21149fbcc0a54&#34;&gt;git 서비스에 Webhook 등록&lt;/h2&gt;

&lt;p&gt;github, gitlab 그리고 Bitbucket은 유사한 형태의 Webhook 등록을 지원합니다.&lt;/p&gt;

&lt;h3 id=&#34;github의-webhooks-등록:922394644e1f3ee8cce21149fbcc0a54&#34;&gt;github의 webhooks 등록&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;http://taewan.kim/images/bitbucket/webhook-github-01.png&#34; alt=&#34;&#34; /&gt;

&lt;img src=&#34;http://taewan.kim/images/bitbucket/webhook-github-02.png&#34; alt=&#34;&#34; /&gt;

&lt;img src=&#34;http://taewan.kim/images/bitbucket/webhook-github-03.png&#34; alt=&#34;&#34; /&gt;

&lt;img src=&#34;http://taewan.kim/images/bitbucket/webhook-github-04.png&#34; alt=&#34;&#34; /&gt;
&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>VirtualBox: 호스트에서 게스트 접근 네트웍 설정</title>
      <link>http://taewan.kim/blog/2016/01/31/virtualvox_network_config/</link>
      <pubDate>Sun, 31 Jan 2016 12:42:43 +0900</pubDate>
      
      <guid>http://taewan.kim/blog/2016/01/31/virtualvox_network_config/</guid>
      <description>

&lt;h1 id=&#34;virtualbox-가상화-이미지의-접근-설정:e504ff6a47b9ec67ec6136666189d988&#34;&gt;VirtualBox 가상화 이미지의 접근 설정&lt;/h1&gt;

&lt;p&gt;최근에는 VirtualBox 이미지로 테스트 환경을 구성하거나 배포하는 경우가 많아졌습니다.
특히 오라클에서는 초기 테스트 및 교육 목적으로 다수의 VirtualBox 이미지를 배포하고 있습니다.
이렇게 만들어진 이미지를 사용할 경우 사용자는 새로운 기술을 접할 때 경험해야 하는 설치 및 구성에 대한 난제를 해결 할 수 있습니다.
즉 사용자는 새로운 기술의 기능 테스트 및 활용에 집중할 수 있게됩니다.&lt;/p&gt;

&lt;p&gt;오라클이 제공하는 VirtualBox 이미지는 Oracle Big Data Lite입니다.
Oracle Big Data Lite는 오라클의 빅데이터 소프트웨어 (CHD배포본 + Orale Software)의 최신 구성을 하나의 VirtualBox 이미지에 담아서 제공합니다.
이 이미지의 최신 버전은 4.3.X (2016.01 기준) 입니다.
Oracle Big Data Lite는 완전한 설정이 반영된 이미지이기 때문에, 사용자는 설치 및 번거로운 작업을 거치지 않고 바로 기능 테스트를 할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://taewan.kim/images/BigDataLite-Initial.png&#34; alt=&#34;BigDataLite&#34; /&gt;
&lt;/p&gt;

&lt;h2 id=&#34;호스트에서-가상화-이미지에-접근할-수-있다면:e504ff6a47b9ec67ec6136666189d988&#34;&gt;호스트에서 가상화 이미지에 접근할 수 있다면&amp;hellip;&lt;/h2&gt;

&lt;p&gt;VirtualBox를 통해서 이미지를 실행한 후에는 VirtualBox가 제공하는 윈도우를 통해서 Guest OS에 접근을 할 수 있습니다.
그러나 Guest OS를 윈도우로 접근하는 방식은 비 효율적입니다.
Guest OS가 리눅스라면 VirtualBox가 구동하는 호스트에서 터미널로 Guest OS에 접근하여 작업하는 것이 더 효율적 입니다.
VirtualBox에 &amp;ldquo;Host Only Adapter&amp;rdquo;를 설정하면, Host OS에서 Guest OS에 접근할 수 있습니다.&lt;/p&gt;

&lt;h2 id=&#34;virtualbox의-host-only-adapter-설정:e504ff6a47b9ec67ec6136666189d988&#34;&gt;VirtualBox의 Host Only Adapter 설정&lt;/h2&gt;

&lt;p&gt;Host Only Adapter 설정은 VirtualBox 레벨에서 &amp;ldquo;새 호스트 전용 네트워크&amp;rdquo; 설정 단계와 Guest OS에서 Host Only Adapter 설정 단계로 구분됩니다.&lt;/p&gt;

&lt;h3 id=&#34;새-호스트-전용-네트워크-설정:e504ff6a47b9ec67ec6136666189d988&#34;&gt;새 호스트 전용 네트워크 설정&lt;/h3&gt;

&lt;p&gt;OS X를 기준으로 메뉴:VirtualBox -&amp;gt; 환경설정 -&amp;gt; 네트워크 텝 -&amp;gt; &amp;ldquo;호스트 전용 네트워크&amp;rdquo;에서 오른쪽의 &amp;ldquo;+&amp;ldquo;아이콘을 선택합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://taewan.kim/images/hostonlynetwork.png&#34; alt=&#34;Host Only Networks&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;&amp;rdquo;+&amp;ldquo;아이콘을 선택하면 &amp;ldquo;vboxnet0&amp;rdquo;가 생성됩니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://taewan.kim/images/vboxnet0.png&#34; alt=&#34;vboxnet0&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;&amp;ldquo;vboxnet0&amp;rdquo;를 더블클릭하여 아래와 같이 DHCP 설정을 합니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;서버사용: 선택&lt;/li&gt;
&lt;li&gt;서버주소: 192.168.56.100&lt;/li&gt;
&lt;li&gt;서버마스크: 255.255.255.0&lt;/li&gt;
&lt;li&gt;최저주소한계: 192.168.56.101&lt;/li&gt;
&lt;li&gt;최고주소한계: 192.168.56.154&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;http://taewan.kim/images/dscp.png&#34; alt=&#34;vboxnet0&#34; /&gt;

위와 같이 설정을 마치고 &amp;ldquo;저장&amp;rdquo;&amp;rdquo; 및 &amp;ldquo;확인&amp;rdquo;&amp;rdquo; 버튼을 클릭하여 네트워크 등록을 완료합니다.&lt;/p&gt;

&lt;h3 id=&#34;guest-os에-adapter-추가-host-only-adapter:e504ff6a47b9ec67ec6136666189d988&#34;&gt;Guest OS에 Adapter 추가 (Host Only Adapter)&lt;/h3&gt;

&lt;p&gt;Guest OS 선택 후 설정 메뉴 오픈, 네트워크 텝-&amp;gt;어탭터2를 선택하고 다음과 같은 설정을 합니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;네트워크 어뎁터 사용하기: 선택&lt;/li&gt;
&lt;li&gt;다음에 연결: Host Only Adapter 선택&lt;/li&gt;
&lt;li&gt;이름: vboxnet0&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;http://taewan.kim/images/adapter2.png&#34; alt=&#34;adapter2&#34; /&gt;
&lt;/p&gt;

&lt;h3 id=&#34;새-호스트-전용-네트워크-설정-1:e504ff6a47b9ec67ec6136666189d988&#34;&gt;새 호스트 전용 네트워크 설정&lt;/h3&gt;

&lt;p&gt;Guest OS에 로그인하여 네트웍 정보를 확인 합니다.
terminal 상에서 ifconfig 명령으로 호스트에서 접근 할 IP를 확인할 수 있습니다.
(192.168.56.101)&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://taewan.kim/images/ipcheck.png&#34; alt=&#34;ipcheck&#34; /&gt;
&lt;/p&gt;

&lt;h3 id=&#34;host-os에서-guest-os에-접근:e504ff6a47b9ec67ec6136666189d988&#34;&gt;Host OS에서 Guest OS에 접근&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;ssh 접근 결과&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;taewanui-MacBook-Pro:demo taewan$ ssh oracle@192.168.56.101
oracle@192.168.56.101&#39;s password: 
Last login: Thu Jan 28 16:00:34 2016 from 192.168.56.1
[oracle@bigdatalite ~]$
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;hue 접근 결과

&lt;ul&gt;
&lt;li&gt;Big Data Lite는 8888포트로 Hue를 제공합니다.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;http://taewan.kim/images/hue.png&#34; alt=&#34;ipcheck&#34; /&gt;
&lt;/p&gt;

&lt;h2 id=&#34;요약:e504ff6a47b9ec67ec6136666189d988&#34;&gt;요약&lt;/h2&gt;

&lt;p&gt;VirtualBox에 Host Only Network를 추가하고 DHCP를 설정한 후 Guest OS에 Host Only Adapter를 등록하면 Host OS에서 Guest OS에 네트웍 접근이 가능합니다. 설정 절차를 요약하면 다음곽 같습니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;VirtualBox에 Host Only Network 추가

&lt;ul&gt;
&lt;li&gt;추가된 네트워크에 DHCP 설정&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;접근할 Guest OS에 네트웍 어뎁터 추가

&lt;ul&gt;
&lt;li&gt;Host Only Adapter&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Guest OS에 로그인하여 접속 IP체크

&lt;ul&gt;
&lt;li&gt;ifconfig command in terminal&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Host OS에서 Guest OS에 접근&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>ssh 사용을 단순화하기 위한 ssh config 설정</title>
      <link>http://taewan.kim/blog/2016/01/28/ssh_config/</link>
      <pubDate>Thu, 28 Jan 2016 13:12:54 +0900</pubDate>
      
      <guid>http://taewan.kim/blog/2016/01/28/ssh_config/</guid>
      <description>

&lt;p&gt;사용자 홈디렉터리의 ~/.ssh/config 파일에 host 별 설정을 추가하면 ssh 명령 사용을 단순화 할 수 있습니다.
본 문서는 ~/.ssh/config 파일의 설정만을 다룹니다. ssh와 ssh key에 대해서는 궁굼하시다면 다음 문서를 참조하시기 바랍니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ssh 원격제어: &lt;a href=&#34;https://opentutorials.org/module/432/3738&#34;&gt;https://opentutorials.org/module/432/3738&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;ssh key: &lt;a href=&#34;https://opentutorials.org/module/432/3742&#34;&gt;https://opentutorials.org/module/432/3742&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ssh의 기본 사용법은 다음과 같습니다 .
다음과 같은 명령을 내릴때 ssh 명령은 &amp;ldquo;~/.ssh/id_rsa&amp;rdquo; 인증서를 사용하여, 52.79.103.139 서버에 ubuntu로 로그인을 시도합니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;taewanui-MacBook-Pro:~ taewan$ ssh ubuntu@52.79.103.139
Welcome to Ubuntu 14.04.3 LTS (GNU/Linux 3.13.0-74-generic x86_64)

Last login: Mon Feb  1 01:44:13 2016 from 211.210.76.6
ubuntu@ip-172-31-11-175:~$ pwd
/home/ubuntu
ubuntu@ip-172-31-11-175:~$ 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;기본 인증서가 다른 인증서를 사용해야 할 경우에는 다음과 같이 -i 옵션을 사용해야 합니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;taewanui-MacBook-Pro:demo taewan$ ssh ubuntu@52.79.103.139 -i ~/.ssh/aws-seoul.pem
Welcome to Ubuntu 14.04.3 LTS (GNU/Linux 3.13.0-74-generic x86_64)

Last login: Mon Feb  1 02:10:40 2016 from 211.210.76.6
ubuntu@ip-172-31-11-175:~$ 

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;위 명령의 경우 인증서를 직접 지정해야 하기 때문에 사용하기 부담스러운 면이 있습니다. ssh을 단순하게 사용하는 방법중에 하나는 다음과 같은 alias를 사용하는 것 입니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;taewanui-MacBook-Pro:demo taewan$ alias awsssh=&amp;quot;ssh ubuntu@52.79.103.139 -i ~/.ssh/aws-seoul.pem&amp;quot;
taewanui-MacBook-Pro:demo taewan$ awsssh
Welcome to Ubuntu 14.04.3 LTS (GNU/Linux 3.13.0-74-generic x86_64)

Last login: Mon Feb  1 02:23:47 2016 from 211.210.76.6
ubuntu@ip-172-31-11-175:~$
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;alias를 사용하면 명령을 쉽게 입력할 수 는 있지만 관리 비용이 증가합니다. 또한 ssh 명령은 인증서, 서버 포트, 포트포워딩 등 다양한 설정 옵션이 있기 때문에 이러한 변경을 효과적으로 대응하기에 어렵다는 단점이 있습니다.&lt;/p&gt;

&lt;h1 id=&#34;ssh-사용-단순화-ssh-config:0984e7ebd3dce43c74ff94df48f1ae75&#34;&gt;ssh 사용 단순화:~/.ssh/config&lt;/h1&gt;

&lt;p&gt;이러한 문제를 해법은 &amp;ldquo;~/.ssh/config&amp;rdquo;을 사용하는 것 입니다. 다음은 일반적인 형태의 ~/.ssh/config 파일의 내용입니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;### for aws
Host aws-ubuntu1
    HostName 52.79.103.139
    IdentityFile ~/.ssh/aws-seoul.pem

Host aws-ubuntu2
    HostName 52.79.103.139
    User ubuntu
    IdentityFile ~/.ssh/aws-seoul.pem   

## for git
Host github.com 
    User git
    IdentityFile ~/.ssh/id_rsa_XXXXXXXXXXXX
Host bitbucket.org
    User git
    IdentityFile ~/.ssh/id_rsa_@@@@@@@@@@@@
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;위 config에서는 2개의 아마존 서버와 github 및 bitbucket 서버 4개의 서버에 대한 ssh 설정이 서버 별로 등록되어 있습니다.
위 예제에서 아마존 aws 서버는 다음의 두 가지 방법으로 로그인 할 수 있습니다.
ssh config 설정을 사용 할 경우 복수의 인증서를 사용하는 상황에서도 ssh 명령을 단순하게 유지할 수 있습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;taewanui-MacBook-Pro:demo taewan$ ssh ubuntu@aws-ubuntu1
Welcome to Ubuntu 14.04.3 LTS (GNU/Linux 3.13.0-74-generic x86_64)

Last login: Mon Feb  1 02:37:28 2016 from 211.210.76.6
ubuntu@ip-172-31-11-175:~$ 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;아래의 경우 aws-ubuntu2에 로그인 계정 명을 등록하였기 때문에 ssh 명령을 더욱 단순하게 사용 가능합니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;taewanui-MacBook-Pro:demo taewan$ ssh aws-ubuntu2
Welcome to Ubuntu 14.04.3 LTS (GNU/Linux 3.13.0-74-generic x86_64)

Last login: Mon Feb  1 02:56:27 2016 from 211.210.76.6
ubuntu@ip-172-31-11-175:~$ 
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;ssh-config-파일:0984e7ebd3dce43c74ff94df48f1ae75&#34;&gt;~/.ssh/config 파일&lt;/h2&gt;

&lt;p&gt;ssh config 설정 파일의 사용자별 위치는 &amp;ldquo;~/.ssh/config&amp;rdquo;입니다.&lt;/p&gt;

&lt;h3 id=&#34;설정-파일-권한:0984e7ebd3dce43c74ff94df48f1ae75&#34;&gt;설정 파일 권한&lt;/h3&gt;

&lt;p&gt;ssh 설정 파일은 다른 사용자가 사용할 경우 심각한 권한 문제가 발생할 수 있습니다.
따라서 다음과 같은 권한으로 설정되어야 합니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;chmod 440 ~/.ssh/config
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;설정-파일-유형:0984e7ebd3dce43c74ff94df48f1ae75&#34;&gt;설정 파일 유형&lt;/h3&gt;

&lt;p&gt;ssh 설정 파일의 기본 형태는 다음과 같습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Host firsthost
    SSH_OPTION_1 custom_value
    SSH_OPTION_2 custom_value
    SSH_OPTION_3 custom_value

Host secondhost
    ANOTHER_OPTION custom_value

Host *host
    ANOTHER_OPTION custom_value

Host *
    CHANGE_DEFAULT custom_value
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ssh 설정 파일의 옵션 값은 다음과 같이 3가지 방법으로 값을 설정 할 수 있습니다.
다음 3 가지는 모두 유효한 설정입니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Port 4567
Port=4567
Port = 4567
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;호스트-맵핑:0984e7ebd3dce43c74ff94df48f1ae75&#34;&gt;호스트 맵핑&lt;/h3&gt;

&lt;p&gt;호스트 맵핑은 Host 속성과 Hostname 속성을 이용하여 실제 호스트 URL에 맵핑을 합니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Host: ssh 명령에 사용하는 이름&lt;/li&gt;
&lt;li&gt;Hostname: Host에 지정된 이름이 매핑되는 실제 호스트 명&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;Host dev
	HostName dev.taewan.kim
	Uset admin
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;위와 같이 설정된 상태에서 &amp;ldquo;ssh dev&amp;rdquo;이 실행된다면 다음과 같은 명령으로 변환되어 실행됩니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ssh admin@dev.taewan.kim -i ~/.ssh/id_rsa&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;2차-도메인-등-와일드카드-문자-지정:0984e7ebd3dce43c74ff94df48f1ae75&#34;&gt;2차 도메인 등 와일드카드 문자 지정&lt;/h3&gt;

&lt;p&gt;다음과 같이 와일드카드 문자로 호스트 명을 지정 할 수 있습니다. 이 경우 taewan.kim의 서브 도메인에 모두 적용됩니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Host *.taewan.kim
    User taewan
    PreferredAuthentications publickey
    IdentityFile ~/.ssh/taewan.dev
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;설정-파일-주요-속성:0984e7ebd3dce43c74ff94df48f1ae75&#34;&gt;설정 파일 주요 속성&lt;/h2&gt;

&lt;h3 id=&#34;일반-설정:0984e7ebd3dce43c74ff94df48f1ae75&#34;&gt;일반 설정&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Hostname: 연결될 서버 호스트 명으로 사용됨.

&lt;ul&gt;
&lt;li&gt;선택적 속성&lt;/li&gt;
&lt;li&gt;미 설정시 Host 값이 Hostname으로 사용됨&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;User: 네트웍 커넥션에 사용되는 계정 명&lt;/li&gt;
&lt;li&gt;Port: 원격 ssh 데몬이 사용하는 포트, 기본 값=22&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;네트웍-설정:0984e7ebd3dce43c74ff94df48f1ae75&#34;&gt;네트웍 설정&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;ServerAliveInterval

&lt;ul&gt;
&lt;li&gt;서버에 테스트 패킷을 전송하는 주기 설정&lt;/li&gt;
&lt;li&gt;초단위 설정&lt;/li&gt;
&lt;li&gt;기본 값: 0&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;ServerAliveCountMax

&lt;ul&gt;
&lt;li&gt;서버에 테스트용 패킷을 전송하는 횟수를 설정&lt;/li&gt;
&lt;li&gt;서버에 추가적인 데이터 전송 없이 ServerAliveInterval의 최대 임계 값을 초과할 경우 커넥션 종료&lt;/li&gt;
&lt;li&gt;기본값: 3&lt;/li&gt;
&lt;li&gt;예: ServerAliveInterval 15, ServerAliveCountMax 3

&lt;ul&gt;
&lt;li&gt;통신없이 45초 결과후 커넥션 종료&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;LogLevel

&lt;ul&gt;
&lt;li&gt;클라이언트 측의 로그 레벨&lt;/li&gt;
&lt;li&gt;최소 로그: QUIET&lt;/li&gt;
&lt;li&gt;최대 로그: DEBUG3&lt;/li&gt;
&lt;li&gt;설정 가능 값

&lt;ul&gt;
&lt;li&gt;QUIET&lt;/li&gt;
&lt;li&gt;FATAL&lt;/li&gt;
&lt;li&gt;ERROR&lt;/li&gt;
&lt;li&gt;INFO&lt;/li&gt;
&lt;li&gt;VERBOSE&lt;/li&gt;
&lt;li&gt;DEBUG1&lt;/li&gt;
&lt;li&gt;DEBUG2&lt;/li&gt;
&lt;li&gt;DEBUG3&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;StrictHostKeyChecking

&lt;ul&gt;
&lt;li&gt;~/.ssh/known_hosts에 자동으로 호스트를 추가하는 설정&lt;/li&gt;
&lt;li&gt;기본 설정은 저장을 질문 함&lt;/li&gt;
&lt;li&gt;비활성 설정: &amp;ldquo;no&amp;rdquo;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;UserKnownHostsFile

&lt;ul&gt;
&lt;li&gt;연결된 호스트에 대한 정보를 남기는 파일을 지정하는 설정&lt;/li&gt;
&lt;li&gt;기본 값: ~/.ssh/known_hosts&lt;/li&gt;
&lt;li&gt;일반적으로 이 설정을 변경하지 않음&lt;/li&gt;
&lt;li&gt;StrictHostKeyChecking을 &amp;ldquo;no&amp;rdquo;로 설정할 경우에 이 설정을 &amp;ldquo;/dev/null&amp;rdquo;로 설정ㄱㄷ유&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;VisualHostKey

&lt;ul&gt;
&lt;li&gt;원격지의 호스트 키를 클라이언트 접속시 출력&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Compression

&lt;ul&gt;
&lt;li&gt;느린 네트웍 상에서 네트웍 패킷을 압축하는 옵션&lt;/li&gt;
&lt;li&gt;일반적인 상황에서 사용하지 않음&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;키-지정:0984e7ebd3dce43c74ff94df48f1ae75&#34;&gt;키 지정&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;IdentityFile

&lt;ul&gt;
&lt;li&gt;Host 별로 사용할 키의 위치를 지정&lt;/li&gt;
&lt;li&gt;기본값: 프로토콜에 따라 결정 됨

&lt;ul&gt;
&lt;li&gt;~/.ssh/id_rsa&lt;/li&gt;
&lt;li&gt;~/.ssh/id_dsa&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;multiplexing:0984e7ebd3dce43c74ff94df48f1ae75&#34;&gt;Multiplexing&lt;/h3&gt;

&lt;p&gt;ssh는 하나의 서버에 접속하는 여러 ssh 커넥션을 하나의 TCP 커넥션을 사용하여 연결하는 기능을 제공합니다.
복수의 SSH 커넥션으로 발생하는 부하를 제거하는 용도로 적합&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ControlMaster

&lt;ul&gt;
&lt;li&gt;Multiplexing을 허용하는 옵션&lt;/li&gt;
&lt;li&gt;허용 설정 값: auto&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;ControlPath

&lt;ul&gt;
&lt;li&gt;커넥션을 제어하는 용도로 사용하는 socket 파일 지정&lt;/li&gt;
&lt;li&gt;/path/to/socket/%r@%h:%p

&lt;ul&gt;
&lt;li&gt;r: username&lt;/li&gt;
&lt;li&gt;h: remote host&lt;/li&gt;
&lt;li&gt;p: port&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;ControlPersist

&lt;ul&gt;
&lt;li&gt;커넥션이 유지해야 할 시간을 초단위로 지정&lt;/li&gt;
&lt;li&gt;초단위 설정&lt;/li&gt;
&lt;li&gt;낮은 값을 설정할 경우 불필요한 커넥션 연결 오픈을 방지할 수 있음&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>JBoss Seam 로고의 의미</title>
      <link>http://taewan.kim/blog/2016/01/27/seam_log/</link>
      <pubDate>Wed, 27 Jan 2016 10:50:36 +0900</pubDate>
      
      <guid>http://taewan.kim/blog/2016/01/27/seam_log/</guid>
      <description>

&lt;p&gt;2008~2009년도에는 JBoss Seam에 몰입했던 기시였습니다. 그 당시에 작성했던 글입니다. 오픈소스를 이해할 때 오픈소스의 이름과 로고가 담고 있는 의미를 이해하는 성움이 됩니다. 오픈소스 이름과 로고를 이렇게 해석했구나 라는 사례로 봐 주시면 좋을 것 같습니다. 그럼 2009년으로 들어가 보겠습니다.&lt;/p&gt;

&lt;h1 id=&#34;seam-framework-로고는-어떤-의미일까요:f19f716c8aeb01c785b0b485dd6debca&#34;&gt;Seam Framework 로고는 어떤 의미일까요?&lt;/h1&gt;

&lt;p&gt;Seam Framework은 기존과 차별되는 독특한 컴포넌트 관리 모델을 제안하고 있습니다. 기존에 Java EE 애플리케이션은 Web 티어와 EJB 티어로 구분되어 있기 때문어 상호간에 참조하기가 어려웠습니다. 웹 에서 EJB 컴포넌트를 참조하기 위해서는 JNDI Lookup과 Casting 작업이 선행되어야 했습니다.&lt;/p&gt;

&lt;p&gt;이렇다 보니 Java EE의 핵심 컴포넌트인 JSF 컴포넌트와 EJB 컴포넌트는 Java EE의 핵심 컴포넌트이기는 하지만 상호간을 참조하는 것은 여간 번거로운 작업이 아닐수 없었습니다.&lt;/p&gt;

&lt;p&gt;왜 이런일이 발생할까? 라는 고민에서 Seam Framework이 시작되었다고 보셔도 좋을것 같습니다.&lt;/p&gt;

&lt;p&gt;처음 Seam을 접할때 Seam이란 의미는 Seamless의 약자가 아닐까? 라는 생각을 했습니다. Seam의 컴포넌트 모델을 보다 보면 다음과 같은 이미지를 연상하게 됩니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://taewan.kim/images/seamlogo.png&#34; alt=&#34;Seam Logo&#34; /&gt;
&lt;/p&gt;

&lt;h2 id=&#34;seam-framework-logo는-이런-의미를-담고-있지-않을까요:f19f716c8aeb01c785b0b485dd6debca&#34;&gt;Seam Framework Logo는 이런 의미를 담고 있지 않을까요?&lt;/h2&gt;

&lt;p&gt;개인적인 추측에 불과하지만 Seam Framework의 빗살 무늬 로고는 이런 의미를 담고 있는 것이 아닌가라는 생각을 해 보았습니다.&lt;/p&gt;

&lt;p&gt;동일한 JVM에서 구동하는 WAS의 컴포넌트를 통합하여 사용할 수 있도록 지원하는 것이 Seam 프레임웍의 시작점 입니다. 이렇게 Java EE 컴포넌트를 통합하는 모델위에 컴포넌트가 서로를 상호 참조하는 의존성 주입 모델이 결합되면 이것이 최종 Seam 컴포넌트 관리 모델이 됩니다.&lt;/p&gt;

&lt;p&gt;Seam 컴포넌트 모델은 지난 번에 말씀 드렸던 것 처럼 JSR - 299 스펙 CDI (Context and Dependency Injection)의 토대가 되고 있고, 현재 Seam의 모습으로 JSR - 299가 정의 되고 있습니다.&lt;/p&gt;

&lt;p&gt;웹컴포넌트와 EJB 컴포넌트가 통합되어 관리 된다는 것은 어떤 의미일까요?&lt;/p&gt;

&lt;p&gt;이것은 다음과 같은 코드를 보시면 좋을 것 같습니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;JSP 코드 예제&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-jsp&#34;&gt; &amp;lt;h:form&amp;gt;
    &amp;lt;h:inputText value=&amp;quot;#{person.name}&amp;quot; /&amp;gt;&amp;lt;br/&amp;gt;
    &amp;lt;h:commandButton type=&amp;quot;submit&amp;quot;  value=&amp;quot;submit&amp;quot; 
        action=&amp;quot;#{manager.sayHello}&amp;quot; /&amp;gt;
&amp;lt;/h:form&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;위와 같은 JSP 코드가 존재한다고 생각해 보시기바랍니다.
이코드를 보면 다음과 같은 것을 추측할 수 있습니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;폼에 하나의 입력 텍스트와 하나의 버튼으로 구성&lt;/li&gt;
&lt;li&gt;입력 텍스트에 입력된 값은 person 객체의 name 필드에 저장됨&lt;/li&gt;
&lt;li&gt;버튼을 클릭하면 manager 객체의 sayHello 메서드가 실행됨&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;person과 manager 객체의 실체는 무엇일까요? person 객체는 다음과 같을 수 있습니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Person 객체&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Entity
@Name(&amp;quot;person&amp;quot;)
public class Person implements Serializable{
  private long id;
  private String name;
  //이하 코드 생략
  //getter-setter
  //Annotation
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;person 객체의 실체는 위와 같을 수 있습니다. 실제 Person 객체는 Seam Person 컴포넌트라고 하는 것이 정확한 표현입니다. Person 객체를 person 이라는 이름으로 참조 할 수 있는 것은  바로 Seam이 제공하는 컴포넌트 관리 모델때문입니다.&lt;/p&gt;

&lt;p&gt;그런데 Person 객체는 실제로 Entity Bean입니다. JPA에서 ORM으로 사용하는 POJO 객체입니다. JPA는 Java SE에서도 구동되는 기술임을 감안하면 아직까지는 크게 이상할 것은 없는 코드 입니다.&lt;/p&gt;

&lt;p&gt;그렇다면 manager 객체, 더 정확히 말해서 manager 컴포넌트의 실체는 무엇일까요?&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;manager 컴포넌트&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Stateless
@Name(&amp;quot;manager&amp;quot;)
public class ManagerAction implements Manager{
    @In @Out Person person;
    @Out List&amp;lt;Person&amp;gt; personList;
    @PersistenceContext EntityManager em;

    public String sayHello(){
      em.persist(person);
      person = null;
      return null;
    }
   //이하 코드 생략
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;여러가지 manager 컴포넌트 스타일을 생각해 볼 수 있지만 위와 같은 코드가 일반적입니다. 놀라운 것은 manager 컴포넌트는 실제 무상태 세션 빈이라는 것입니다. JSP 페이지의 테그라이브러리의 Expression Language 형태로 설정한 형태는 실제 세션빈의 메서드를 호출하는 것이었습니다.&lt;/p&gt;

&lt;p&gt;JSP를 통하여 별다른 작업 없이 ejb를 직접 호출하는 형태 입니다. JSF에 익숙하신 분들에게는 이렇게 표현하실 수 있습니다. (위 JSP는 실제 JSF 페이지 코드의 일부 입니다. )&lt;/p&gt;

&lt;h2 id=&#34;seam은-세션빈을-액션-리스너로-직접-사용할-수-있다:f19f716c8aeb01c785b0b485dd6debca&#34;&gt;Seam은 세션빈을 액션 리스너로 직접 사용할 수 있다.&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;JSF로 이런한 기능을 구현하기 위해서는 다음과 같은 작업을 거치게 됩니다&lt;/li&gt;
&lt;li&gt;JSF페이지에서 managed bean으로 등록된 컴포넌트의 메소드를 호출 그 메서드가 JDNI 룩업을 하고 전처리를 수행&lt;/li&gt;
&lt;li&gt;ejb를 호출&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Seam은 이런 절차를 모두 생략하고 직접 세션빈을 액션 리스너로 사용할 수 있는 방법을 제공합니다.&lt;/p&gt;

&lt;p&gt;이것이 Seam에서 이야기하는 컴포넌트 통합 모델의 근간 입니다.&lt;/p&gt;

&lt;p&gt;Seam은 기존에 경험하지 못했던 새로운 개념의 통합 컴포넌트 모델 관리 개념을 제공합니다. 컴포넌트를 직접 참조하는 것이 아니라 컴포넌트 이름으로 참조하고 이것을 관리하는 것은 Seam 프레임웍이 전담하는 형태입니다.&lt;/p&gt;

&lt;p&gt;사실 EJB 컴포넌트와 Web 컴포넌트를 통합하는 것은 Seam의 핵심 기능이기는 하지만 가장 밑바탕이 되는 기능중의 일부 입니다. Seam은 기존의 Dependency Injection을 확장하여 Bijection이라는 개념과 Context 개념을 강화하여 진보된 컴포넌트 관리 모델을 제공합니다.&lt;/p&gt;

&lt;p&gt;이런 의미에서 앞에서 살펴 보았던 Seam Logo 이미지를 다시 한번 살펴 보도록 하겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://taewan.kim/images/seamlogo.png&#34; alt=&#34;Seam Logo&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;Seam 프레임웍 로고로 사용하는 빗살 무늬 로고는 아마도 두 개의 Tier로 나누어져 있는 컴포넌트를 서로 연결하는 상호작용 할 수 있도록 지원한다는 의미라고 저는 생각하고 있습니다.&lt;/p&gt;

&lt;p&gt;여러분들은 어떻게 보이시나요?&lt;/p&gt;

&lt;p&gt;간혹 이런 의미를 생각해 보는 것도 재미있는 것 같습니다.^^&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Hugo의 Syntax Highlight기능 구성</title>
      <link>http://taewan.kim/blog/2016/01/25/codehighlight/</link>
      <pubDate>Mon, 25 Jan 2016 17:19:38 +0900</pubDate>
      
      <guid>http://taewan.kim/blog/2016/01/25/codehighlight/</guid>
      <description>

&lt;p&gt;현재 taewan.kim은 블러그 생성 엔진으로 Hugo를 테마로는 Hyde-x를 사용하고 있습니다.
제가 Hugo를 처음 사용하면서 가장 혼동된 부분은 Syntax Hightlight를 구성하는 과정이었습니다.
Hugo에 대한 배경 지식이 부족하다 보니 Hugo의 Syntax Hightlight 기능에 대한 혼돈이 있었습니다.
이 부분에 대하여 간략히 정리해 보겠습니다.&lt;/p&gt;

&lt;h1 id=&#34;hugo의-syntax-highlight기능-지원-타입:8249a9659163c14ad6dd21231787110e&#34;&gt;Hugo의 Syntax Highlight기능 지원 타입&lt;/h1&gt;

&lt;p&gt;Hugo는 서버사이드 모드와 클라이언트 모드로 Syntax Highlight기능을 제공합니다.
서버사이드/클라이언트 모드는 Hugo의 config 파일에서 설정 됩니다.&lt;/p&gt;

&lt;h2 id=&#34;서버사이드-모드의-syntax-highlight:8249a9659163c14ad6dd21231787110e&#34;&gt;서버사이드 모드의 Syntax Highlight&lt;/h2&gt;

&lt;p&gt;서버사이드 모드는 빌드 시점에 Syntax Hightlight가 적용된 HTML을 생성하는 방식으로 pygments를 사용합니다.
pygments는 파이썬으로 만들어진 툴로 일반 코드에 syntax highlight를 적용하는 툴입니다.
서버사이드 모드를 사용하기 위해서는 hugo 빌드에 앞서 pygments가 사전에 설치되어 있어야 합니다.(pip install pygments)&lt;/p&gt;

&lt;h2 id=&#34;클라이언트-모드의-syntax-highlight:8249a9659163c14ad6dd21231787110e&#34;&gt;클라이언트 모드의 Syntax Highlight&lt;/h2&gt;

&lt;p&gt;클라이언트 모드는 브라우저에서 페이지를 로딩할 때 Syntax Highlight가 적용되는 방식으로,
다음과 같은 라이브러리를 사용합니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Highlight.js&lt;/li&gt;
&lt;li&gt;Prism&lt;/li&gt;
&lt;li&gt;Rainbow&lt;/li&gt;
&lt;li&gt;Syntax Highlighter&lt;/li&gt;
&lt;li&gt;Google Prettify&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;클라이언트-모드와-서버-모드의-syntax-highlight-기능-지원:8249a9659163c14ad6dd21231787110e&#34;&gt;클라이언트 모드와 서버 모드의 Syntax Highlight 기능 지원&lt;/h2&gt;

&lt;p&gt;Hugo는 두가지 모드에 대하여 적합한 변환을 Hugo 빌드 시 적용합니다.
그러나 두 변환 방식 중 어떤 것을 사용할 것인가는 일반적으로 테마가 결정합니다.
일반적으로 Theme의 README.md파일에 보면 어떤 방식을 지원하는지에 대한 설명이 기술되어 있습니다.&lt;/p&gt;

&lt;p&gt;현재 사용하고 있는 Hyde-X는 클라이언트 모드 만을 지원합니다.
Hyde-X는 Hightlight.js를 이용하여 Highlight기능을 구현합니다.
사실 Hyde-X가 서버사이드 모드도 지원하지만, 최종 빌드된 결과가 투박하고 가독성이 떨어집니다.
따라서 Hyde-x를 사용할 경우에는 클라이언트 모드를 사용하는 것이 효과적입니다.&lt;/p&gt;

&lt;h2 id=&#34;각-모드-별-설정-옵션-및-표기법:8249a9659163c14ad6dd21231787110e&#34;&gt;각 모드 별 설정 옵션 및 표기법&lt;/h2&gt;

&lt;h3 id=&#34;클라이언트-모드:8249a9659163c14ad6dd21231787110e&#34;&gt;클라이언트 모드&lt;/h3&gt;

&lt;p&gt;클라이언트 모드 설정은 config 파일에 highlight 속성으로 표시합니다.
highlight에 설정 가능한 값은 &lt;hugo_site&gt;/themes/static/css/highlight에서 확인 할 수 있습니다.
다음은 설정 예입니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; # Check the static/css/highlight directory for options.
 highlight = &amp;quot;github&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;~~~java
public static void main(String args[]){

}
~~~
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;위 설정에 대한 결과는 다음과 같습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static void main(String args[]){

}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;서버사이드-모드:8249a9659163c14ad6dd21231787110e&#34;&gt;서버사이드 모드&lt;/h3&gt;

&lt;p&gt;설정 옵션은 다음과 같습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pygmentsstyle = &amp;quot;monokai&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;유효한 설정 값은 &lt;a href=&#34;http://pygments.org/&#34;&gt;http://pygments.org/&lt;/a&gt; 에서 확인 할 수 있습니다.&lt;/p&gt;

&lt;h2 id=&#34;삽질-요약:8249a9659163c14ad6dd21231787110e&#34;&gt;삽질 요약&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Hugo는 클라이언트 모드와 서버사이드 모드의 Highlight를 지원한다.&lt;/li&gt;
&lt;li&gt;두 모드 중에서 사용 가능한 방식은 현재 사이트의 적용 테마가 결정한다.&lt;/li&gt;
&lt;li&gt;테마가 클라이언트 모드를 지원할 경우, highlisht 스타일은 static/css/highlight에서 확인 가능하다.&lt;/li&gt;
&lt;li&gt;테마가 서버사이드 모드를 지원할 경우, hugo 빌드를 수행하는 곳에는 pygments가 설치되어 있어야 한다.&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>taewan.kim을 오픈합니다.</title>
      <link>http://taewan.kim/blog/2016/01/25/first/</link>
      <pubDate>Mon, 25 Jan 2016 13:09:53 +0900</pubDate>
      
      <guid>http://taewan.kim/blog/2016/01/25/first/</guid>
      <description>&lt;p&gt;안녕하세요 김태완입니다.&lt;/p&gt;

&lt;p&gt;여러 블러그를 떠돌다 이번에 Hugo로 만든 정적 블러그에 정착하기로 했습니다.
이젠 힘들어서 이 녀석에 최대한 의지할 예정입니다.&lt;/p&gt;

&lt;p&gt;taewan.kim의 구성은 다음과 같습니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Hugo

&lt;ul&gt;
&lt;li&gt;theme: Hyde-X&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Host: github.io&lt;/li&gt;
&lt;li&gt;version control

&lt;ul&gt;
&lt;li&gt;github.com&lt;/li&gt;
&lt;li&gt;bitbucket.org&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Publishing: Jenkins at AWS&lt;/li&gt;
&lt;li&gt;Others

&lt;ul&gt;
&lt;li&gt;Google Analytics&lt;/li&gt;
&lt;li&gt;Disqus&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;taewan.kim은 기술과 소소한 일상을 주제로 운영될 블러그입니다. 많은 관심 부탁드립니다.&lt;/p&gt;

&lt;p&gt;감사합니다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>[Vagrant]Guest 인스턴스들 사이의 네트웍 설정</title>
      <link>http://taewan.kim/blog/2015/02/01/vagrant_comm_between_vms/</link>
      <pubDate>Sun, 01 Feb 2015 18:05:10 +0900</pubDate>
      
      <guid>http://taewan.kim/blog/2015/02/01/vagrant_comm_between_vms/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Vagrant를 이용한 개발 환경 구성</title>
      <link>http://taewan.kim/blog/2015/02/01/vagrant_introduction/</link>
      <pubDate>Sun, 01 Feb 2015 18:04:41 +0900</pubDate>
      
      <guid>http://taewan.kim/blog/2015/02/01/vagrant_introduction/</guid>
      <description>

&lt;p&gt;Vagrant는 가상화 인스턴스인 Virtual Machine(VM)을 관리하는 소프트웨어입니다.
Vagrant는 &amp;ldquo;부랑자&amp;rdquo;/&amp;ldquo;정처없는 사람&amp;rdquo; 이라는 사전적인 의미를 갖습니다.
Vagrant는 가상화 이미지를 효과적으로 만들고 테스트하는 유연한 환경이라는 의미로 명명된 것으로 생각됩니다.
앞에서 설명한 것 처럼 Vagrant는 VM을 관리하는 소프트웨어로 여러 가상화 기술을 지원는 고수준 래퍼라고 할 수 있습니다.&lt;br /&gt;
Vagrant가 provider로 지원하는 기술은 다음과 같습니다.
- VirtualBox
- Vmware
- KVM
- Linux Container&lt;/p&gt;

&lt;p&gt;Vagrant의 개발 언어는 루비이며 2016.01 현재 최신 버전은 1.8입니다.
Vagrant는 초기에 VirtualBox를 근간으로 만들어 졌습니다.
여기에 버전 1.1부터 VMware와 KVM이 추가되었고, 버전 1.6에서는 Docker 컨테이너가 추가되었습니다.
Vagrant가 여러 Provider를 지원하기는 하지만, 여전히 기본 Provider는 VirtualBox입니다.&lt;/p&gt;

&lt;p&gt;Vagrant가 갖는 주요 특징은 다음과 같습니다.
* VM의 라이프사이클을 지원하면 간단한 CLI(Command-line Interface) 유틸리티
* VirtualBox기반으로 가상 머신 생성 자동화
* Chef와 Puppet을 사용한 프로비저닝 지원
* SSH 완전 지원
* VM에 고정 IP 할당 가능
* 호스트 머신에 포트 포워드 지원
* box로 이미지 배포
* 단일 명령으로 가상 머신을 완전히 리빌드&lt;/p&gt;

&lt;h2 id=&#34;vagrant-설치:5df5018d6687eb59ab586ab578cca973&#34;&gt;Vagrant 설치&lt;/h2&gt;

&lt;h2 id=&#34;quick-start-in-5-minute:5df5018d6687eb59ab586ab578cca973&#34;&gt;Quick Start in 5 Minute&lt;/h2&gt;

&lt;h2 id=&#34;vagrant-명령어-요약:5df5018d6687eb59ab586ab578cca973&#34;&gt;vagrant 명령어 요약&lt;/h2&gt;

&lt;h2 id=&#34;vagrantfile성-설정하기:5df5018d6687eb59ab586ab578cca973&#34;&gt;VagrantFile성 설정하기&lt;/h2&gt;

&lt;p&gt;###
###
###
###
###
###&lt;/p&gt;

&lt;h2 id=&#34;reference:5df5018d6687eb59ab586ab578cca973&#34;&gt;Reference&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;설치
    - virtualbox 설치
    - vagrant 설치&lt;/p&gt;

&lt;p&gt;gem install vagrant
vagrant box add lucid32 http://&amp;hellip;&amp;hellip;.box
vagrant init
vagrant up&lt;/p&gt;

&lt;p&gt;&amp;mdash;&amp;mdash;-getting started &amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;
* Vagrant가 virtualbox를 선호하는 이유
    * Just Free
    * 주요 플랫폼
    * Vagrant에 빌트-인 되어 있음&lt;/p&gt;

&lt;p&gt;vagrant init bashincorp/predics64
vagrant up
vagrant ssh&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&amp;ldquo;Ubuntu 12.04 LTS 64-bit&amp;rdquo; 가상화 구성 완료&lt;/li&gt;
&lt;li&gt;vagrant ssh&lt;/li&gt;
&lt;li&gt;vagrant destroy&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;vagrant-설정-vagrantfile:5df5018d6687eb59ab586ab578cca973&#34;&gt;Vagrant 설정: Vagrantfile&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Vagrantfile 을 초기화하는 명령&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;vagrant init&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Boxes&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Vagrant가 빠른 가상머신 복제를 위해 사용하는 기본 이미지&lt;/li&gt;
&lt;li&gt;Vagrantfile에 사용할 box를 지정함&lt;/li&gt;
&lt;li&gt;모든 프로젝트는 Box의 초기 이미지를 클론하여 사용&lt;/li&gt;
&lt;li&gt;원본 이미지를 수정하지 않음&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Box 설치&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;vagrant box add hashicorp/precise64&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://atlas.hashicorp.com/boxes/search에서&#34;&gt;https://atlas.hashicorp.com/boxes/search에서&lt;/a&gt; 다운로드&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;설정:5df5018d6687eb59ab586ab578cca973&#34;&gt;설정&lt;/h2&gt;

&lt;p&gt;Vagrant.configure(&amp;ldquo;2&amp;rdquo;) do |config|
  config.vm.box = &amp;ldquo;hashicorp/precise64&amp;rdquo;
end&lt;/p&gt;

&lt;p&gt;HashiCorp&amp;rsquo;s Atlas box catalog: &lt;a href=&#34;https://atlas.hashicorp.com/boxes/search&#34;&gt;https://atlas.hashicorp.com/boxes/search&lt;/a&gt;
bento&lt;/p&gt;

&lt;p&gt;vagrant up
vagrant ssh
vagrant destory box 이미지를 제거하지 않음
vagrant box remove&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;동기화-폴더:5df5018d6687eb59ab586ab578cca973&#34;&gt;동기화 폴더&lt;/h2&gt;

&lt;p&gt;/vagrant&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ vagrant up
$ vagrant ssh
vagrant@precise64:~$ ls /vagrant
Vagrantfile
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;vagrant@precise64:~$ touch /vagrant/foo
vagrant@precise64:~$ exit
$ ls
foo Vagrantfile
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;VAGRANTFILE_API_VERSION = &amp;quot;2&amp;quot;
 
Vagrant.configure(VAGRANTFILE_API_VERSION) do |config|
  config.vm.box = &amp;quot;precise32&amp;quot;
  config.vm.box_url = &amp;quot;http://files.vagrantup.com/precise32.box&amp;quot;
  # config.vm.network :forwarded_port, guest: 80, host: 8080
  # config.vm.network :private_network, ip: &amp;quot;192.168.33.10&amp;quot;
  # config.vm.network :public_network
  # config.ssh.forward_agent = true
  config.vm.provider &amp;quot;virtualbox&amp;quot; do |vm|
        vm.customize [
               &amp;quot;modifyvm&amp;quot;,:id,
               &amp;quot;--memory&amp;quot;,&amp;quot;512&amp;quot;,
               &amp;quot;--name&amp;quot;,&amp;quot;Terry_vagrant0&amp;quot;,
               &amp;quot;--cpus&amp;quot;,&amp;quot;2&amp;quot;,
                       ]
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;shared-folder:5df5018d6687eb59ab586ab578cca973&#34;&gt;shared folder&lt;/h2&gt;

&lt;p&gt;vagrant@precise64:~$ touch /vagrant/foo
vagrant@precise64:~$ exit
$ ls
foo Vagrantfile&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;provisioning:5df5018d6687eb59ab586ab578cca973&#34;&gt;provisioning&lt;/h2&gt;

&lt;p&gt;#!/usr/bin/env bash&lt;/p&gt;

&lt;p&gt;apt-get update
apt-get install -y apache2
if ! [ -L /var/www ]; then
  rm -rf /var/www
  ln -fs /vagrant /var/www&lt;/p&gt;

&lt;h2 id=&#34;fi:5df5018d6687eb59ab586ab578cca973&#34;&gt;fi&lt;/h2&gt;

&lt;p&gt;Vagrant.configure(&amp;ldquo;2&amp;rdquo;) do |config|
  config.vm.box = &amp;ldquo;hashicorp/precise64&amp;rdquo;
  config.vm.provision :shell, path: &amp;ldquo;bootstrap.sh&amp;rdquo;&lt;/p&gt;

&lt;h2 id=&#34;end:5df5018d6687eb59ab586ab578cca973&#34;&gt;end&lt;/h2&gt;

&lt;p&gt;vagrant 파일 기준 상대 경로&lt;/p&gt;

&lt;p&gt;vagrant reload &amp;ndash;provision&lt;/p&gt;

&lt;p&gt;Configuration of communications between VMs&lt;/p&gt;

&lt;p&gt;Vagrant는
- VirtualBox
- VMWare
- AWS&lt;/p&gt;

&lt;p&gt;Provider를 설치한 후
$ vagrant up &amp;ndash;provider=vmware_fusion
$ vagrant up &amp;ndash;provider=aws
&amp;ldquo;vagrant up&amp;rdquo;에서만 provider를 지정하면 옵션을 사용합니다.
다른 vagrant 명령에서는 provider를 별도로 지정할 필요가 없습니다.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>