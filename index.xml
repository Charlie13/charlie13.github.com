<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>taewan&#39;s blog</title>
    <link>http://taewan.kim/</link>
    <description>Recent content on taewan&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 27 Jan 2016 10:50:36 +0900</lastBuildDate>
    <atom:link href="http://taewan.kim/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>JBoss Seam 로고의 의미</title>
      <link>http://taewan.kim/blog/2016/01/27/seam_log/</link>
      <pubDate>Wed, 27 Jan 2016 10:50:36 +0900</pubDate>
      
      <guid>http://taewan.kim/blog/2016/01/27/seam_log/</guid>
      <description>

&lt;p&gt;2008~2009년도에는 JBoss Seam에 몰입했던 기시였습니다. 그 당시에 작성했던 글입니다. 오픈소스를 이해할 때 오픈소스의 이름과 로고가 담고 있는 의미를 이해하는 도움이 됩니다. 오픈소스 이름과 로고를 이렇게 해석했구나 라는 사례로 봐 주시면 좋을 것 같습니다. 그럼 2009년으로 들어가 보겠습니다.&lt;/p&gt;

&lt;h1 id=&#34;seam-framework-로고는-어떤-의미일까요:f19f716c8aeb01c785b0b485dd6debca&#34;&gt;Seam Framework 로고는 어떤 의미일까요?&lt;/h1&gt;

&lt;p&gt;Seam Framework은 기존과 차별되는 독특한 컴포넌트 관리 모델을 제안하고 있습니다. 기존에 Java EE 애플리케이션은 Web 티어와 EJB 티어로 구분되어 있기 때문어 상호간에 참조하기가 어려웠습니다. 웹 에서 EJB 컴포넌트를 참조하기 위해서는 JNDI Lookup과 Casting 작업이 선행되어야 했습니다.&lt;/p&gt;

&lt;p&gt;이렇다 보니 Java EE의 핵심 컴포넌트인 JSF 컴포넌트와 EJB 컴포넌트는 Java EE의 핵심 컴포넌트이기는 하지만 상호간을 참조하는 것은 여간 번거로운 작업이 아닐수 없었습니다.&lt;/p&gt;

&lt;p&gt;왜 이런일이 발생할까? 라는 고민에서 Seam Framework이 시작되었다고 보셔도 좋을것 같습니다.&lt;/p&gt;

&lt;p&gt;처음 Seam을 접할때 Seam이란 의미는 Seamless의 약자가 아닐까? 라는 생각을 했습니다. Seam의 컴포넌트 모델을 보다 보면 다음과 같은 이미지를 연상하게 됩니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://taewan.kim/images/seamlogo.png&#34; alt=&#34;Seam Logo&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;seam-framework-logo는-이런-의미를-담고-있지-않을까요:f19f716c8aeb01c785b0b485dd6debca&#34;&gt;Seam Framework Logo는 이런 의미를 담고 있지 않을까요?&lt;/h2&gt;

&lt;p&gt;개인적인 추측에 불과하지만 Seam Framework의 빗살 무늬 로고는 이런 의미를 담고 있는 것이 아닌가라는 생각을 해 보았습니다.&lt;/p&gt;

&lt;p&gt;동일한 JVM에서 구동하는 WAS의 컴포넌트를 통합하여 사용할 수 있도록 지원하는 것이 Seam 프레임웍의 시작점 입니다. 이렇게 Java EE 컴포넌트를 통합하는 모델위에 컴포넌트가 서로를 상호 참조하는 의존성 주입 모델이 결합되면 이것이 최종 Seam 컴포넌트 관리 모델이 됩니다.&lt;/p&gt;

&lt;p&gt;Seam 컴포넌트 모델은 지난 번에 말씀 드렸던 것 처럼 JSR - 299 스펙 CDI (Context and Dependency Injection)의 토대가 되고 있고, 현재 Seam의 모습으로 JSR - 299가 정의 되고 있습니다.&lt;/p&gt;

&lt;p&gt;웹컴포넌트와 EJB 컴포넌트가 통합되어 관리 된다는 것은 어떤 의미일까요?&lt;/p&gt;

&lt;p&gt;이것은 다음과 같은 코드를 보시면 좋을 것 같습니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;JSP 코드 예제&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-jsp&#34;&gt; &amp;lt;h:form&amp;gt;
    &amp;lt;h:inputText value=&amp;quot;#{person.name}&amp;quot; /&amp;gt;&amp;lt;br/&amp;gt;
    &amp;lt;h:commandButton type=&amp;quot;submit&amp;quot;  value=&amp;quot;submit&amp;quot; 
        action=&amp;quot;#{manager.sayHello}&amp;quot; /&amp;gt;
&amp;lt;/h:form&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;위와 같은 JSP 코드가 존재한다고 생각해 보시기바랍니다.
이코드를 보면 다음과 같은 것을 추측할 수 있습니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;폼에 하나의 입력 텍스트와 하나의 버튼으로 구성&lt;/li&gt;
&lt;li&gt;입력 텍스트에 입력된 값은 person 객체의 name 필드에 저장됨&lt;/li&gt;
&lt;li&gt;버튼을 클릭하면 manager 객체의 sayHello 메서드가 실행됨&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;person과 manager 객체의 실체는 무엇일까요? person 객체는 다음과 같을 수 있습니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Person 객체&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Entity
@Name(&amp;quot;person&amp;quot;)
public class Person implements Serializable{
  private long id;
  private String name;
  //이하 코드 생략
  //getter-setter
  //Annotation
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;person 객체의 실체는 위와 같을 수 있습니다. 실제 Person 객체는 Seam Person 컴포넌트라고 하는 것이 정확한 표현입니다. Person 객체를 person 이라는 이름으로 참조 할 수 있는 것은  바로 Seam이 제공하는 컴포넌트 관리 모델때문입니다.&lt;/p&gt;

&lt;p&gt;그런데 Person 객체는 실제로 Entity Bean입니다. JPA에서 ORM으로 사용하는 POJO 객체입니다. JPA는 Java SE에서도 구동되는 기술임을 감안하면 아직까지는 크게 이상할 것은 없는 코드 입니다.&lt;/p&gt;

&lt;p&gt;그렇다면 manager 객체, 더 정확히 말해서 manager 컴포넌트의 실체는 무엇일까요?&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;manager 컴포넌트&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Stateless
@Name(&amp;quot;manager&amp;quot;)
public class ManagerAction implements Manager{
    @In @Out Person person;
    @Out List&amp;lt;Person&amp;gt; personList;
    @PersistenceContext EntityManager em;

    public String sayHello(){
      em.persist(person);
      person = null;
      return null;
    }
   //이하 코드 생략
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;여러가지 manager 컴포넌트 스타일을 생각해 볼 수 있지만 위와 같은 코드가 일반적입니다. 놀라운 것은 manager 컴포넌트는 실제 무상태 세션 빈이라는 것입니다. JSP 페이지의 테그라이브러리의 Expression Language 형태로 설정한 형태는 실제 세션빈의 메서드를 호출하는 것이었습니다.&lt;/p&gt;

&lt;p&gt;JSP를 통하여 별다른 작업 없이 ejb를 직접 호출하는 형태 입니다. JSF에 익숙하신 분들에게는 이렇게 표현하실 수 있습니다. (위 JSP는 실제 JSF 페이지 코드의 일부 입니다. )&lt;/p&gt;

&lt;h2 id=&#34;seam은-세션빈을-액션-리스너로-직접-사용할-수-있다:f19f716c8aeb01c785b0b485dd6debca&#34;&gt;Seam은 세션빈을 액션 리스너로 직접 사용할 수 있다.&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;JSF로 이런한 기능을 구현하기 위해서는 다음과 같은 작업을 거치게 됩니다&lt;/li&gt;
&lt;li&gt;JSF페이지에서 managed bean으로 등록된 컴포넌트의 메소드를 호출 그 메서드가 JDNI 룩업을 하고 전처리를 수행&lt;/li&gt;
&lt;li&gt;ejb를 호출&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Seam은 이런 절차를 모두 생략하고 직접 세션빈을 액션 리스너로 사용할 수 있는 방법을 제공합니다.&lt;/p&gt;

&lt;p&gt;이것이 Seam에서 이야기하는 컴포넌트 통합 모델의 근간 입니다.&lt;/p&gt;

&lt;p&gt;Seam은 기존에 경험하지 못했던 새로운 개념의 통합 컴포넌트 모델 관리 개념을 제공합니다. 컴포넌트를 직접 참조하는 것이 아니라 컴포넌트 이름으로 참조하고 이것을 관리하는 것은 Seam 프레임웍이 전담하는 형태입니다.&lt;/p&gt;

&lt;p&gt;사실 EJB 컴포넌트와 Web 컴포넌트를 통합하는 것은 Seam의 핵심 기능이기는 하지만 가장 밑바탕이 되는 기능중의 일부 입니다. Seam은 기존의 Dependency Injection을 확장하여 Bijection이라는 개념과 Context 개념을 강화하여 진보된 컴포넌트 관리 모델을 제공합니다.&lt;/p&gt;

&lt;p&gt;이런 의미에서 앞에서 살펴 보았던 Seam Logo 이미지를 다시 한번 살펴 보도록 하겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://taewan.kim/images/seamlogo.png&#34; alt=&#34;Seam Logo&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Seam 프레임웍 로고로 사용하는 빗살 무늬 로고는 아마도 두 개의 Tier로 나누어져 있는 컴포넌트를 서로 연결하는 상호작용 할 수 있도록 지원한다는 의미라고 저는 생각하고 있습니다.&lt;/p&gt;

&lt;p&gt;여러분들은 어떻게 보이시나요?&lt;/p&gt;

&lt;p&gt;간혹 이런 의미를 생각해 보는 것도 재미있는 것 같습니다.^^&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Hugo의 Syntax Highlight기능 구성</title>
      <link>http://taewan.kim/blog/2016/01/25/codehighlight/</link>
      <pubDate>Mon, 25 Jan 2016 17:19:38 +0900</pubDate>
      
      <guid>http://taewan.kim/blog/2016/01/25/codehighlight/</guid>
      <description>

&lt;p&gt;현재 taewan.kim은 블러그 생성 엔진으로 Hugo를 테마로는 Hyde-x를 사용하고 있습니다.
제가 Hugo를 처음 사용하면서 가장 혼동된 부분은 Syntax Hightlight를 구성하는 과정이었습니다.
Hugo에 대한 배경 지식이 부족하다 보니 Hugo의 Syntax Hightlight 기능에 대한 혼돈이 있었습니다.
이 부분에 대하여 간략히 정리해 보겠습니다.&lt;/p&gt;

&lt;h1 id=&#34;hugo의-syntax-highlight기능-지원-타입:8249a9659163c14ad6dd21231787110e&#34;&gt;Hugo의 Syntax Highlight기능 지원 타입&lt;/h1&gt;

&lt;p&gt;Hugo는 서버사이드 모드와 클라이언트 모드로 Syntax Highlight기능을 제공합니다.
서버사이드/클라이언트 모드는 Hugo의 config 파일에서 설정 됩니다.&lt;/p&gt;

&lt;h2 id=&#34;서버사이드-모드의-syntax-highlight:8249a9659163c14ad6dd21231787110e&#34;&gt;서버사이드 모드의 Syntax Highlight&lt;/h2&gt;

&lt;p&gt;서버사이드 모드는 빌드 시점에 Syntax Hightlight가 적용된 HTML을 생성하는 방식으로 pygments를 사용합니다.
pygments는 파이썬으로 만들어진 툴로 일반 코드에 syntax highlight를 적용하는 툴입니다.
서버사이드 모드를 사용하기 위해서는 hugo 빌드에 앞서 pygments가 사전에 설치되어 있어야 합니다.(pip install pygments)&lt;/p&gt;

&lt;h2 id=&#34;클라이언트-모드의-syntax-highlight:8249a9659163c14ad6dd21231787110e&#34;&gt;클라이언트 모드의 Syntax Highlight&lt;/h2&gt;

&lt;p&gt;클라이언트 모드는 브라우저에서 페이지를 로딩할 때 Syntax Highlight가 적용되는 방식으로,
다음과 같은 라이브러리를 사용합니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Highlight.js&lt;/li&gt;
&lt;li&gt;Prism&lt;/li&gt;
&lt;li&gt;Rainbow&lt;/li&gt;
&lt;li&gt;Syntax Highlighter&lt;/li&gt;
&lt;li&gt;Google Prettify&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;클라이언트-모드와-서버-모드의-syntax-highlight-기능-지원:8249a9659163c14ad6dd21231787110e&#34;&gt;클라이언트 모드와 서버 모드의 Syntax Highlight 기능 지원&lt;/h2&gt;

&lt;p&gt;Hugo는 두가지 모드에 대하여 적합한 변환을 Hugo 빌드 시 적용합니다.
그러나 두 변환 방식 중 어떤 것을 사용할 것인가는 일반적으로 테마가 결정합니다.
일반적으로 Theme의 README.md파일에 보면 어떤 방식을 지원하는지에 대한 설명이 기술되어 있습니다.&lt;/p&gt;

&lt;p&gt;현재 사용하고 있는 Hyde-X는 클라이언트 모드 만을 지원합니다.
Hyde-X는 Hightlight.js를 이용하여 Highlight기능을 구현합니다.
사실 Hyde-X가 서버사이드 모드도 지원하지만, 최종 빌드된 결과가 투박하고 가독성이 떨어집니다.
따라서 Hyde-x를 사용할 경우에는 클라이언트 모드를 사용하는 것이 효과적입니다.&lt;/p&gt;

&lt;h2 id=&#34;각-모드-별-설정-옵션-및-표기법:8249a9659163c14ad6dd21231787110e&#34;&gt;각 모드 별 설정 옵션 및 표기법&lt;/h2&gt;

&lt;h3 id=&#34;클라이언트-모드:8249a9659163c14ad6dd21231787110e&#34;&gt;클라이언트 모드&lt;/h3&gt;

&lt;p&gt;클라이언트 모드 설정은 config 파일에 highlight 속성으로 표시합니다.
highlight에 설정 가능한 값은 &lt;hugo_site&gt;/themes/static/css/highlight에서 확인 할 수 있습니다.
다음은 설정 예입니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; # Check the static/css/highlight directory for options.
 highlight = &amp;quot;github&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;~~~java
public static void main(String args[]){

}
~~~
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;위 설정에 대한 결과는 다음과 같습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static void main(String args[]){

}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;서버사이드-모드:8249a9659163c14ad6dd21231787110e&#34;&gt;서버사이드 모드&lt;/h3&gt;

&lt;p&gt;설정 옵션은 다음과 같습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pygmentsstyle = &amp;quot;monokai&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;유효한 설정 값은 &lt;a href=&#34;http://pygments.org/&#34;&gt;http://pygments.org/&lt;/a&gt; 에서 확인 할 수 있습니다.&lt;/p&gt;

&lt;h2 id=&#34;삽질-요약:8249a9659163c14ad6dd21231787110e&#34;&gt;삽질 요약&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Hugo는 클라이언트 모드와 서버사이드 모드의 Highlight를 지원한다.&lt;/li&gt;
&lt;li&gt;두 모드 중에서 사용 가능한 방식은 현재 사이트의 적용 테마가 결정한다.&lt;/li&gt;
&lt;li&gt;테마가 클라이언트 모드를 지원할 경우, highlisht 스타일은 static/css/highlight에서 확인 가능하다.&lt;/li&gt;
&lt;li&gt;테마가 서버사이드 모드를 지원할 경우, hugo 빌드를 수행하는 곳에는 pygments가 설치되어 있어야 한다.&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>taewan.kim을 오픈합니다.</title>
      <link>http://taewan.kim/blog/2016/01/25/first/</link>
      <pubDate>Mon, 25 Jan 2016 13:09:53 +0900</pubDate>
      
      <guid>http://taewan.kim/blog/2016/01/25/first/</guid>
      <description>&lt;p&gt;안녕하세요 김태완입니다.&lt;/p&gt;

&lt;p&gt;여러 블러그를 떠돌다 이번에 Hugo로 만든 정적 블러그에 정착하기로 했습니다.
이젠 힘들어서 이 녀석에 최대한 의지할 예정입니다.&lt;/p&gt;

&lt;p&gt;taewan.kim의 구성은 다음과 같습니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Hugo

&lt;ul&gt;
&lt;li&gt;theme: Hyde-X&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Host: github.io&lt;/li&gt;
&lt;li&gt;version control

&lt;ul&gt;
&lt;li&gt;github.com&lt;/li&gt;
&lt;li&gt;bitbucket.org&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Publishing: Jenkins at AWS&lt;/li&gt;
&lt;li&gt;Others

&lt;ul&gt;
&lt;li&gt;Google Analytics&lt;/li&gt;
&lt;li&gt;Disqus&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;taewan.kim은 기술과 소소한 일상을 주제로 운영될 블러그입니다. 많은 관심 부탁드립니다.&lt;/p&gt;

&lt;p&gt;감사합니다.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>