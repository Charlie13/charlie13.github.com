<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>taewan&#39;s blog</title>
    <link>http://taewan.kim/</link>
    <description>Recent content on taewan&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 21 Nov 2016 09:33:52 +0900</lastBuildDate>
    <atom:link href="http://taewan.kim/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>오라클 클라우드에서 window VM 인스턴스 생성</title>
      <link>http://taewan.kim/blog/2016/11/21/opc-window/</link>
      <pubDate>Mon, 21 Nov 2016 09:33:52 +0900</pubDate>
      
      <guid>http://taewan.kim/blog/2016/11/21/opc-window/</guid>
      <description>

&lt;p&gt;오라클 클라우드(Oracle Public Cloud, OPC)의 IaaS 서비스에서 Window VM 인스턴스로 만드는 절차를 정리합니다. 오라클 클라우드에서 가상머신을 생성하기 위해서는 Oracle Cloud의 계정이 필요합니다. 계정을 생성하는 방법에 대해서는 &lt;a href=&#34;http://taewan.kim/blog/2016/10/06/account_reg_of_oracloud/&#34;&gt;&amp;ldquo;오라클 클라우드 계정 생성하기&amp;rdquo;&lt;/a&gt; 를 참조하시기 바랍니다.&lt;/p&gt;

&lt;h2 id=&#34;oracle-cloud-vm-인스턴스-생성-실습:94992633c6f2d4e4cf6bd081f840f7fe&#34;&gt;Oracle Cloud VM 인스턴스 생성 실습&lt;/h2&gt;

&lt;p&gt;본 문서는 OS X(Mac) 환경에서 작성되었습니다. 이 문서를 실습함에 있어서 윈도우와 &amp;ldquo;OS X&amp;rdquo;의 차이는 거의 없습니다. Window VM을 생성한 이후에 RDP로 Window VM에 접속한는 부분에서만 차이가 있습니다. 이 부분은 Window와 &amp;ldquo;OS X&amp;rdquo;를 구분하여 문서를 작성했습니다. 본 문서는 2016년 11월 19일을 기준으로 작성되었습니다.&lt;/p&gt;

&lt;p&gt;오라클 클라우드 VM 생성 실습은 약 10~15분 정도 소요됩니다.&lt;/p&gt;

&lt;h3 id=&#34;실습-절차:94992633c6f2d4e4cf6bd081f840f7fe&#34;&gt;실습 절차&lt;/h3&gt;

&lt;p&gt;오라클 클라우드에 Window VM을 생성하는 실습은 다음과 같은 순서로 진행되며,
각 단계를 &amp;ldquo;Step by Step&amp;rdquo; 형태로 설명하겠습니다.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Oracle Cloud 로그인&lt;/li&gt;
&lt;li&gt;Window VM Instance 생성&lt;/li&gt;
&lt;li&gt;Security Rule 등록 (for RDP)&lt;/li&gt;
&lt;li&gt;Mac OS X에서 Window VM 접속하기&lt;/li&gt;
&lt;li&gt;Window 10에서 Window VM 접속하기&lt;/li&gt;
&lt;li&gt;Window VM 인스턴스 재시작&lt;/li&gt;
&lt;li&gt;Window VM 인스턴스 정지 및 제거&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;oracle-cloud에서-window-vm-생성:94992633c6f2d4e4cf6bd081f840f7fe&#34;&gt;Oracle Cloud에서 Window VM 생성&lt;/h2&gt;

&lt;h3 id=&#34;step01-oracle-cloud-로그인:94992633c6f2d4e4cf6bd081f840f7fe&#34;&gt;Step01. Oracle Cloud 로그인&lt;/h3&gt;

&lt;p&gt;OPC에 인스턴스를 생성하기 위해서 &lt;a href=&#34;http://cloud.oracle.com&#34;&gt;http://cloud.oracle.com&lt;/a&gt; 에 로그인해야 합니다.
[그림 1]에서 &amp;ldquo;sign in&amp;rdquo;을 클릭하면 리전을 선택하는 페이지가 출력됩니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;그림 1. &lt;a href=&#34;http://cloud.oracle.com&#34;&gt;http://cloud.oracle.com&lt;/a&gt; 메인 페이지
&lt;img src=&#34;https://minsupapa.github.io/oracle/opc/win-vm/0010.jpg&#34; alt=&#34;&#34; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;로그인에 앞서 인스턴스를 생성할 region을 선택합니다.
&lt;strong&gt;Free trial&lt;/strong&gt; 계정의 경우 [그림 2]와 같이 &lt;strong&gt;Public Cloud Services - US&lt;/strong&gt; 를 선택해야 합니다.
리전을 선택하고 &lt;code&gt;My Services&lt;/code&gt; 버튼을 클릭하면, 로그인 페이지로 이동하게 됩니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;그림 2. 서비스 리전 선택
&lt;img src=&#34;https://minsupapa.github.io/oracle/opc/win-vm/0020.jpg&#34; alt=&#34;&#34; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;OPC 로그인을 위해서 [그림 3]와 [그림 4]과 같이 도메인 ID, 계정 ID, 패스워드를 입력합니다.
[그림 3]에서 도메인 ID를 입력하고 &lt;code&gt;Go&lt;/code&gt; 버튼을 클릭하면 계정 ID/패스워드 입력 페이지로 이동합니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;그림 3. 도메인 ID 입력
&lt;img src=&#34;https://minsupapa.github.io/oracle/opc/win-vm/0030.jpg&#34; alt=&#34;&#34; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;[그림 4]와 같이 계정 ID/PASSWORD을 입력하고 &lt;code&gt;Sign In&lt;/code&gt; 버튼을 클릭하면 로그인이 수행됩니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;그림 4. 로그인 정보 입력
&lt;img src=&#34;https://minsupapa.github.io/oracle/opc/win-vm/0040.jpg&#34; alt=&#34;&#34; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;로그인이 정상적으로 처리되면 [그림 5]와 같이 &lt;strong&gt;Oracle Cloud My Services Dashboard&lt;/strong&gt; 가 출력됩니다.&lt;/p&gt;

&lt;h3 id=&#34;step02-window-vm-instance-생성:94992633c6f2d4e4cf6bd081f840f7fe&#34;&gt;Step02. Window VM Instance 생성&lt;/h3&gt;

&lt;p&gt;Dashboard 페이지에서는 [그림 5]와 같이 각 클라우드 서비스로 이동 가능한 블럭이 출력됩니다.
VM 인스턴스를 생성하는 Compute Cloud Service Console(이하 compute console)로 이동하기 위해서 &lt;code&gt;Create Instance&lt;/code&gt; 버튼을 클릭합니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;그림 5. Oracle Cloud My Services Dashboard
&lt;img src=&#34;https://minsupapa.github.io/oracle/opc/win-vm/0050.jpg&#34; alt=&#34;&#34; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;현재 Cloud 서비스에서 생성 가능한 유형이 출력됩니다. 우리는 Compute Cloud에서 Window VM 을 생성하기 위해 [그림 6]과 같이 &lt;code&gt;Compute&lt;/code&gt;를 클릭합니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;그림 6. Compute 서비스 선택
&lt;img src=&#34;https://minsupapa.github.io/oracle/opc/win-vm/0060.jpg&#34; alt=&#34;&#34; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Compute 클라우드 생성에 앞서 사용 할 운영체제 이미지를 선택해야 합니다. OPC Compute Cloud에서는 Oracle Image, Private Image 그리고 Marketplaces로 OS 이미지를 관리합니다.&lt;/p&gt;

&lt;p&gt;각 OS Images 관리 영역은 다음과 같이 관리 됩니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Oracle Images: 오라클 공식 VM 이미지 (Oracle Enterprise Linux)&lt;/li&gt;
&lt;li&gt;Private Images: 사용자 등록 이미지&lt;/li&gt;
&lt;li&gt;Marketplaces: 마켓 등록 이미지&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Marketplaces에는 2016/10/13 현재 335개의 OS 이미지가 등록되어 있습니다. Marketplaces는 [그림 7]과 같이 이동 할 수 있습니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;그림 7. Marketplaces 이동
&lt;img src=&#34;https://minsupapa.github.io/oracle/opc/win-vm/0070.jpg&#34; alt=&#34;&#34; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Marketplaces 에서 [그림 8]과 같이 &amp;ldquo;window&amp;rdquo;를 검색하고 &lt;strong&gt;Window8&lt;/strong&gt;을 클립합니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;그림 8. Window 검색 및 Window8 이미지 선택
&lt;img src=&#34;https://minsupapa.github.io/oracle/opc/win-vm/0080.jpg&#34; alt=&#34;&#34; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Marketplaces에서 설치할 이미지를 설치하면 라이센스 관련 동의 팝업 페이지가 출력됩니다. [그림 9]와 같이 두 개 항목을 체크하고 &lt;code&gt;install&lt;/code&gt; 버튼을 클릭합니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;그림 9. Marketplaces 이미지 설치를 위한 라이센스 동의
&lt;img src=&#34;https://minsupapa.github.io/oracle/opc/win-vm/0090.jpg&#34; alt=&#34;&#34; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Window8 이미지를 선택했으면 [그림 10]과 같이 VM 생성을 위해서 &lt;code&gt;&amp;gt;&lt;/code&gt; 버튼을 클릭합니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;그림 10. Window 8 설치 설정 시작
&lt;img src=&#34;https://minsupapa.github.io/oracle/opc/win-vm/0100.jpg&#34; alt=&#34;&#34; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Window VM 설치 첫 번째 단계로 대상 VM의 Shape을 선택합니다. 오라클은 [그림 11]같이 여러가지 Shape을 제공합니다.
[그림 11]과 같이 대상 Shpae을 선택하고, 다음 단계로 넘어가기 위해서 &lt;code&gt;&amp;gt;&lt;/code&gt; 버튼을 클릭합니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;그림 11. Shape 유형 선택
&lt;img src=&#34;https://minsupapa.github.io/oracle/opc/win-vm/0110.jpg&#34; alt=&#34;&#34; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;[그림 12]와 같이 설정을 입력합니다.
Public IP Address의 경우 이번에는 자동 생성을 사용할 것 입니다. 사전에 고정된 Public IP Address를 사용해야 한다면
사전에 생성된 Public IP Address를 선택할 수 있습니다.
리눅스 VM과 달리 Window VM은 SSH를 사용하지 않습니다. 따라서 &lt;code&gt;SSH keys&lt;/code&gt;를 설정할 필요가 없습니다.
윈도우 접속을 위해서 &lt;code&gt;RDP&lt;/code&gt;를 Enabled로 선택하고 Administorator 패스워드를 설정해야 합니다.
설정이 완료되었으면, 다음 단계로 넘어가기 위해서 &lt;code&gt;&amp;gt;&lt;/code&gt; 버튼을 클릭합니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;그림 12. VM Instance 설정 항목
&lt;img src=&#34;https://minsupapa.github.io/oracle/opc/win-vm/0120.jpg&#34; alt=&#34;&#34; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;[그림 13]에서는 스토리지 관련 페이지로 Block Storage를 추가할 수 있습니다.
현재 실습에서는 기본 스토리지만을 사용하므로 추가 설정 없이 넘어가겠습니다.
다음 단계로 넘어가기 위해서 &lt;code&gt;&amp;gt;&lt;/code&gt; 버튼을 클릭합니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;그림 13. 스토리지 추가
&lt;img src=&#34;https://minsupapa.github.io/oracle/opc/win-vm/0130.jpg&#34; alt=&#34;&#34; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;[그림 14]에서는 Window VM 생성을 위한 전체 설정을 확인하는 페이지 입니다. 설정에 이상이 없다면 &lt;code&gt;create&lt;/code&gt;버튼을 틀릭하여 Window VM 생성을
시작합니다. VM 생성은 5분 정도 소요됩니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;그림 14. 설정 요약
&lt;img src=&#34;https://minsupapa.github.io/oracle/opc/win-vm/0140.jpg&#34; alt=&#34;&#34; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;VM 생성은 Orchestration 텝에서 확인할 수 있습니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;그림 15. Orchestration 텝으로 이동
&lt;img src=&#34;https://minsupapa.github.io/oracle/opc/win-vm/0150.jpg&#34; alt=&#34;&#34; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Window VM이 생성되는 시점에서는 [그림 16]과 같이 3개의 Orchestration이 starting으로 출력됩니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;그림 16. Window VM 생성 중 Orchestration 상태
&lt;img src=&#34;https://minsupapa.github.io/oracle/opc/win-vm/0160.jpg&#34; alt=&#34;&#34; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Window VM 생성이 완료되면 3개의 Orchestration의 상태는 [그림 17]과 같이 &lt;strong&gt;Ready&lt;/strong&gt; 상태로 변경됩니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;그림 17. Window VM 생성 완료시 Orchestration 상태
&lt;img src=&#34;https://minsupapa.github.io/oracle/opc/win-vm/0170.jpg&#34; alt=&#34;&#34; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;step04-security-rule-등록-for-rdp:94992633c6f2d4e4cf6bd081f840f7fe&#34;&gt;Step04. Security Rule 등록 (for RDP)&lt;/h3&gt;

&lt;p&gt;Window VM 생성이 완료되면, Oracle Cloud에 생성된 Window에 접근하기 위해서는  RDP(Remote Desktop Protocol)을 사용해야 합니다.
외부에서 Window VM에 접근하기 위해서 RDP 포트를 외부에 오픈하는 설정을 추가해야 합니다. 현재 실습에 사용하는 컴퓨터에서 고정 IP가 아닌 유동 IP라면
사용중이라면 &amp;ldquo;Public Internet&amp;rdquo;에 RDP 포트를 오픈해야 합니다.&lt;/p&gt;

&lt;p&gt;이러한 설정을 하기 위해서는 &amp;ldquo;Compute Service Console&amp;rdquo;에서 [그림 18]과 같이 Network 텝으로 이동합니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;그림 18. 네트워크 설정 페이지 이동
&lt;img src=&#34;https://minsupapa.github.io/oracle/opc/win-vm/0180.jpg&#34; alt=&#34;&#34; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;RDP 포트에 대한 정의는 &amp;ldquo;Security Application&amp;rdquo;에 RDP라는 이름으로 사전에 만들어져 있습니다.
또한 &amp;ldquo;Pulbic Internet&amp;rdquo;은  Secirytp IP List에 빌트인으로 사전에 만들어져 있습니다. 따라서 [그림 19]와 같이 &lt;code&gt;create Security Rule&lt;/code&gt;버튼을 클릭하여 &amp;ldquo;Security Rules&amp;rdquo;을 만들수 있습니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;그림 19. Security Rule 생성
&lt;img src=&#34;https://minsupapa.github.io/oracle/opc/win-vm/0190.jpg&#34; alt=&#34;&#34; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;RDP를 위한 Security Rule은 [그림 20]과 같이 설정합니다.
참고로 앞 [그림 12]에서 Window VM 생성시 Security Lists를 default로 설정했었습니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Security List 설정 값

&lt;ul&gt;
&lt;li&gt;Name: RDP_SEC_Rule&lt;/li&gt;
&lt;li&gt;Status: Enabled&lt;/li&gt;
&lt;li&gt;Security Appplication: rdp&lt;/li&gt;
&lt;li&gt;Source Security IP List: public-internet&lt;/li&gt;
&lt;li&gt;Destination Security List: default&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;설정이 완료되면 &lt;code&gt;create&lt;/code&gt; 버튼을 클릭합니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;그림 20. RDP Security Rule 설정
&lt;img src=&#34;https://minsupapa.github.io/oracle/opc/win-vm/0200.jpg&#34; alt=&#34;&#34; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Security Rule이 정상적으로 생성되면, [그림 21]과 같이 Security Rules 목록이 출력됩니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;그림 21. RDP Security Rule 생설 결과
&lt;img src=&#34;https://minsupapa.github.io/oracle/opc/win-vm/0210.jpg&#34; alt=&#34;&#34; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;step05-mac-os-x에서-window-vm-접속하기:94992633c6f2d4e4cf6bd081f840f7fe&#34;&gt;Step05. Mac OS X에서 Window VM 접속하기&lt;/h3&gt;

&lt;p&gt;Mac OS에서 원격 Window에 접속하기 위해서 &lt;code&gt;Microsoft Remote Desktop&lt;/code&gt;을 설치해야 합니다. 이 프로그램은 App Store에서 무료로 제공됩니다.
[그림 22]는 App Store에서 &lt;code&gt;Microsoft Remote Desktop&lt;/code&gt;을 검색한 결과 입니다. 아래 &lt;code&gt;설치&lt;/code&gt; 버튼을 클릭하여 프로그램을 설치할 수 있습니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;그림 22. &lt;code&gt;Microsoft Remote Desktop&lt;/code&gt; 검색 결과 (@App Store)
&lt;img src=&#34;https://minsupapa.github.io/oracle/opc/win-vm/0220.jpg&#34; alt=&#34;&#34; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;Microsoft Remote Desktop&lt;/code&gt;이 설치되면 spotlight에서 [그림 23]과 같이 RDP를 실행할 수 있습니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;그림 23. &lt;code&gt;Microsoft Remote Desktop&lt;/code&gt; 실행
&lt;img src=&#34;https://minsupapa.github.io/oracle/opc/win-vm/0230.jpg&#34; alt=&#34;&#34; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;Microsoft Remote Desktop&lt;/code&gt;로 Window VM에 접속하기 위해서는 접속할 Window의 Public IP를 알아야 합니다.
앞서 생성한 Window VM의 IP는 [그림 24]에서 확인할 수 있습니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;그림 24. Public IP이 확인
&lt;img src=&#34;https://minsupapa.github.io/oracle/opc/win-vm/0240.jpg&#34; alt=&#34;&#34; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;Microsoft Remote Desktop&lt;/code&gt;에서 [그림 25]와 같이 &lt;code&gt;+&lt;/code&gt; 버튼을 클릭하여 접속 정보를 설정합니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;그림 25. &lt;code&gt;Microsoft Remote Desktop&lt;/code&gt;의 접속 정보 추가
&lt;img src=&#34;https://minsupapa.github.io/oracle/opc/win-vm/0250.jpg&#34; alt=&#34;&#34; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;접속 정보는 [그림 26]과 같이 설정됩니다. 특히 PC name에서 접속할 Window의 Public IP를 입력합니다.
Password 항목에는 [그림 12]에서 설정한 패스워드를 사용합니다. 설정이 완료되면 상단의 닫기 아이콘(red)을 클릭합니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;그림 26. RDP 접속 정보 설정
&lt;img src=&#34;https://minsupapa.github.io/oracle/opc/win-vm/0260.jpg&#34; alt=&#34;&#34; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;접속 정보가 설정완료되면 [그림 27]과 같이 출력됩니다. &amp;ldquo;opc-windiw8&amp;rdquo; 항목을 더블클릭하여 원격 윈도우 접속이 시작됩니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;그림 27. RDP 설정 결과 및 접속 시작
&lt;img src=&#34;https://minsupapa.github.io/oracle/opc/win-vm/0270.jpg&#34; alt=&#34;&#34; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;접속 과정에서 인증서 확인 절차가 [그림 28]과 같이 진행됩니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;그림 28. 접속중 인증서 확인
&lt;img src=&#34;https://minsupapa.github.io/oracle/opc/win-vm/0280.jpg&#34; alt=&#34;&#34; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;[그림 29 ~ 32]는 원격 윈도우에 접속하여 Google에 접속하는 일련의 과정입니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;그림 29. 윈도우 접속 중
&lt;img src=&#34;https://minsupapa.github.io/oracle/opc/win-vm/0290.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;그림 30. 윈도우 접속 완료
&lt;img src=&#34;https://minsupapa.github.io/oracle/opc/win-vm/0300.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;그림 31. 원격 윈도우에서 브라우저 실행
&lt;img src=&#34;https://minsupapa.github.io/oracle/opc/win-vm/0310.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;그림 32. 원격 윈도우에서 구글 접속
&lt;img src=&#34;https://minsupapa.github.io/oracle/opc/win-vm/0320.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;step06-window10에서-window-vm-접속하기:94992633c6f2d4e4cf6bd081f840f7fe&#34;&gt;Step06. Window10에서 Window VM 접속하기&lt;/h3&gt;

&lt;p&gt;윈도우에는 &lt;code&gt;Microsoft Remote Desktop&lt;/code&gt;이 기본적으로 설치되어 있습니다. [그림 33 ~ 37]은 &amp;ldquo;&amp;lsquo;원격 데스크톱 연결```을 실행하고
원격 윈도우에 접속하는 일련의 절차입니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;그림 33. &amp;ldquo;&amp;lsquo;원격 데스크톱 연결``` 시작
&lt;img src=&#34;https://minsupapa.github.io/oracle/opc/win-vm/0330.jpg&#34; alt=&#34;&#34; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;대상  VM의 Public IP는 [그림 24]에서 확인 할 수 있습니다. 이 IP를 [그림 34]에 입력합니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;그림 34. 접속 대상 Public IP 입력 및 연결
&lt;img src=&#34;https://minsupapa.github.io/oracle/opc/win-vm/0340.jpg&#34; alt=&#34;&#34; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;[그림 12]에서 설정한  RDP용 패스워드를 [그림 35]입력합니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;그림 35. 아이디/패스워드 입력
&lt;img src=&#34;https://minsupapa.github.io/oracle/opc/win-vm/0350.jpg&#34; alt=&#34;&#34; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;접속 과정에서 인증서 확인 절차가 [그림 36]과 같이 진행됩니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;그림 36. 접속중 인증서 확인
&lt;img src=&#34;https://minsupapa.github.io/oracle/opc/win-vm/0360.jpg&#34; alt=&#34;&#34; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;접속이 완료되면 [그림 37]과 같은 화면이 출력됩니다. [그림 37]에서는 앞에서 오픈한 브라우저가 화면에 출력되어 있는 것을 확인할 수 있습니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;그림 37. 브라우저 오픈된 상태 확인
&lt;img src=&#34;https://minsupapa.github.io/oracle/opc/win-vm/0370.jpg&#34; alt=&#34;&#34; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;step07-vm-인스턴스-재시작:94992633c6f2d4e4cf6bd081f840f7fe&#34;&gt;Step07: VM 인스턴스 재시작&lt;/h3&gt;

&lt;p&gt;OPC에 생성한 Window는 &lt;code&gt;Compute Service Console&lt;/code&gt;에서 [그림 38]과 같이 재시작 할 수 있습니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;그림 38. 윈도우 VM 재시작
&lt;img src=&#34;https://minsupapa.github.io/oracle/opc/win-vm/0380.jpg&#34; alt=&#34;&#34; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;step08-vm-인스턴스-정지-및-제거:94992633c6f2d4e4cf6bd081f840f7fe&#34;&gt;Step08: VM 인스턴스 정지 및 제거&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;Compute Service Console&lt;/code&gt;의 Orchestration 텝에서 생성한 VM을 정지 및 제거할 수 있습니다.
Orchestration을 통해서 VM을 제거할 때 약 5분 정도 소요됩니다.&lt;/p&gt;

&lt;p&gt;각 VM은 3개의 Orchestration으로 관리 됩니다. 3개 중에서 master가 대표 Orchestration입니다.
[그림 39]과 같이 win-tw_master를 정지하면 모든 자원은 제거 됩니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;그림 39. 윈도우 VM 종료
&lt;img src=&#34;https://minsupapa.github.io/oracle/opc/win-vm/0390.jpg&#34; alt=&#34;&#34; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;win-tw_master를 중지하면 [그림 40]과 같이 자원 해제에 대한 정보가 출력됩니다.
&lt;code&gt;yes&lt;/code&gt;버튼을 클릭하여 중지 작업을 계속합니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;그림 40. Orchestrations 시작 확인
&lt;img src=&#34;https://minsupapa.github.io/oracle/opc/win-vm/0400.jpg&#34; alt=&#34;&#34; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;win-tw_master의 종료가 완료되면 [그림 41]과 같이 3개의 orchestration의 상태가 stopped 상태로 변경됩니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;그림 41. Orchestrations 종료 확인 및 인스턴스 확인 이동
&lt;img src=&#34;https://minsupapa.github.io/oracle/opc/win-vm/0410.jpg&#34; alt=&#34;&#34; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Orchestration이 완려되면 윈도우 인스턴스는 [그림 42]와 같이 삭제 됩니다.
전체 인스턴스를 종료하고 삭제의 소요시간은 약 5분입니다.&lt;/p&gt;

&lt;h2 id=&#34;마치며:94992633c6f2d4e4cf6bd081f840f7fe&#34;&gt;마치며&lt;/h2&gt;

&lt;p&gt;지금까지 OPC에서 Window VM을 생성, 재시작 그리고 삭제하는 방법에 대하여 살펴보았습니다.
향후에 Ansible 및 Chef를 OPC에 적용하여 배포 자동화하는 방법에 대하여 살펴보겠습니다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Vagrant으로 구성하는 파이썬 데이터 분석 환경</title>
      <link>http://taewan.kim/blog/2016/10/19/env_datascience_vagrant/</link>
      <pubDate>Wed, 19 Oct 2016 23:04:19 +0900</pubDate>
      
      <guid>http://taewan.kim/blog/2016/10/19/env_datascience_vagrant/</guid>
      <description>&lt;p&gt;이 문서는 Vagrant가 설치되어 있다는 것을 가정합니다. 설치가 필요하시다면 &amp;ldquo;(내 친구 Vagrant를 소개합니다.)[&lt;a href=&#34;http://taewan.kim/blog/2016/02/06/vagrant_intro/]&amp;quot;를&#34;&gt;http://taewan.kim/blog/2016/02/06/vagrant_intro/]&amp;quot;를&lt;/a&gt; 참고하시기 바랍니다.&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/taewanme/5aec347b6fbfdc96495d3cc522b906cd.js&#34;&gt;&lt;/script&gt;

&lt;pre&gt;&lt;code&gt;git clone git@github.com:taewanme/vagrant4DS.git
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;`&lt;code&gt;vagrant up&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;taewan@vagrant4DS $vagrant up
Bringing machine &#39;default&#39; up with &#39;virtualbox&#39; provider...
==&amp;gt; default: Checking if box &#39;ubuntu/xenial64&#39; is up to date...
==&amp;gt; default: There was a problem while downloading the metadata for your box
==&amp;gt; default: to check for updates. This is not an error, since it is usually due
==&amp;gt; default: to temporary network problems. This is just a warning. The problem
## 로그 생략
==&amp;gt; default: Machine already provisioned. Run `vagrant provision` or use the `--provision`
==&amp;gt; default: flag to force provisioning. Provisioners marked to run always will still run.
taewan@vagrant4DS $vagrant
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;taewan@vagrant4DS $vagrant ssh
Welcome to Ubuntu 16.04.1 LTS (GNU/Linux 4.4.0-43-generic x86_64)

 * Documentation:  https://help.ubuntu.com
 * Management:     https://landscape.canonical.com
 * Support:        https://ubuntu.com/advantage

  Get cloud support with Ubuntu Advantage Cloud Guest:
    http://www.ubuntu.com/business/services/cloud

6 packages can be updated.
0 updates are security updates.


ubuntu@ubuntu-xenial:~$ ./jupyter.sh 
ubuntu@ubuntu-xenial:~$ nohup: redirecting stderr to stdout

ubuntu@ubuntu-xenial:~$ 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://minsupapa.github.io/vm/vagrant/forDataScience/step01.jpg&#34; alt=&#34;&#34; /&gt;
&lt;img src=&#34;https://minsupapa.github.io/vm/vagrant/forDataScience/step02.jpg&#34; alt=&#34;&#34; /&gt;
&lt;img src=&#34;https://minsupapa.github.io/vm/vagrant/forDataScience/step03.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>자바스크립트 함수형 프로그래밍 연습 - Table 테그 레퍼</title>
      <link>http://taewan.kim/blog/2016/10/18/functional_javascript/</link>
      <pubDate>Tue, 18 Oct 2016 21:28:14 +0900</pubDate>
      
      <guid>http://taewan.kim/blog/2016/10/18/functional_javascript/</guid>
      <description>&lt;p&gt;최근에 함수형 언어을 다른 시각에서 접근한다는 취지로 &amp;ldquo;&lt;a href=&#34;http://www.hanbit.co.kr/store/books/look.php?p_code=B9124201558&#34;&gt;함수형 자바스크립트 : 새롭고 올바른 자바스크립트 프로그래밍 기법&lt;/a&gt;&amp;ldquo;을 보고 있습니다. (기존에는 Scala를 중심으로 함수형을 접근했습니다.) 이 책의 4장까지의 내용을 기초로 테이블 테그 래퍼를 작성해 보았습니다.&lt;/p&gt;

&lt;p&gt;이 책에서는 함수형을 지원하기 위해서 underscore.js를 사용하고 있지만, ES6는 함수형의 핵심 함수들을 대부분 포함하고 있습니다.&lt;/p&gt;

&lt;p&gt;첫번째 구현체를 ES6 코드로 작성해 보았습니다.&lt;/p&gt;

&lt;p&gt;코드를 리뷰해 주신 분의 의견은 &amp;ldquo;함수형을 빙지한 순차적 프로그래밍이다&amp;rdquo;라는 리뷰를 받았습니다.
함수형 코드를 모방한 함수를 사용하기는 했지만 지역변수가 존재하고 제어문이 그대로 노출되는 문제를 안고 있습니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;그림 1. 첫번째 구현체 (초기 버전)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;https://minsupapa.github.io/javascript/functional_practice/fig01.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;이 부분을 다시 구현해 보았습니다. 주안점을 둔 부분은 다음과 같습니다.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;제어문을 제거&lt;/li&gt;
&lt;li&gt;지역 변수를 사용 금지&lt;/li&gt;
&lt;li&gt;배열 검증&lt;/li&gt;
&lt;li&gt;ES6 기반 코드&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;ul&gt;
&lt;li&gt;그림 2. 두번째 구현체 수정 코드&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;https://minsupapa.github.io/javascript/functional_practice/fig02.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;함수형 코드를 사용함에 있어서 장점은..&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;코드의 재사용성이 높아짐&lt;/li&gt;
&lt;li&gt;재사용성을 높이는 Generic 함수 디자인 가능&lt;/li&gt;
&lt;li&gt;코드이 가독성이 높아짐&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이러한 특징을 볼 수 있는것 같습니다.
그러나 너무 어렵네요&amp;hellip;.&lt;/p&gt;

&lt;p&gt;다음은 두 번째 코드입니다.
아직은 연습하는 입장에서 문제가 많습니다.&lt;/p&gt;

&lt;p&gt;다양한 리뷰 부탁드립니다.
스칼라를 주로 사용하다가 자바스크립트로 함수형 프로그래밍을 해보니 역시 힘드네요.
(아직 함수형 개념이 부족한듯 합니다)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;wrapper = function(tag){
    return function(v){return &#39;&amp;lt;&#39; + tag + &#39;&amp;gt;&#39; + v + &#39;&amp;lt;/&#39; + tag + &#39;&amp;gt;&#39;;};
}

initArr = function(arr){
    return Array.isArray(arr) ? arr : []
}


var people = [
  [&#39;김민수&#39;,&#39;3&#39;,&#39;아들&#39;],
  [&#39;임선영&#39;,&#39;39&#39;,&#39;엄마&#39;],
  [&#39;김태완&#39;,&#39;43&#39;,&#39;아빠&#39;]
];
var labels = [&#39;이름&#39;,&#39;나이&#39;,&#39;비고&#39;];


tableGen = function(matrix, head, wrapfun){
    const tr = wrapfun(&#39;tr&#39;);
    const td = wrapfun(&#39;td&#39;);

    return wrapfun(&#39;table&#39;)(
        wrapfun(&#39;thead&#39;)(initArr(head).reduce( (p,c)=&amp;gt;p+td(c),&#39;&#39;)) +
        wrapper(&#39;tbody&#39;)(initArr(matrix).reduce( (p,c)=&amp;gt;p+tr(c.reduce((sp,sc)=&amp;gt;sp+td(sc),&#39;&#39;)),&#39;&#39;))
    );
}

var tbltag = tableGen(people, labels, wrapper)

$$html$$ = tbltag
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Oracle Public Cloud 모음</title>
      <link>http://taewan.kim/opc.html</link>
      <pubDate>Wed, 12 Oct 2016 17:18:09 +0900</pubDate>
      
      <guid>http://taewan.kim/opc.html</guid>
      <description>&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://taewan.kim/blog/2016/10/06/account_reg_of_oracloud/&#34;&gt;오라클 클라우드 계정 생성하기&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://taewan.kim/blog/2016/10/12/iaas_quick/&#34;&gt;오라클 IaaS를 이용한 VM 인스턴스 생성&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>오라클 IaaS를 이용한 VM 인스턴스 생성</title>
      <link>http://taewan.kim/blog/2016/10/12/iaas_quick/</link>
      <pubDate>Wed, 12 Oct 2016 10:27:49 +0900</pubDate>
      
      <guid>http://taewan.kim/blog/2016/10/12/iaas_quick/</guid>
      <description>

&lt;p&gt;오라클 클라우드의 IaaS 서비스에서 Ubuntu 14.04를 VM 인스턴스로 만드는 절차를 정리합니다. 오라클 클라우드에서 가상머신을 생성하기 위해서는 Oracle Cloud의 계정이 필요합니다. 계정을 생성하는 방법에 대해서는 &lt;a href=&#34;http://taewan.kim/blog/2016/10/06/account_reg_of_oracloud/&#34;&gt;&amp;ldquo;오라클 클라우드 계정 생성하기&amp;rdquo;&lt;/a&gt; 를 참조하시기 바랍니다.&lt;/p&gt;

&lt;h2 id=&#34;oracle-cloud-vm-인스턴스-생성-실습:7a6448865fd6548e9403a0ce293d8c64&#34;&gt;Oracle Cloud VM 인스턴스 생성 실습&lt;/h2&gt;

&lt;p&gt;본 문서는 OS X(Mac) 환경에서 작성되었습니다. 이 문서를 윈도우에서 실습하실 경우에는 PUTTY와 같은 Terminal을 사용하는 부분과 SSH-KEYGEN을 사용하는 절차가 달라질 것입니다. 이 부분에 대해서는 별도 문서로 정리하겠습니다.&lt;/p&gt;

&lt;p&gt;오라클 클라우드 VM 생성 실습은 약 10~15분 정도 소요됩니다.&lt;/p&gt;

&lt;h3 id=&#34;실습-절차:7a6448865fd6548e9403a0ce293d8c64&#34;&gt;실습 절차&lt;/h3&gt;

&lt;p&gt;오라클 클라우드에 VM을 생성하는 실습은 다음과 같은 순서로 진행되며,
각 단계를 &amp;ldquo;Step by Step&amp;rdquo; 형태로 설명하겠습니다.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;로컬 컴퓨터 ssh key 생성&lt;/li&gt;
&lt;li&gt;Oracle Cloud 로그인&lt;/li&gt;
&lt;li&gt;Compute Cloud Service Console&lt;/li&gt;
&lt;li&gt;Network 설정

&lt;ul&gt;
&lt;li&gt;Public Key 등록&lt;/li&gt;
&lt;li&gt;Public IP 생성&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;VM Instance 생성&lt;/li&gt;
&lt;li&gt;Security Rule 등록 (for SSH)&lt;/li&gt;
&lt;li&gt;VM 로그인 및 nginx 설치&lt;/li&gt;
&lt;li&gt;Security 등록 (for 80포트) 및 브라우저 접근&lt;/li&gt;
&lt;li&gt;VM 인스턴스 정지&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;oracle-cloud-vm-생성:7a6448865fd6548e9403a0ce293d8c64&#34;&gt;Oracle Cloud VM 생성&lt;/h2&gt;

&lt;h3 id=&#34;step01-로컬-컴퓨터-ssh-key-생성:7a6448865fd6548e9403a0ce293d8c64&#34;&gt;Step01: 로컬 컴퓨터 ssh key 생성&lt;/h3&gt;

&lt;p&gt;Oracle Public Cloud(이하 OPC)에 가상 머신을 생성하면,
사용자는 자신의 컴퓨터 터미널 프로그램을 사용하여 ssh로 VM 인스턴스(이하 인스턴스)에 접근하게 됩니다.
OPC에 인스턴스를 생성하는 과정에는 접근할 컴퓨터의 SSH 공개키를 등록하는 단계를 포함합니다.
이렇게 OPC에 등록된 ssh 공개키는 접속할 컴퓨터를 인증하는 용도로 사용됩니다.&lt;/p&gt;

&lt;p&gt;리눅스와 OS X에서 OPC의 인스턴스에 접속할 때 사용되는 암호화 키는 다음과 같은 명령으로 생성됩니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;ssh-keygen -t rsa
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;[그림 1]은 ssh-keygen 명령으로 암호화 키를 생성하는 스크린 샷입니다.
ssh-keygen 명령으로 암호화 키를 생성할때 기본 파일 생성 디렉터리와 파일명은 다음과 같습니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;기본 디렉터리: &lt;USER_HOME&gt;/.ssh/&lt;/li&gt;
&lt;li&gt;기본 파일명: id_rsa / id_rsa.pub&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;taewan@.ssh $pwd
/Users/taewan/.ssh
taewan@.ssh $ls -al
drwx------   24 taewan  staff   816 10 11 15:15 .
drwxr-xr-x+ 147 taewan  staff  4998 10 11 15:15 ..
-rw-------    1 taewan  staff  1675 10 11 13:58 id_rsa
-rw-------    1 taewan  staff   415 10 11 13:58 id_rsa.pub
taewan@.ssh $
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;그림 1. ssh-keygen 명령을 이용한 암호화키 생성
&lt;img src=&#34;http://taewan.kim/images/oracloud/iaas_quick/step010.jpg&#34; alt=&#34;&#34; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ssh-keygen 명령으로 생성된 파일 중 확장자가 pub인 파일이 공개키입니다.
[그림 1]에서 생성한 id_rsa.pub에 포함된 내용이 OPC에 등록되며, 이 정보는 향후 해당 인스턴스의 운영체제 접속시점에 사용 됩니다.
id_ras.pub에 저장되어 있는 내용은 [그림 2]와 같습니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;그림 2. ssh-keygen으로 생성한 공개키
&lt;img src=&#34;http://taewan.kim/images/oracloud/iaas_quick/step020.jpg&#34; alt=&#34;&#34; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;step02-oracle-cloud-로그인:7a6448865fd6548e9403a0ce293d8c64&#34;&gt;Step02: Oracle Cloud 로그인&lt;/h3&gt;

&lt;p&gt;OPC에 인스턴스를 생성하기 위해서 &lt;a href=&#34;http://cloud.oracle.com&#34;&gt;http://cloud.oracle.com&lt;/a&gt; 에 로그인해야 합니다.
[그림 3]에서 &amp;ldquo;sign in&amp;rdquo;을 클릭하면 리전을 선택하는 페이지가 출력됩니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;그림 3. &lt;a href=&#34;http://cloud.oracle.com&#34;&gt;http://cloud.oracle.com&lt;/a&gt; 메인 페이지
&lt;img src=&#34;http://taewan.kim/images/oracloud/iaas_quick/step030.jpg&#34; alt=&#34;&#34; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;로그인에 앞서 인스턴스를 생성할 region을 선택합니다.
&lt;strong&gt;Free trial&lt;/strong&gt; 계정의 경우 [그림 4]와 같이 &lt;strong&gt;Public Cloud Services - US&lt;/strong&gt; 를 선택해야 합니다.
리전을 선택하고 &lt;code&gt;My Services&lt;/code&gt; 버튼을 클릭하면, 로그인 페이지로 이동하게 됩니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;그림 4. &lt;a href=&#34;http://cloud.oracle.com&#34;&gt;http://cloud.oracle.com&lt;/a&gt; 메인 페이지
&lt;img src=&#34;http://taewan.kim/images/oracloud/iaas_quick/step040.jpg&#34; alt=&#34;&#34; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;OPC 로그인을 위해서 [그림 5]와 [그림 6]과 같이 도메인 ID, 계정 ID, 패스워드를 입력합니다.
[그림 5]에서 도메인 ID를 입력하고 &lt;code&gt;실행&lt;/code&gt; 버튼을 클릭하면 계정 ID/패스워드 입력 페이지로 이동합니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;그림 5. 도메인 ID 입력
&lt;img src=&#34;http://taewan.kim/images/oracloud/iaas_quick/step050.jpg&#34; alt=&#34;&#34; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;[그림 6]과 같이 계정 ID/PASSWORD을 입력하고 &lt;code&gt;사인인&lt;/code&gt; 버튼을 클릭하면 로그인이 수행됩니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;그림 6. 로그인 정보 입력
&lt;img src=&#34;http://taewan.kim/images/oracloud/iaas_quick/step060.jpg&#34; alt=&#34;&#34; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;로그인이 정상적으로 처리되면 [그림 7]과 같은 &lt;strong&gt;Oracle Cloud My Services Dashboard&lt;/strong&gt; 가 출력됩니다.&lt;/p&gt;

&lt;h3 id=&#34;step03-compute-cloud-service-console-이동:7a6448865fd6548e9403a0ce293d8c64&#34;&gt;Step03: compute Cloud Service Console 이동&lt;/h3&gt;

&lt;p&gt;Dashboard 페이지에서는 [그림 7]과 같이 각 클라우드 서비스로 이동 가능한 블럭이 출력됩니다.
VM 인스턴스를 생성하는 &lt;strong&gt;Compute Cloud Service Console(이하 compute console)&lt;/strong&gt; 로 이동하기 위해서 Dashboard의 왼쪽 상단의 메뉴 아이콘을 클릭합니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;그림 7. Dashboard 페이지의 메뉴 아이콘 선택
&lt;img src=&#34;http://taewan.kim/images/oracloud/iaas_quick/step070.jpg&#34; alt=&#34;&#34; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;[그림 7]에서 메뉴 아이콘을 클릭하면 왼편에 [그림 8]과 같이 각 서비스 콘솔과
모니터링 콘솔 페이지 이동을 지원하는 메뉴가 출력됩니다.
출력된 메뉴 중에서 &lt;strong&gt;compute&lt;/strong&gt; 를 클릭합니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;그림 8. Compute 서비스 선택
&lt;img src=&#34;http://taewan.kim/images/oracloud/iaas_quick/step080.jpg&#34; alt=&#34;&#34; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;step04-네트워크-설정:7a6448865fd6548e9403a0ce293d8c64&#34;&gt;Step04: 네트워크 설정&lt;/h3&gt;

&lt;p&gt;Comput Console에서 네트워크 텝을 선택하여 [그림 9]와 같이 네트워크 설정 페이지로 이동합니다.
네트워크 설정 페이지 에서는 Security Rule, Security List, Security Application, Security IP List, IP Reservation, SSH Public Key를 설정할 수 있습니다.
다음은 설정 메뉴에 대한 요약입니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Security Lists: 보안 대상 서버 그룹 설정, 일종의 방화벽 구성&lt;/li&gt;
&lt;li&gt;Security Rules: 보안 대상 서버 그룹에 설정할 보안 룰 정의&lt;/li&gt;
&lt;li&gt;Security Applications: Security Rule에서 사용할 포트 정보 등록 및 관리&lt;/li&gt;
&lt;li&gt;Security IP Lists: OPC 계정이 관리히지 않는 외부 시스템의 IP 목록 관리&lt;/li&gt;
&lt;li&gt;IP Reservations: Public IP 생성 및 관리&lt;/li&gt;
&lt;li&gt;SSH Public Keys: SSH Public Key 등록&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;네트워크 설정 관련해서는 별도의 문서로 정리하겠습니다.
본 문서에서는 IP Reservation과 SSH Public Key만을 사용할 것입니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;그림 9. Compute Cloud Service Console
&lt;img src=&#34;http://taewan.kim/images/oracloud/iaas_quick/step090.jpg&#34; alt=&#34;&#34; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;ssh-public-key-등록:7a6448865fd6548e9403a0ce293d8c64&#34;&gt;SSH Public Key 등록&lt;/h4&gt;

&lt;p&gt;앞에서 생성한 SSH 공개키(그림 2 참조)의 내용을 등록해야 합니다. 여기에서 등록한 public키는 VM 생성시 인스턴스에 할당되고,
향후에 터미널을 통해서 ssh를 이용하여 시스템에 접근할 때 사용됩니다.&lt;/p&gt;

&lt;p&gt;네트워크 페이지에서 SSH 공개키[그림 10]와 같이 &lt;strong&gt;SSH Public Keys&lt;/strong&gt; 를 선택하여 SSH Public Key 등록 페이지로 이동합니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;그림 10. SSH Public Keys 페이지 이동
&lt;img src=&#34;http://taewan.kim/images/oracloud/iaas_quick/step100.jpg&#34; alt=&#34;&#34; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;[그림 11]과 같이 &lt;code&gt;Add SSH Public Key&lt;/code&gt;을 클릭하면 [그림 12]와 같이 SSH Public Key 등록 폼이 출력됩니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;그림 11. &lt;code&gt;SSH Public Keys&lt;/code&gt; 추가 버튼 클릭
&lt;img src=&#34;http://taewan.kim/images/oracloud/iaas_quick/step110.jpg&#34; alt=&#34;&#34; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;[그림 2]에서 생성한 공개키 파일의 내용을 복사하여 [그림 12]의 등록 폼에 입력합니다.
공개키 이름을 입력한 후 &lt;code&gt;Add&lt;/code&gt; 버튼을 클릭하면 공개키 등록 절차가 완료됩니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;그림 12. SSH Public 등록 폼
&lt;img src=&#34;http://taewan.kim/images/oracloud/iaas_quick/step120.jpg&#34; alt=&#34;&#34; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;공개키 등록이 완료되면 [그림 13]에서 공개키가 등록된 결과를 확인 할 수 있습니다.
이제 Public IP를 생성하기 위해서 &lt;code&gt;IP Reservation&lt;/code&gt; 메뉴를 클릭합니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;그림 13. 공개 키 등록 확인 및 IP Reservation 페이지로 이동
&lt;img src=&#34;http://taewan.kim/images/oracloud/iaas_quick/step130.jpg&#34; alt=&#34;&#34; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;public-ip-생성:7a6448865fd6548e9403a0ce293d8c64&#34;&gt;Public IP 생성&lt;/h4&gt;

&lt;p&gt;VM을 관리함에 있어서 Public IP를 예약하고 재사용하는 것이 편리합니다.
Public IP를 예약하지 않을 경우 VM을 재시작 할 때 마다 새로운 Public IP가 적용됩니다.
VM 인스턴스를 효과적으로 관리하기 위해서는 Public IP를 사전에 생성하고, 인스턴스에 할당해야 합니다.&lt;/p&gt;

&lt;p&gt;[그림 14]와 같이 &lt;code&gt;Create IP Reservation&lt;/code&gt; 버튼을 클릭하면 공개 IP 설정 폼이 출력 됩니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;그림 14. Public IP를 생성하기 위한 &lt;code&gt;Create IP Reservation&lt;/code&gt; 클릭.
&lt;img src=&#34;http://taewan.kim/images/oracloud/iaas_quick/step140.jpg&#34; alt=&#34;&#34; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;생성할 공개 IP에 할당 될 IP 명을 입력하고 &lt;code&gt;Create&lt;/code&gt; 버튼을 클릭하면 IP 생성은 완료됩니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;그림 15. Public IP 명 설정 및 생성
&lt;img src=&#34;http://taewan.kim/images/oracloud/iaas_quick/step150.jpg&#34; alt=&#34;&#34; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;공개 IP 생성이 완료되면, [그림 16]과 같이 생성된 공개 IP를 목록에서 확인할 수 있습니다.
이제 VM Instance를 생성하기 위해서 상단의 &lt;strong&gt;Instances&lt;/strong&gt; 텝을 클릭합니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;그림 16. 공개 IP 목록
&lt;img src=&#34;http://taewan.kim/images/oracloud/iaas_quick/step160.jpg&#34; alt=&#34;&#34; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;step04-vm-인스턴스-생성:7a6448865fd6548e9403a0ce293d8c64&#34;&gt;Step04: VM 인스턴스 생성&lt;/h3&gt;

&lt;p&gt;이제 &lt;code&gt;Create Instance&lt;/code&gt; 버튼을 클릭하여 인스턴스 생성 페이지로 이동합니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;그림 17. &lt;code&gt;Create Instance&lt;/code&gt; 버튼 클릭
&lt;img src=&#34;http://taewan.kim/images/oracloud/iaas_quick/step170.jpg&#34; alt=&#34;&#34; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Boot Images 선택 페이지로 이동합니다. OPC는 3가지의 유형의 Images를 제공합니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Oracle Images: 오라클 공식 VM 이미지 (Oracle Enterprise Linux)&lt;/li&gt;
&lt;li&gt;Private Images: 사용자 등록 이미지&lt;/li&gt;
&lt;li&gt;Marketplaces: 마켓 등록 이미지&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Ubuntu Boot Image를 선택하기 위해서 왼쪽 메뉴에서 &amp;ldquo;Marketplaces&amp;rdquo;를 클릭합니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;그림 18. Marketplaces 이동 메뉴
&lt;img src=&#34;http://taewan.kim/images/oracloud/iaas_quick/step180.jpg&#34; alt=&#34;&#34; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Marketplaces에는 2016/10/13 현재 335개의 boot 이미지가 등록되어 있습니다.
필요한 이미지는 [그림 19]와 같이 검색 가능합니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;그림 19. Marketplaces의 검색 기능
&lt;img src=&#34;http://taewan.kim/images/oracloud/iaas_quick/step190.jpg&#34; alt=&#34;&#34; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;[그림 20]과 같이 검색어로 &amp;ldquo;ubuntu&amp;rdquo;를 입력하면 ubuntu로 tagging된 모든 이미지가 조회 됩니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;그림 20. Marketplaces의 검색 &amp;ldquo;Ubuntu&amp;rdquo;
&lt;img src=&#34;http://taewan.kim/images/oracloud/iaas_quick/step200.jpg&#34; alt=&#34;&#34; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;검색된 Ubuntu 이미지 중에 &amp;ldquo;Ubuntu Server 14.04 LTS amd64&amp;rdquo;를 선택하고 [그림 21]과 같이 오른쪽 상단의 &lt;code&gt;&amp;gt;&lt;/code&gt; 버튼을 클릭합니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;그림 21. 설치 Boot 이미지 선택
&lt;img src=&#34;http://taewan.kim/images/oracloud/iaas_quick/step210.jpg&#34; alt=&#34;&#34; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Marketplaces에서 이미지를 선택하면 현재 계정의 Compute Cloud에 다운로드 됩니다. 이와 관련된 알림과 승인 창이 출력됩니다.
[그림 22]와 같이 승인 체크 박스에 체크하고 &amp;ldquo;Install&amp;rdquo;을 선택합니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;그림 22. 대상 이미지 다운로드 및 승인 확인 알림
&lt;img src=&#34;http://taewan.kim/images/oracloud/iaas_quick/step220.jpg&#34; alt=&#34;&#34; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;다음으로는 인스턴스의 Shape을 선택하는 페이지로 이동합니다. [그림 23]과 같이 현재 3개의 Shape을 제공합니다.
&amp;ldquo;General Purpose&amp;rdquo;를 선택하고 오른쪽 상단의 &lt;code&gt;&amp;gt;&lt;/code&gt; 버튼을 클릭합니다.
&amp;ldquo;General Purpose&amp;rdquo;로 생성된 인스턴스에는 1 ocpu / memory 7.5GB의 자원이 할당됩니다.
1 OCPU는 아마존 2 vCPU와 동일한 용량을 제공합니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;그림 23. 설치할 Compute의 Shape 선택
&lt;img src=&#34;http://taewan.kim/images/oracloud/iaas_quick/step240.jpg&#34; alt=&#34;&#34; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;[그림 24]와 같은 기본 폼이 출력됩니다.
- 그림 24. VM Instance 생성 폼
&lt;img src=&#34;http://taewan.kim/images/oracloud/iaas_quick/step250.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;[그림 25]와 같이 인스턴스 명, host 명을 입력합니다. 추가로 Public IP Address에 &lt;strong&gt;Persistant Public IP Reservation&lt;/strong&gt; 을 선택하면 앞에서 생성한 Public IP를 선택하는 입력 폼이 추가됩니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;그림 25. &amp;ldquo;ㅜname&amp;rdquo; 지정 및 DNS Hostname Prefix 지정
&lt;img src=&#34;http://taewan.kim/images/oracloud/iaas_quick/step260.jpg&#34; alt=&#34;&#34; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;[그림 26]과 같이 Public IP Address에는 [그림 16]에서 생성한 Public IP를 선택합니다. Security List 항목에는 기본적으로 생성된 default를 선택합니다. 그리고 SSH Key에는 [그림 13]에서 등록한 SSH 공개키를 선택합니다. 이상으로 입력이 완료되면 오른쪽 상단의 &lt;code&gt;&amp;gt;&lt;/code&gt; 버튼을 클릭합니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;그림 26. Public IP, Security List, SSH Key 입력
&lt;img src=&#34;http://taewan.kim/images/oracloud/iaas_quick/step280.jpg&#34; alt=&#34;&#34; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;[그림 27]은 스토리지 설정 페이징 입니다.
스토리지 관련해서는 별도의 문서로 다룰 것입니다.
지금은 기본적으로 만들어진 &amp;ldquo;demo_ubuntu_vm_storage&amp;rdquo;를 그대로 사용할 것입니다.
이제 모든 설정은 완료되었습니다. 오른쪽 상단의 &lt;code&gt;&amp;gt;&lt;/code&gt; 버튼을 클릭합니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;그림 27. Storage 설정 페이지
&lt;img src=&#34;http://taewan.kim/images/oracloud/iaas_quick/step290.jpg&#34; alt=&#34;&#34; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;[그림 28]은 지금까지 인스턴스 생성 설정에 대한 요약 정보가 출력됩니다.
모든 정보가 맞다면 &lt;code&gt;Create&lt;/code&gt; 버튼을 클릭하여 인스턴스를 생성합니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;그림 28. Instance 요약
&lt;img src=&#34;http://taewan.kim/images/oracloud/iaas_quick/step300.jpg&#34; alt=&#34;&#34; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;[그림 28]에서 &lt;code&gt;Create&lt;/code&gt; 버튼을 클릭하면 Instances 페이지로 이동합니다.
Instances에는 현재 인스턴스가 추가되지 않은 상태입니다.
현재 생성중인 인스턴스 상태는 Orchestrations 텝에서  확인 할 수 있습니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;그림 29. Orchestrations 텝 이동
&lt;img src=&#34;http://taewan.kim/images/oracloud/iaas_quick/step310.jpg&#34; alt=&#34;&#34; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;[그림 30]과 같이 Orchestrations 탭에는 3개의 orchestation이 등록되어 있고 2개가 동작중인 것을 확인할 수 있습니다.
각각은 master, storage, instance 용 orchestration입니다.
master는 storage와 instance orchestration을 실행하는 역할을 담당합니다.
storage orchestration이 먼저 실행디고 그 다음
Instance Orchestration이 실행됩니다.
지금 생성하는 인스턴스의 생성 소요 시간은 약 3~5분정도 입니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;그림 30. Orchestrations 목록과 상태
&lt;img src=&#34;http://taewan.kim/images/oracloud/iaas_quick/step320.jpg&#34; alt=&#34;&#34; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;인스턴스 생성이 완료되면 [그림 31]과 같이 Orchestrations 목록이 모두 Ready 상태로 변경된 것을 확인 할 수 있습니다.
Orchestration이 완료되었다면 Instances 텝으로 이동합니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;그림 31. 인스턴스 생성이 완료된 Orchestrations 목록과 상태
&lt;img src=&#34;http://taewan.kim/images/oracloud/iaas_quick/step330.jpg&#34; alt=&#34;&#34; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Instances 텝에서 새로 등록된 인스턴스를 확인할 수 있습니다.
또한 인스턴스에 사전에 등록한 Public IP가 설정되어 있는 것을 확인할 수 있습니다.
현재 인스턴스에는 외부에서 접근 불가능한 상태 입니다.
외부에서 접근을 하기 위해서는 Network 텝으로 이동하여 Security Rule을 등록해야 합니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;그림 32. 인스턴스 등록 확인
&lt;img src=&#34;http://taewan.kim/images/oracloud/iaas_quick/step340.jpg&#34; alt=&#34;&#34; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;step04-security-rule-등록-for-ssh:7a6448865fd6548e9403a0ce293d8c64&#34;&gt;Step04: Security Rule 등록 (for SSH)&lt;/h3&gt;

&lt;p&gt;사용자 컴퓨터 터미널에서 ssh로 앞에서 생성한 인스턴스에 접근하기 위해서,
인스턴스에 ssh가 사용하는 22번 포트에 대한 보안 설정을 추가해야 합니다.
이러한 보안 설정은 Security Rule에서 설정됩니다.
Network 텝의 왼쪽 메뉴에서 &amp;ldquo;Security Rule&amp;rdquo;로 이동합니다.
&amp;ldquo;Security Rule&amp;rdquo; 페이지에서 [그림 33]과 같이 &lt;code&gt;Create Security Rule&lt;/code&gt; 버튼을 클릭하면
Security Rule을 추가할 수 있습니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;그림 33. Security Rule 등록
&lt;img src=&#34;http://taewan.kim/images/oracloud/iaas_quick/step350.jpg&#34; alt=&#34;&#34; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;[그림 34]는 Security Rule 등록 폼입니다. Security Rule을 등록하기 위해서는 다음과 같은 정보를 입력해야 합니다.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Security rule 명&lt;/li&gt;
&lt;li&gt;Security Application: 포트&lt;/li&gt;
&lt;li&gt;Souece&lt;/li&gt;
&lt;li&gt;Destination&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;기본적으로 위 4가지 정보를 등록해야 합니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;그림 34. Security Rule 등록 폼
&lt;img src=&#34;http://taewan.kim/images/oracloud/iaas_quick/step360.jpg&#34; alt=&#34;&#34; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ssh을 위한 Security Rule은 [그림 35]와 같이 입력합니다.
source의 public-internet은 모든 IP를 의미(0.0.0.0)합니다.
Destination에 설정한 default는 VM 인스턴스 생성시 할당한 값입니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;그림 35. ssh 서비스 오픈을 위한 설정
&lt;img src=&#34;http://taewan.kim/images/oracloud/iaas_quick/step370.jpg&#34; alt=&#34;&#34; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;[그림 35]에서 &lt;code&gt;Create&lt;/code&gt; 버튼을 클릭하면, [그림 36]에서 Security Rule이 생성된 것을 확인 할 수 있습니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;그림 36. Security Rule 생성
&lt;img src=&#34;http://taewan.kim/images/oracloud/iaas_quick/step380.jpg&#34; alt=&#34;&#34; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;step05-vm-로그인-및-nginx-설치:7a6448865fd6548e9403a0ce293d8c64&#34;&gt;Step05: VM 로그인 및 nginx 설치&lt;/h3&gt;

&lt;p&gt;사용자 컴퓨터에서 [그림 37]과 [그림 38] 같이 다음 명령으로 앞에서 생성한 VM 인스턴스에 로그인 할 수 있습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;ssh ubuntu@129.144.152.137
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;그림 37. Ubuntu 로그인
&lt;img src=&#34;http://taewan.kim/images/oracloud/iaas_quick/step390.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;그림 38. Ubuntu 로그인 결과
&lt;img src=&#34;http://taewan.kim/images/oracloud/iaas_quick/step400.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ubuntu에 nginx를 설치하기 위해서는 [그림 37]과 [그림 38]과 같은 명령을 입력해야 합니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo apt-get updates
sudo apt-get install -y nginx
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;그림 39. apt 레파지토리 업데이트
&lt;img src=&#34;http://taewan.kim/images/oracloud/iaas_quick/step440.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;그림 40. nginx 설치
&lt;img src=&#34;http://taewan.kim/images/oracloud/iaas_quick/step460.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;nginx가 설치가 완료되면, [그림 41]과 같은 명령으로 nginx 서비스 상태를 확인할 수 있습니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;그림 41. nginx 서비스 상태 확인
&lt;img src=&#34;http://taewan.kim/images/oracloud/iaas_quick/step470.jpg&#34; alt=&#34;&#34; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;step06-security-등록-for-80포트-및-브라우저:7a6448865fd6548e9403a0ce293d8c64&#34;&gt;Step06: Security 등록 (for 80포트) 및 브라우저&lt;/h3&gt;

&lt;p&gt;nginx의 서비스를 브라우저로 접근하기 위해서는 추가적인 80포트 보안 설정이 필요합니다.
80 포트에 유입되는 모든 요청을 처리하기 위해서는 새로운 Security Rule을 [그림 42]와
[그림 43]과 같이 생성해야 합니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;그림 42. 80 포트 오픈을 위한 Security Rule 생성 요청
&lt;img src=&#34;http://taewan.kim/images/oracloud/iaas_quick/step480.jpg&#34; alt=&#34;&#34; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;TCP/80 포트의 경우 Security Application에 이미 만들어져 있습니다.
따라서 새로 만들 필요 없이 [그림 43]과 같이 Security Application에 http를 선택하면 됩니다.
또한 인터넷으로 부터 들어오는 모든 요청을 받아들이기 위해서 source에
public-internet을 선택하고 &lt;code&gt;Create&lt;/code&gt; 버튼을 클릭합니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;그림 43. 80 포트 오픈을 위한 Security Rule 생성
&lt;img src=&#34;http://taewan.kim/images/oracloud/iaas_quick/step490.jpg&#34; alt=&#34;&#34; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Security Rule이 정상적으로 생성될 경우 [그림 44]와 같이 Security Rules 목록을 확인할 수 있습니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;그림 44. Security Rules 목록을 확인
&lt;img src=&#34;http://taewan.kim/images/oracloud/iaas_quick/step500.jpg&#34; alt=&#34;&#34; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Security Rules가 등록되면 바로 [그림 45]와 같이 브라우저 접근이 가능합니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;그림 45. 브라우저 접근
&lt;img src=&#34;http://taewan.kim/images/oracloud/iaas_quick/step510.jpg&#34; alt=&#34;&#34; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;step07-vm-인스턴스-정지:7a6448865fd6548e9403a0ce293d8c64&#34;&gt;Step07: VM 인스턴스 정지&lt;/h3&gt;

&lt;p&gt;OPC에 생성된 VM 인스턴스는 Orchestrations 텝에서 시작과 종료를 할 수 있습니다.
현재 인스턴스가 동작하는 상태는 [그림 46]과 같습니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;그림 46. 인스턴스 구동시 Orchestration 상태 조회
&lt;img src=&#34;http://taewan.kim/images/oracloud/iaas_quick/step520.jpg&#34; alt=&#34;&#34; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;인스턴스를 종료하기 위해서는 [그림 48]과 같이 master orchestration의 메뉴 아이콘을 클릭하고 stop을 클릭하면 됩니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;그림 48. 인스턴스 셧다운을 위한 Master 종료 명령
&lt;img src=&#34;http://taewan.kim/images/oracloud/iaas_quick/step530.jpg&#34; alt=&#34;&#34; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;현재 인스턴스는 디폴트 스토리지를 사용하기 때문에 인스턴스 종료시 데이터가 유실될 수 있습니다.
인스턴스 종료시 데이터 유실을 방지하기 위해서는 별도의 스토리지를 생성하고 설정해야 합니다.
이 부분은 별도의 문서로 다루겠습니다.&lt;/p&gt;

&lt;p&gt;현재 인스턴스를 종료하면 [그림 49]와 같이 데이터 유실에 관한 에러 메세지가 출력됩니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;그림 49. 인스턴스 종료 시 데이터 유실 경고 메세지
&lt;img src=&#34;http://taewan.kim/images/oracloud/iaas_quick/step540.jpg&#34; alt=&#34;&#34; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;[그림 49]에서 &amp;ldquo;YES&amp;rdquo;를 클릭하면 Master Orchestration이 시작하며 [그림 50] 과 같이 종료된 것을 확인할 수있습니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;그림 50. 인스턴스 종료하는 Orchestration 프로세스 종료
&lt;img src=&#34;http://taewan.kim/images/oracloud/iaas_quick/step550.jpg&#34; alt=&#34;&#34; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Orchestration이 종료디면 Instances탭의 인스턴스 정보에서 Public IP가 사라진 것을 확인할 수 있습니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;그림 51. Instance 텝에서 VM 종료 상태 확인
&lt;img src=&#34;http://taewan.kim/images/oracloud/iaas_quick/step560.jpg&#34; alt=&#34;&#34; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;종료된 인스턴스를 다시 시작하기 위해서는  Orchestrations 텝에서 master orchestration의 메뉴 아이콘을 클릭하고 start를 클릭하면 됩니다.&lt;/p&gt;

&lt;h2 id=&#34;마치며:7a6448865fd6548e9403a0ce293d8c64&#34;&gt;마치며&lt;/h2&gt;

&lt;p&gt;지금까지 OPC에서 Ubuntu이미지를 이용하여 VM 인스턴스를 생성하고, ssh 보안설정, 소프트웨어 설치, 80포트 보안 설정, 인스턴스 종료와 시작에 대해서 알아 보았습니다.&lt;/p&gt;

&lt;p&gt;다음 문서에서는 스토리지 및 보안 관련된 사항을 다루도록 하겠습니다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>오라클 클라우드 계정 생성하기</title>
      <link>http://taewan.kim/blog/2016/10/06/account_reg_of_oracloud/</link>
      <pubDate>Thu, 06 Oct 2016 14:26:30 +0900</pubDate>
      
      <guid>http://taewan.kim/blog/2016/10/06/account_reg_of_oracloud/</guid>
      <description>

&lt;p&gt;오라클 클라우드에는 무료로 오라클 클라우드를 경험할 수 할 수 있는 Free Trial Account를 제공하고 있습니다. 이 계정을 이용하여 Oracle Database Cloud Service(이하 CS), Java CS, Compute CS, Developer CS, Database Backup CS, Storage CS, Application Container CS, SOA CS를 사용할 수 있습니다. 본 문에서는 Oracle Cloud의 NewBOracle Cloud의 계정을 생성하는 방법에 대하여 살펴보겠습니다. Oracle Cloud의 무료 계정은 최대 2개월까지 사용할 수 있습니다.&lt;/p&gt;

&lt;h2 id=&#34;oracle-cloud-계정-등록-절차:fb2c96cdd3503b1324552b3e2a30e2e9&#34;&gt;Oracle Cloud 계정 등록 절차&lt;/h2&gt;

&lt;p&gt;오라클 클라우드의 계정 등록 절차는 다음과 같습니다.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Oracle Cloud 사이트 방문&lt;/li&gt;
&lt;li&gt;Free Trial 메뉴 클릭&lt;/li&gt;
&lt;li&gt;로그인 페이지 이동 - &amp;ldquo;계정 생성&amp;rdquo; 클릭&lt;/li&gt;
&lt;li&gt;Oracle Account 생성&lt;/li&gt;
&lt;li&gt;등록 메일에 대한 확인 메일 수신&lt;/li&gt;
&lt;li&gt;Oracle Cloud 로그인 및 추가 정보 등록&lt;/li&gt;
&lt;li&gt;전화 SMS 인증&lt;/li&gt;
&lt;li&gt;계정 등록 완료&lt;/li&gt;
&lt;li&gt;계정 등록 최종 완료 메일 수신&lt;/li&gt;
&lt;li&gt;Oracle Cloud 로그인&lt;/li&gt;
&lt;li&gt;Oracle Cloud 패스워드 변경&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;오라클 클라우드 계정 생성 절차에 대해서는 다음 절에세 &amp;ldquo;Step by Step&amp;rdquo;으로 설명하겠습니다.&lt;/p&gt;

&lt;h2 id=&#34;오라클-클라우드-계정-신청-절차:fb2c96cdd3503b1324552b3e2a30e2e9&#34;&gt;오라클 클라우드 계정 신청 절차&lt;/h2&gt;

&lt;p&gt;오라클 클라우드의 홈페이지는 &lt;a href=&#34;http://cloud.oracle.com&#34;&gt;http://cloud.oracle.com&lt;/a&gt; 입니다.&lt;/p&gt;

&lt;p&gt;아래 그림 1과 같이 오라클 클라우드 홈페이지에서 &amp;ldquo;Free Trial&amp;rdquo;을 클릭하여 계정 신청을 시작할 수 있습니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;그림 1. 오라클 클라우드 홈페이지
&lt;img src=&#34;http://taewan.kim/images/oracloud/account/step01.jpg&#34; alt=&#34;&#34; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;그림 2와 같이 &amp;ldquo;Try it&amp;rdquo;링크를 클릭하여 계정 등록 절차를 시작할 수 있습니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;그림 2. 계정 등록 시작
&lt;img src=&#34;http://taewan.kim/images/oracloud/account/step02.jpg&#34; alt=&#34;&#34; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;오라클 클라우드 계정을 만들기 위해서는 Oracle Technology Networks의 계정이 필요합니다.
기존에 OTN 계정이 있다면 그림 3의 로그인 페이지에서 로그인하고 Oracle Cloud 계정 생성을 진행합니다.
기존에 OTN 계정이 없다면 로그인 페이지의 오른쪽 하단에 위치한 &amp;ldquo;Create Account&amp;rdquo; 버튼을 클릭하여 OTN 계정 생성 작업을 진행합니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;그림 3. 오라클 클라우드 로그인 페이지
&lt;img src=&#34;http://taewan.kim/images/oracloud/account/step03.jpg&#34; alt=&#34;&#34; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;오라클 클라우드 계정 생성 중 이메일 인증과 핸드폰 인증 단계가 있습니다.
따라서 OTN 계정 등록 단계에 입력하는 이메일과 핸드폰 정보는 그림4와 같이 정확하게 입력해야 합니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;그림 4. OTN 계정 등록 페이지
&lt;img src=&#34;http://taewan.kim/images/oracloud/account/step04.jpg&#34; alt=&#34;&#34; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;그림 4의 단계를 완료하면 그림 5와 같이 OTN 계정 생성이 완료됩니다. 계정 생성이 완료될 경우 계정 활성화를 위해서,
계정 등록 시에 입력한 메일로 메일 검증용 메일이 발송됩니다. 메일 발송시 까지 약 2-3분 정도 소요됩니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;그림 5. OTN 계정 생성 페이지
&lt;img src=&#34;http://taewan.kim/images/oracloud/account/step05.jpg&#34; alt=&#34;&#34; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;그림 6과 같이 계정 등록시 입력한 메일 정보를 점증하기 위한 메일이 오라클로 부터 발송됩니다.
메일의 &amp;ldquo;Verify Email Address&amp;rdquo;를 클립하면 그림 6과 같은 페이지가 오픈되며 OTN 계정 생성 절차가 완료됩니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;그림 6. 등록 E-mail 검증 메일
&lt;img src=&#34;http://taewan.kim/images/oracloud/account/step06.jpg&#34; alt=&#34;&#34; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;그림 7은 OTN 계정 등록 완료 페이지 입니다. 이 페이지에서 &amp;ldquo;계속&amp;rdquo; 버튼을 클릭하면 Oracle Cloud 계정 생성을 위한 다음 절차로 넘어 갑니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;그림 7. OTN 계정 등록 완료 페이지
&lt;img src=&#34;http://taewan.kim/images/oracloud/account/step07.jpg&#34; alt=&#34;&#34; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;그림 8과 같이 오라클 클라우드 계정에 필요한 추가적인 정보를 입력하는 페이지로 이동합니다. 이 페이지에는 계정 생성시 입력한
전화번호를 SMS로 점증 절차를 포함합니다. &amp;ldquo;Request Code&amp;rdquo; 버튼을 클릭하면 문자가 발송됩니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;그림 8. OTN 계정 등록 완료 페이지
&lt;img src=&#34;http://taewan.kim/images/oracloud/account/step08.jpg&#34; alt=&#34;&#34; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;그림 9와 같은 SMS가 수신됩니다. 메세지에 포함된 6자리 숫자를 그림 10와 같이 입력합니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;그림 9. 오라클 클라우드 계정에 필요한 추가 정보 입력 페이지
&lt;img src=&#34;http://taewan.kim/images/oracloud/account/step09.jpg&#34; alt=&#34;&#34; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;SMS로 전단된 인증 번호화 추가 정보를 입력하여 계정 정보 입력&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;그림 10. 오라클 클라우드 정보입력 완료
&lt;img src=&#34;http://taewan.kim/images/oracloud/account/step10.jpg&#34; alt=&#34;&#34; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;모든 입력 절차가 완료되면 그림 11과 같은 신청 완료 페이지로 이동합니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;그림 11. 계정 신청 완료 페이지
&lt;img src=&#34;http://taewan.kim/images/oracloud/account/step11.jpg&#34; alt=&#34;&#34; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;오라클 클라우드 계정 신청이 완료되면 오라클로 부터 최종 확인 메일을 그림 12와 같이 수신받게 됩니다.
최종 확인 메일 수신은 계정 신청 완료 후 약 1시간 정도가 소요됩니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;그림 12. 계정 등록 완료 메일
&lt;img src=&#34;http://taewan.kim/images/oracloud/account/step12.jpg&#34; alt=&#34;&#34; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;그림 12와 같은 메일을 수신하면 확인에 포함된 계정 명, 패스워드로 오라클 클라우드에 로그인할 수 있습니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;그림 13. 오라클 클라우드 로그인 페이지 이동
&lt;img src=&#34;http://taewan.kim/images/oracloud/account/step13.jpg&#34; alt=&#34;&#34; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;오라클 클라우드에 로그인 하기 위해서 그림 14와 같이 &amp;ldquo;Public Cloud Service - US&amp;rdquo;를 선택합니다.
Trial Account는 현재 US서버로 고정되어 있습니다.
&amp;ldquo;My Services&amp;rdquo; 버튼을 클릭합니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;그림 14. 데이터 센터 선택
&lt;img src=&#34;http://taewan.kim/images/oracloud/account/step14.jpg&#34; alt=&#34;&#34; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;로그인 하시 위해서는 &amp;ldquo;Identity Domain&amp;rdquo;을 먼저 입력해야 합니다. 이 정보는 최종 계정 확인 메일에서 확인할 수 있습니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;그림 15. 도메인 입력
&lt;img src=&#34;http://taewan.kim/images/oracloud/account/step15.jpg&#34; alt=&#34;&#34; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;최종 계정 확인 메일에 포함된 id/password 정보를 입력합니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;그림 16. ID/Password입력
&lt;img src=&#34;http://taewan.kim/images/oracloud/account/step16.jpg&#34; alt=&#34;&#34; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;최초 로그인시 시스템에서 생성한 기본 패스워드를 변경하도록 되어 있습니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;그림 17. 패스워드 변경
&lt;img src=&#34;http://taewan.kim/images/oracloud/account/step17.jpg&#34; alt=&#34;&#34; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;패스워드를 변경하면 그림 18과 같이 환영 페이지가 출력됩니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;그림 18. 환영 페이지
&lt;img src=&#34;http://taewan.kim/images/oracloud/account/step18.jpg&#34; alt=&#34;&#34; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;환영 페이지를 종료하면 그림 19와 같이 오라클 클라우드의 Dashborad 페이지를 확인 할 수 있습니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;그림 19. Dashborad 페이지
&lt;img src=&#34;http://taewan.kim/images/oracloud/account/step19.jpg&#34; alt=&#34;&#34; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;지금까지 오라클 클라우드 계정 생성 절차를 살펴 보았습니다.
전체적으로 계정 생성은 인증 및 점증 절차까지 포함하여 약 1시간 정도 소요됩니다.&lt;/p&gt;

&lt;p&gt;현재 Trial Account로 다음과 같은 서비스에 접근할 수 있습니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Oracle Database Cloud Service(이하 CS)&lt;/li&gt;
&lt;li&gt;Java CS&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Compute CS&lt;/li&gt;
&lt;li&gt;Developer CS&lt;/li&gt;
&lt;li&gt;Database Backup CS&lt;/li&gt;
&lt;li&gt;Storage CS&lt;/li&gt;
&lt;li&gt;Application Container CS&lt;/li&gt;
&lt;li&gt;SOA CS&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;다음 포스트에서는 각 서비스에 대한 생성 및 사용법에 대하여 알아보겠습니다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>네크워크 클래스 별 Private IP의 대역입니다.</title>
      <link>http://taewan.kim/blog/2016/05/07/private_ip/</link>
      <pubDate>Sat, 07 May 2016 17:41:46 +0900</pubDate>
      
      <guid>http://taewan.kim/blog/2016/05/07/private_ip/</guid>
      <description>&lt;p&gt;암기용 요약입니다. 네트워크 클래스별 Private IP의 대역입니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;A 클래스 : 10.0.0.0 ~ 10.255.255.255&lt;/li&gt;
&lt;li&gt;B 클래스 : 172.16.0.0 ~ 172.31.255.255&lt;/li&gt;
&lt;li&gt;C 클래스 : 192.168.0.0 ~ 192.168.255.255&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;RUN apt-get install -y libX11-6&lt;/p&gt;

&lt;p&gt;USER jovyan
RUN pip install matplotlib&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Scala for the Impatient: ch02. Control Structures and Functions</title>
      <link>http://taewan.kim/documents/scala4impatient/ch02.html</link>
      <pubDate>Wed, 13 Apr 2016 19:24:30 +0900</pubDate>
      
      <guid>http://taewan.kim/documents/scala4impatient/ch02.html</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;최종 업데이트: 2016.04.13&lt;/li&gt;
&lt;li&gt;돌아가기: &lt;a href=&#34;http://taewan.kim/documents/scala4theimpatient.html&#34;&gt;Index&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h1 id=&#34;ch02-control-structures-and-functions:a5386c4b4d4ac3b60f9b614e360f10df&#34;&gt;ch02. Control Structures and Functions&lt;/h1&gt;

&lt;h2 id=&#34;주요-내용-정리:a5386c4b4d4ac3b60f9b614e360f10df&#34;&gt;주요 내용 정리&lt;/h2&gt;

&lt;h3 id=&#34;2-1-조건식:a5386c4b4d4ac3b60f9b614e360f10df&#34;&gt;2.1 조건식&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;조건식은 값을 반환.&lt;/li&gt;
&lt;li&gt;val 변수 초기화에 활용 가능&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;val s = if(x&amp;gt;0) 1 else -1
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;else절이 없을 경우 Unit을 반환&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;if(x&amp;gt;0) 1 else ()
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;2-3-블록식:a5386c4b4d4ac3b60f9b614e360f10df&#34;&gt;2.3 블록식&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;한줄에 여려 식을 기술해야 할 때 사용&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;val distance = {val dx=x-x0;val dy=y-y0;sqrt(dx*dx+dy*dt)}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;할당문으로 끝나는 블록식은 Unit을 반환&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;scala&amp;gt; val result = {val a = 3}
result: Unit = ()

scala&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;2-4-입력과-출력:a5386c4b4d4ac3b60f9b614e360f10df&#34;&gt;2.4 입력과 출력&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;printf(&amp;quot;Hello, %s!, you are %d years old.&amp;quot;, &amp;quot;minsu&amp;quot;, 3)
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;import scala.math._&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;import 문에서 scala로 시작하는 패키지는 scala 생략 가능

&lt;ul&gt;
&lt;li&gt;다음 import는 동일한 결과&lt;/li&gt;
&lt;li&gt;&lt;code&gt;import scala.math._&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;import math._&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;static 메서드가 없음

&lt;ul&gt;
&lt;li&gt;Companion Object에 자바이 static 메서드 정의 가능&lt;/li&gt;
&lt;li&gt;인자가 없는 스칼라 메서드는 일반적으로 괄호를 사용하지 않는다.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;apply 메서드

&lt;ul&gt;
&lt;li&gt;apply메소드는 다음과 같은 상황헤서 묵시적으로 호출됨&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;quot;Hello&amp;quot;(4)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;BigInt(&amp;quot;1234567890&amp;quot;)&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;apply 메서드는 Companion Object에 정의됨&lt;/li&gt;
&lt;li&gt;new 연산자 없이 객체 생성&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;exercises:a5386c4b4d4ac3b60f9b614e360f10df&#34;&gt;Exercises&lt;/h2&gt;

&lt;h3 id=&#34;1-스칼라-repl에서-3을-입력하고-tab키를-입력할-것-어떤-메서드를-볼-수-있나:a5386c4b4d4ac3b60f9b614e360f10df&#34;&gt;1. 스칼라 REPL에서 3을 입력하고 Tab키를 입력할 것. 어떤 메서드를 볼 수 있나?&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;scala&amp;gt; 3.
%   +   &amp;gt;    &amp;gt;&amp;gt;&amp;gt;            isInstanceOf   toDouble   toLong     unary_+   |   
&amp;amp;   -   &amp;gt;=   ^              toByte         toFloat    toShort    unary_-       
*   /   &amp;gt;&amp;gt;   asInstanceOf   toChar         toInt      toString   unary_~       

scala&amp;gt; 3.
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;2-스칼라-repl에서-3의-제곱근을-계산하고-그-값을-제곱하라-결과가-3과-얼마나-차이가-나는가:a5386c4b4d4ac3b60f9b614e360f10df&#34;&gt;2. 스칼라 REPL에서 3의 제곱근을 계산하고 그 값을 제곱하라. 결과가 3과 얼마나 차이가 나는가?&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;scala&amp;gt; import math._
import math._

scala&amp;gt; sqrt(3)
res2: Double = 1.7320508075688772

scala&amp;gt; pow(res2, 2)
res3: Double = 2.9999999999999996

scala&amp;gt; 3 -  res3
res4: Double = 4.440892098500626E-16
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;3-res-변수는-val인가-var-인가:a5386c4b4d4ac3b60f9b614e360f10df&#34;&gt;3. res 변수는 val인가? var 인가?&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Answer: val&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;scala&amp;gt; 3+3
res5: Int = 6

scala&amp;gt; res5 = 7
&amp;lt;console&amp;gt;:14: error: reassignment to val
       res5 = 7
            ^
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;4-스칼라에서는-문자열을-숫자로-곱할-수-있다-crazy-3-을-repl에서-수행해-보라-이-연산은-무엇을-하나-스칼라-독-어디에서-찾을-수-있나:a5386c4b4d4ac3b60f9b614e360f10df&#34;&gt;4. 스칼라에서는 문자열을 숫자로 곱할 수 있다. &lt;code&gt;&amp;quot;crazy&amp;quot;*3&lt;/code&gt; 을 REPL에서 수행해 보라. 이 연산은 무엇을 하나? 스칼라 독 어디에서 찾을 수 있나?&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;scala&amp;gt; &amp;quot;crazy&amp;quot;*3
res0: String = crazycrazycrazy

scala&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;StringOps: &lt;a href=&#34;http://www.scala-lang.org/api/2.11.8/#scala.collection.immutable.StringOps&#34;&gt;http://www.scala-lang.org/api/2.11.8/#scala.collection.immutable.StringOps&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;def *(n: Int): String&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;5-10-max-2는-무엇을-의미하나-max-메서드는-어느-클래스에-정의되어-있나:a5386c4b4d4ac3b60f9b614e360f10df&#34;&gt;5. 10 max 2는 무엇을 의미하나? max 메서드는 어느 클래스에 정의되어 있나?&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;scala&amp;gt; 10 max 2
res7: Int = 10

scala&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.scala-lang.org/api/current/#scala.runtime.RichInt&#34;&gt;http://www.scala-lang.org/api/current/#scala.runtime.RichInt&lt;/a&gt;&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;scala.runtime.RichInt&lt;/li&gt;
&lt;li&gt;&lt;code&gt;def max(that: Int): Int&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;6-bitint를-사용하여-2-1024를-계산하시오:a5386c4b4d4ac3b60f9b614e360f10df&#34;&gt;6. BitInt를 사용하여 2^1024를 계산하시오.&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;scala&amp;gt; BigInt(2) pow 1024
res10: scala.math.BigInt = 179769313486231590772930519078902473361797697894230657273430081157732675805500963132708477322407536021120113879871393357658789768814416622492847430639474124377767893424865485276302219601246094119453082952085005768838150682342462881473913110540827237163350510684586298239947245938479716304835356329624224137216  

scala&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;7-probableprime과-random에-아무런-식별자-없이-probableprime-100-random-으로-임의의-소수를-얻으려면-어떻게-해야-하는가:a5386c4b4d4ac3b60f9b614e360f10df&#34;&gt;7. probablePrime과 Random에 아무런 식별자 없이 probablePrime(100, Random)으로 임의의 소수를 얻으려면 어떻게 해야 하는가?&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;scala&amp;gt; import BigInt._
import BigInt._

scala&amp;gt; import util._
import util._

scala&amp;gt; probablePrime(100, Random)
res0: scala.math.BigInt = 807294085848679373168091165161

scala&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;8-임의의-파일-혹은-디렉터리-이름을-생성하는-방법-중-하나는-임의의-bigint를-생성하고-있을-36진법으로-변환하여-qsnvbevtomcj38o06kul-같은-문자열을-얻는-것이다-스칼라-독을-뒤져서-방법을-찾으시오:a5386c4b4d4ac3b60f9b614e360f10df&#34;&gt;8. 임의의 파일 혹은 디렉터리 이름을 생성하는 방법 중 하나는 임의의 BigInt를 생성하고 있을 36진법으로 변환하여 &amp;ldquo;qsnvbevtomcj38o06kul&amp;rdquo; 같은 문자열을 얻는 것이다. 스칼라 독을 뒤져서 방법을 찾으시오.&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;scala&amp;gt; import BigInt._
import BigInt._

scala&amp;gt; import util._
import util._


scala&amp;gt;  probablePrime(100, Random)
res6: scala.math.BigInt = 972061358937142327172244809173

scala&amp;gt; res6.toString(36)
res8: String = 2m8qszj9v05sqltjr4d1
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;9-scala에서-문자열의-첫문자를-어떻게-얻는가-마지막-문자는-어떻게-얻는가:a5386c4b4d4ac3b60f9b614e360f10df&#34;&gt;9. scala에서 문자열의 첫문자를 어떻게 얻는가? 마지막 문자는 어떻게 얻는가?&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;scala&amp;gt; &amp;quot;meorng&amp;quot;(0)
res9: Char = m

scala&amp;gt; &amp;quot;meorng&amp;quot;.head
res10: Char = m

scala&amp;gt; &amp;quot;meorng&amp;quot;.last
res11: Char = g

scala&amp;gt; &amp;quot;meorng&amp;quot;.reverse
res12: String = gnroem

scala&amp;gt; &amp;quot;meorng&amp;quot;.reverse.head
res13: Char = g

scala&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;10-문자열의-take-drop-takeright-dropright는-무엇을-하나-substring을-사용하는-것에-비교해-장점과-단점은-무엇인가:a5386c4b4d4ac3b60f9b614e360f10df&#34;&gt;10. 문자열의 take, drop, takeRight, dropRight는 무엇을 하나? subString을 사용하는 것에 비교해 장점과 단점은 무엇인가?&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;scala&amp;gt; &amp;quot;merong&amp;quot; take 3
res16: String = mer

scala&amp;gt; &amp;quot;merong&amp;quot; drop 3
res17: String = ong

scala&amp;gt; &amp;quot;merong&amp;quot; takeRight 3
res18: String = ong

scala&amp;gt; &amp;quot;merong&amp;quot; dropRight 3
res19: String = mer
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;ul&gt;
&lt;li&gt;돌아가기: &lt;a href=&#34;http://taewan.kim/documents/scala4theimpatient.html&#34;&gt;Index&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>[막번역] Apache Kafka 0.9.0 Documentation</title>
      <link>http://taewan.kim/documents/translation/kafka_official_doc.html</link>
      <pubDate>Tue, 12 Apr 2016 14:56:13 +0900</pubDate>
      
      <guid>http://taewan.kim/documents/translation/kafka_official_doc.html</guid>
      <description>

&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;출처: &lt;a href=&#34;http://kafka.apache.org/documentation.html#introduction&#34;&gt;http://kafka.apache.org/documentation.html#introduction&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;버전: 0.90&lt;/li&gt;
&lt;li&gt;최종 업데이티:2016.04.06&lt;/li&gt;
&lt;li&gt;친척률: 5%&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;1-시작:50433a3ec3aee35119c9d3a0f7503755&#34;&gt;1. 시작&lt;/h1&gt;

&lt;h2 id=&#34;1-1-소개:50433a3ec3aee35119c9d3a0f7503755&#34;&gt;1.1 소개&lt;/h2&gt;

&lt;p&gt;Kafka는 커밋 로그 서비스로 분산, 파티션, 복제의 특징을 갖는다. Kafka는 메세징 시스템 기능을 제공하며, 아주 특이한 디자인을 포함합니다.&lt;/p&gt;

&lt;p&gt;이것이 무슨 의미일까요?&lt;/p&gt;

&lt;p&gt;우선 몇 가지 기본 메세징 용어를 살펴보겠습니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Topic: Kafka는 토픽이라고 불리는 메세지 저장소를 유지한다.&lt;/li&gt;
&lt;li&gt;Producer: Kafka 토픽에 메세지를 발행(저장)하는 프로세스&lt;/li&gt;
&lt;li&gt;Consumer: 토픽을 구독하고 발행된 메세지를 소비하는 프로세스&lt;/li&gt;
&lt;li&gt;Broker: Kafka는 하나 혹은 다수의 서버로 구성된 클러스터로 동작함. 클러스터를 구성하는 서버를 Broker라고 함&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Producer는 네트웍을 통해서 Kafka 클러스터에 메세지를 전달한다. Kafka 클러스터는 다시 메세지를 Consumer에 다음과 같이 전달됩니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://kafka.apache.org/images/producer_consumer.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;클라이언트와 서버사이의 통신은 단순한 고성능 TCP 프로토콜을 이용합니다. 이 TCP 프로토콜은 언어 중립적입니다. Apache Kafka는 Kafka 자바 클라이어트를 제공합니다. 그러나 다수의 언어에서 이용 가능한 클라이언트를 이용 가능합니다.  &lt;a href=&#34;https://cwiki.apache.org/confluence/display/KAFKA/Clients&#34;&gt;https://cwiki.apache.org/confluence/display/KAFKA/Clients&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;토픽과-로그:50433a3ec3aee35119c9d3a0f7503755&#34;&gt;토픽과 로그&lt;/h3&gt;

&lt;p&gt;토픽은 발행된 메세지의 카테고리명 혹은 피드명입니다. 각 토픽에 Kafka 클러스터는 분할된 로그를 다음과 같이 저장합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://kafka.apache.org/images/log_anatomy.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;각 파티션은 순차적이며 불변의 메세지를 저장하는 연속체(시퀀스)로 지속적으로 커밋 로그가 추가됩니다. 이 파티션의 메세지에는 개별적으로 순차적으로 증가하는 id (숫자)가 할당됩니다. 이 id를 &amp;ldquo;offset&amp;rdquo;이라고 하며 파티션에서 각 메세지를 유일하게 식별합니다.&lt;/p&gt;

&lt;p&gt;Kafka 클러스터는 모든 발행된 메세지를 설정된 기간동안 보관 합니다. 메세지의 소비 여부는 보관 결정에 관여하지 않습니다. 예를 들어서 log retaintion(로그 보관 주기 &lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:50433a3ec3aee35119c9d3a0f7503755:log-retaintion&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:50433a3ec3aee35119c9d3a0f7503755:log-retaintion&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;)이 2일로 설정되었다면 메세지가 발행된 후 이틀동안 해당 메세지는 소비될 수 있습니다. 그리고 이틀 후에는 저장 공간 확보를 위해서 폐기됩니다. Kafka 성능은 데이터 사이즈에 큰 영햐을 받지 않고 일정하게 유지됩니다. 따라서 많은 데이터를 보관하는 것이 문제가 되지는 않습니다.&lt;/p&gt;

&lt;p&gt;consumer에서 관리되는 유일한 메타데이터는 로그에서의 Consumer의 위치 다시 말해 offset 입니다. 이 offset은 consumer가 관리합니다. 일반적으로 Consumer는 메세지를 읽을때 마다 자신의 offset을 선형적으로 증가시킵니다. 그러나 이 위치 정보는  Consumer가 관리 합니다. 그리고 원하는 순서대로 메세지를 읽어갈 수 있습니다. 예를 들어서 Consumer는 데이터 재처리를 위해서 오래된 offset으로 재설정할 수 있습니다.&lt;/p&gt;

&lt;p&gt;이러한 특징들로 인하여 Kafka Consumer는 매우 저렴한 비용으로 관리 가능합니다. 또한 클러스터 혹은 다른 Consumer에 큰 영향을 미치지 않고 앞/뒤로 이동할 수 있습니다. 예를 들어서 기존 consumer가 어디까지 소비되었는지를 고려할 필요 없이, 모든 토픽의 내용을 &amp;ldquo;tail&amp;rdquo;하는 명령어를 사용할 수 있습니다. (역자주: 기존 Message Queue 방식에서는 불가능했던 오퍼레이션입니다. )&lt;/p&gt;

&lt;p&gt;로그를 파티셔닝하는 것은 몇 가지 의도가 있습니다. 첫 번째, 파티셔닝을 통해서 로그를 확장 할 수 있습니다. 이러한 확장은 단일 서버의 규모를 넘어선 확장이 가능하게 합니다. 각 개별적인 파티션은 구동하는 호스트에 적합해야 합니다. 하나의 Topic은 여러개의 파티션을 갖을 수 있고 결고적으로 대규모 데이터를 처리할 수 있습니다. 두 번째는 파티션은 어느정도 병렬처리의 단위로써 작동합니다.&lt;/p&gt;

&lt;h3 id=&#34;distribution:50433a3ec3aee35119c9d3a0f7503755&#34;&gt;Distribution&lt;/h3&gt;

&lt;p&gt;로그 파티션은 kafka 클러스터의 여러 서버에 분산되어 있습니다. 클러스터의 각 서버는 데이터 처리하며 파티션의 공유를 요청합니다. 파티션은 설정된 수 만큼의 서버에 복제하여 장애 극복(Fault Tolerance)을 지원합니다.&lt;/p&gt;

&lt;p&gt;각 파티션은 리더로써 동작하는 하나의 서버를 갖고 0개 혹은 그 아상 서버는 &amp;ldquo;follower&amp;rdquo;로 동작합니다. 리더는 파티션의 모든 읽기와 쓰기 요청을 처리합니다. 동시에 follower는 리더를 복제합니다. 리더에 장애가 발생하면 follower 중에 하나가 새로운 리더가 되며 이러한 처리는 자동화 되어 있습니다. 새로 선출된 그 리더는 해당 파티션에 대한 모든 읽기와 쓰기 요청을 처리합니다. 각 서버는 자신의 파티션의 일부에 대해서는 리더로 동작하고, 나머지 일부에 대해서는 follower로 동작합니다. 클러스터 내부에서 부하는 귱형을 맞추게 됩니다.&lt;/p&gt;

&lt;h3 id=&#34;producers:50433a3ec3aee35119c9d3a0f7503755&#34;&gt;Producers&lt;/h3&gt;

&lt;p&gt;Producer는 데이터를 자신이 선택한 토픽에 발행합니다. Producer는어떤 메세지를 토픽의 어떤 파티션에 저장할지를 결정하는 것을 전담합니다. 이러한 것은 부하를 분산하기 위해서 단순히 Round-robin 방식으로 동작되기도 하고 몇 가지 시멘틱 파티션 기능(메세지으 어떤 키를 기준으로 결정하는 바식)으로 동적합니다. 파티션을 사용에 관해서는 잠시후에 다루도록 하겠습니다.&lt;/p&gt;

&lt;h3 id=&#34;consumers:50433a3ec3aee35119c9d3a0f7503755&#34;&gt;Consumers&lt;/h3&gt;

&lt;p&gt;전통적인 메세징에서는 Queue와 Publish-subscribe 두 가지 모델있습니다. Queue 모델에서는 일련의 Consumer들로 풀(pool)을 구성하고 서버로 부터 메세지를 읽어습니다. 각 메세지는 consumer 풀중에 하나로 이동하게 됩니다. Publish-subscribe모델에서는 메세지는 모든 Consumer에 전달됩니다 (Broadcast). Kafka는 이 두가지 모델을 일반화한 하나의 consumer 모델인 &amp;ldquo;consumer group&amp;rdquo;을 제공합니다.&lt;/p&gt;

&lt;p&gt;Consumer는 Consumer 그룹 명으로 스스로를 분류합니다. Topic에 발행된 각 메세지는 각 구독 consumer 그룹의 1개 consumer 인스턴스에 전달됩니다. Consumer 인스턴스는 독립된 프로세스이거나 별도의 서버에 위치 할 수 있습니다.&lt;/p&gt;

&lt;p&gt;모든 consumer 인스턴스가 동일한 consumer 그룹을 갖는 상황이라면, 이러한 방식으로 작동하는 것은 전통적인 Queue 환경에서 여러 consumer에 부하를 분산하는 것과 유사하게 보입니다.&lt;/p&gt;

&lt;p&gt;반대로 모든 consumer 인스턴스가 모두 다른 consumer 그룹을 갖는다면, 이러한 구성은 publish-subscribe 모델과 같이 동작합니다. 모든 메세지는 모든 consumer에 전달됩니다 (Broadcast)&lt;/p&gt;

&lt;p&gt;일반적으로 Topic은 몇개의 consumer 그룹을 갖습니다. 각 그룹은 논리적인 구독자(subscriber)입니다. 각 그룹은 확장성과 장애 극복(Fault tolerance)을 위하여 복수의 consumer 인스턴스로 구성됩니다. 사실 이러한 구성은 구독자가 하나의 프로셋가 아닌 consumer 클러스터 형태인 publish-subscribe 시멘틱 구성과 같은 것 입니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&#34;http://kafka.apache.org/images/consumer-groups.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;그림 설명: 두 개의 kafka 클러스터는 4개의 파티셔닝(P0-P3)을 갖고 있으며, 2개의 consumer 그룹으로 구성되어 있습니다. Consumer 그룹 A는 두 개의 인스턴스를 갖고있고, Consumer 그룹 B는 4개의 consumer 인스턴스로 구성됩니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Kafka는 전통적인 메세징 시스템보다 더 강력하게 순서를 보장합니다.&lt;/p&gt;

&lt;p&gt;전통적인 Queue는 서버에 순서대로 메세지를 보관합니다. 복수의 consumer가 queue로 부터 메세지를 요청하면 서버는 메세지가 저장된 순서대로 consumer에 분해합니다. 그러나 서버가 순서대로 메세지를 Consumer에 분배하기는 했지만, 메세지는 consumer에 비동기적으로 전달됩니다. 따라서 메세지는 다른 consumer에 순서가 바뀌여 도착할 수 있습니다. 이는 사실상 메세지의 순서는 병렬처리에서는 무의미해 진다는 것을 의미합니다. 메세징 시스템은 종종 &amp;ldquo;배타적 Consumer(exclusive consumer)&amp;ldquo;의 개념으로 이러한 문제를 우회하기도 합니다. 배타적 consumer란 오직 queue로 부터 메세지를 소비하는 하나의 프로세스만을 허용하는 개념입니다. 그러나 이 방법은 병령 처리의 개념이 존재하지 않는 극단적인 편법입니다.&lt;/p&gt;

&lt;p&gt;Kafka는 이 방법보다 개선된 방식을 제공합니다. 토픽내에 병렬 파티션 개념을 사용합니다. Kafka는 순서를 보장하면서 consumer 프로세스 풀에 부하를 분산시킬 수 있습니다. 이는 토픽의 파티션에 consumer 그룹의 consumer를 할당하여 완성됩니다. 이러한 구성을 통해서 consumer는 파티션의 유일한 리더되고 순서대로 데이터를 소비하게 됩니다. 많은 파티션이 존재하기 때문에 다수의 consumer 인스턴스로 부하술 분산하게 됩니다. 주의할 점은  consumer 그룹의  consumer 인스턴스의 갯수는 파티션 보다 많을 수 없습니다.&lt;/p&gt;

&lt;p&gt;Kafka는 하나의 파티션내에서 메세지의 순서를 보장합니다. 토픽의 다른 파티션 사이에서는 순서를 보장하지 않습니다. 파티션 내에서 순서와 키를 기준으로한 파티션 데이터에 기능을 결합한다면 대부분 애플리케이션에 충족할 것 입니다. 그러나 메세지에 대한 전체 순서를 보장해야 하는 상황이라면 kafka를 하나 파티션만을 갖는 topic으로 구현할 수 있습니다. 물론 이 방식은 하나의 consumer 인스턴스만을 갖는 consumer 그룹을 사용해야 한다는 것을 의미합니다.&lt;/p&gt;

&lt;h3 id=&#34;kafaka가-보장하는-것:50433a3ec3aee35119c9d3a0f7503755&#34;&gt;Kafaka가 보장하는 것&lt;/h3&gt;

&lt;p&gt;Kafka는 다음과 같은 내용을 보자합니다.
- Producer가 특정 토픽 파티션에 전달한 메세지는 메세지가 전달된 순서대로 보일 것입니다. 즉 메세지 M1과 M2가 동일한 Proucer가 제출한 메세지이고 M1이 먼저 제출된 것이라면, M1에게는 M2보나 작은 offset이 할당되고 로그에서 앞에 위치하게 됩니다.
- consumer 인스턴스는 메세지가 로그에 저장된 순서대로 메세지가 보입니다.
- 복제 계수 N인 Topic에서 N-1개 서버 장애까지 로그에 저장된 메세지의 손실 없이 장애 극복 가능합니다.&lt;/p&gt;

&lt;p&gt;Kafka가 보장하는 더 자세한 내용은 이 문서의 디자인 섹션에서 다루겠습니다.&lt;/p&gt;

&lt;h2 id=&#34;1-2-use-cases:50433a3ec3aee35119c9d3a0f7503755&#34;&gt;1.2 Use Cases&lt;/h2&gt;

&lt;p&gt;이 절에서는 아파치 Kafka의 유명한 사용 사례를 설명합니다. 추가적인 설명은 다음 블러그를 참조하시기 바랍니다. &lt;a href=&#34;http://engineering.linkedin.com/distributed-systems/log-what-every-software-engineer-should-know-about-real-time-datas-unifying&#34;&gt;Linkedin  Technical Blog&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;messaging:50433a3ec3aee35119c9d3a0f7503755&#34;&gt;Messaging&lt;/h3&gt;

&lt;p&gt;Kafka는 다수의 전통적인 메세지 브로커를 대체하고 있습니다. Message Broker가 사용되는 이유는 다양합니다 (데이터 Producer로 부터 프로세스을 이원화고 처리되지 않은 메시지를 버퍼합니다.) 대부분의 메세지 시스템과 비교해 볼 때, Kafka는 더 좋은 처리량을 제공합니다. 또한 내장 파티션, 복제 그리고 장애 극복을 더 잘 제공합니다. Kafka는 대규모 확장 메세지 처리 애플리케이션에 적합한 솔루션입니다.&lt;/p&gt;

&lt;p&gt;경험적으로 메세징 사용은 종종 상태적으로 낮은 처리량을 보인다. 그러나 낮은 대기 지연을 요구할 수 도 있다. 그리고 종종 Kafka가 제공하는 강력한 영속성 ㅂ장에 의존하기도 한다.&lt;/p&gt;

&lt;p&gt;이 도메인에서 Kafka는 전통적인 메세징 시스템 (ActiveMQ와 RobbitMQ)와 비교할 수 있습니다.&lt;/p&gt;

&lt;h3 id=&#34;website-activity-tracking:50433a3ec3aee35119c9d3a0f7503755&#34;&gt;Website Activity Tracking&lt;/h3&gt;

&lt;p&gt;Kafka는 본래 실시간 publish-subscrive으로써 사용자 액티비티를 투적하는 파이프라인을 재구축할 수 있도록 하는 것 입니다. 이것은 사용자 액티비티(페이지뷰, 검색 혹은 다른 사용자가 취하는 움직임)를 액티비티 유형 별로 할당된 Topic를 갖는 중앙  Topic에 메세지를 발해하는 것을 의미합니다. 이러한 메세지 전달 방식은 실시간 프로세싱, 실시간 모니터링 그리고 하둡과 오프라인 데이터 웹어하우스 시스템으로 데이터 로딩하여 오프라인 프로세싱과 리포팅을 포함하는 다양한 범위에 응용할 수 있습니다.&lt;/p&gt;

&lt;p&gt;사용자 페이지 뷰를 위한 다수의 액티비티 메세지를 생성하기 때문에 액티비티 트래킹은 종종 매우 높은 규모를 보입니다.&lt;/p&gt;

&lt;h3 id=&#34;metrics:50433a3ec3aee35119c9d3a0f7503755&#34;&gt;Metrics&lt;/h3&gt;

&lt;p&gt;Kafka는 종종 운영 모니티러이 데이터로 사용됩니다. 분산된 애플리케이션으로 부터 집계 통계를 구현하여 운영 데이터에 중앙 집중하된 데이터 전달을 만들 수 있습니다.&lt;/p&gt;

&lt;h3 id=&#34;log-aggregation:50433a3ec3aee35119c9d3a0f7503755&#34;&gt;Log Aggregation&lt;/h3&gt;

&lt;p&gt;대다수의 사람들은 Kafka를 로그 수집 솔루션를 위한 대안으로 Kafka를 사용합니다. 로그 수집은 전통적으로 외부 서버에 위치한 물리적 로그 파일을 수집하고 로그를 처리하기 위채서 중앙 저장소에 저장합니다. 중앙 저장소로는 파일서버나 HDFS가 이용됩니다. Kafka는 파일의 세부 정보로 부터 분리되고 로그 혹은 메세지 스트림 같은 이벤트 데이터에 대한 더 명확한 추상화를 제공합니다. 따라서 더 낮은 지연 처리와 복수 데이터 소스와 분산 데이터 소비에 대한 더 쉬운 지원을 가능하게 합니다. Scrive 혹은 Flume과 같은 로그 중심 시스템과 비교해 볼 때, Kafka는 상당히 좋은 성능, 복제에 기인한 더 강력한 데이터 연속성 보장, 더 낮은 지연 처리 시간을 제공합니다.&lt;/p&gt;

&lt;h3 id=&#34;stream-processing:50433a3ec3aee35119c9d3a0f7503755&#34;&gt;Stream Processing&lt;/h3&gt;

&lt;p&gt;많은 사용자는 Topic의 미처리 데이터(raw data)로 부터 소비한 데이터를 단계적인 프로세스로 처리하게 됩니다. 미 처리 데이터를 읽어서 합계를 내고, 데이터를 보강하고 혹은 추가적인 전달을 위해서 변환하여 새로운 Kafka topic에 전달합니다. 예를 들어서 기사 추천(article recommendation)용 프로세스 흐름은 RSS로 부터 기사 내용을 크롤링(Crawl)하고 그 데이터를 article topic에 전달합니다. 추가적인 프로세스는 데이터를 정규화하거나 깨끗한 기사 내용을 위하셔 컨텐츠를 정재하는 작업을 수행합니다. 마지막 단계에서 사용자에게 이 컨텐츠를 매칭합니다. 이러한 방식은 개별적인 topic으로 부터 실시간 데이터 프름의 그래프를 생성합니다.  이러한 종류의 변환을 구현하는 가장 유명한 프레임웍은  &lt;a href=&#34;https://storm.apache.org&#34;&gt;Storm&lt;/a&gt;과 &lt;a href=&#34;http://samza.apache.org&#34;&gt;Samza&lt;/a&gt; 입니다.&lt;/p&gt;

&lt;h3 id=&#34;event-sourcing:50433a3ec3aee35119c9d3a0f7503755&#34;&gt;Event Sourcing&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://martinfowler.com/eaaDev/EventSourcing.html&#34;&gt;Event Sourcing&lt;/a&gt;은 상태 변경이 시간 순서대로 레코드로 기록되는 애플리케이션 디자인 스타일입니다. 이러한 대규모 로그 데이터 저장 기능을 제공하는 kafka는 Enent Sourcing 스타일의 애플리케이션의 훌령한 백엔드 입니다.&lt;/p&gt;

&lt;h3 id=&#34;commit-log:50433a3ec3aee35119c9d3a0f7503755&#34;&gt;Commit Log&lt;/h3&gt;

&lt;p&gt;Kafka는 분산 시스템을 위한 외부 커밋-로그의 한가지 형태로 동작합니다. 로그는 노드들 사이에 데이터 복제되고 장애난 노드의 재동기화 매카니즘으로 동작하며 결과적으로 데이터를 복구합니다. Kafka에서 로그 데이터 압축 기능은 이러한 것들을 돕습니다. Commit Log 방식에서는 Kafka가 Apache BookKeeper와 유사하게 이용됩니다. .&lt;/p&gt;

&lt;h2 id=&#34;1-3-quick-start:50433a3ec3aee35119c9d3a0f7503755&#34;&gt;1.3 Quick Start&lt;/h2&gt;

&lt;p&gt;본 튜토리얼은 kafka를 처음 시작하고 기존에  kafka와 Zookeeper 데이터가 존재하지 않나고 가정합니다.&lt;/p&gt;

&lt;h3 id=&#34;step-1-코드-다운로드:50433a3ec3aee35119c9d3a0f7503755&#34;&gt;Step 1: 코드 다운로드&lt;/h3&gt;

&lt;p&gt;Apache Kafka 0.9.0.0 버전 [다운로드] 및 압축 풀기&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;taewan@kafka $tar -xvf kafka_2.11-0.9.0.0.tgz 
x kafka_2.11-0.9.0.0/
x kafka_2.11-0.9.0.0/LICENSE
//로그생략
x kafka_2.11-0.9.0.0/libs/lz4-1.2.0.jar
taewan@kafka $cd kafka_2.11-0.9.0.0
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;step-2-서버-시작:50433a3ec3aee35119c9d3a0f7503755&#34;&gt;step 2: 서버 시작&lt;/h3&gt;

&lt;p&gt;Kafka는 Zookeeper를 사용합니다. 따라서 가장 먼저 Zookeeper 서버를 시작해야 합니다. 이 글을 읽는 독자중 현재 사용하고 있는 Zookeeper가 없는 상황이라면, Kafka 패키지에 포함된 스크립트를 사용하여 단일 노드로 구성된 Zookeeper 인스턴스를 바로 시작할 수 있습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;taewan@kafka_2.11-0.9.0.0 $bin/zookeeper-server-start.sh config/zookeeper.properties 

[2016-04-08 17:19:31,254] INFO Reading configuration from: config/zookeeper.properties (org.apache.zookeeper.server.quorum.QuorumPeerConfig)
//로그 생량
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이제는 kafka 서버를 시작합니다. (역자주: 별도의 터니멀을 오픈하여 kafka 서버를 시작합니다. )&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;taewan@kafka_2.11-0.9.0.0 $pwd
/Users/taewan/temp/kafka/kafka_2.11-0.9.0.0
taewan@kafka_2.11-0.9.0.0 $bin/kafka-server-start.sh config/server.properties 
[2016-04-08 17:21:54,625] INFO KafkaConfig values: 
	advertised.host.name = null
	metric.reporters = []
//로그 생략
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;topic-생성하기:50433a3ec3aee35119c9d3a0f7503755&#34;&gt;Topic 생성하기&lt;/h3&gt;

&lt;p&gt;Topic 명이 &amp;ldquo;test&amp;rdquo;이고 단일 파티션과 단일 복제를 갖는 Topic을 생성합니다.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;bin/kafka-topics.sh &amp;ndash;create &amp;ndash;zookeeper localhost:2181 &amp;ndash;replication-factor 1 &amp;ndash;partitions 1 &amp;ndash;topic test&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;taewan@kafka_2.11-0.9.0.0 $bin/kafka-topics.sh --create --zookeeper localhost:2181 --replication-factor 1 --partitions 1 --topic test
Created topic &amp;quot;test&amp;quot;.
taewan@kafka_2.11-0.9.0.0 $
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;list 명령을 사용하여 topic의 목록을 확인 할 수 있습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;taewan@kafka_2.11-0.9.0.0 $bin/kafka-topics.sh --list --zookeeper localhost:2181
test
taewan@kafka_2.11-0.9.0.0 $
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;수작업으로 topic을 생성하지 않고 메세지를 발행하는 topic이 존재하지 않을때 topic이 자동으로 생성되도록 broker를 구성할 수 있습니다.&lt;/p&gt;

&lt;h3 id=&#34;step-4-메세지-전달하기:50433a3ec3aee35119c9d3a0f7503755&#34;&gt;Step 4: 메세지 전달하기&lt;/h3&gt;

&lt;p&gt;Kafka는 파일 혹은 표준 입력으로 부터 입력을 받아 메세지를 kafka 클러스터에 전달하는 커맨드 라인 클라이언트를 제공합니다. 각 라인이 개별적인 메세지로 전송됩니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;taewan@kafka_2.11-0.9.0.0 $bin/kafka-console-producer.sh --broker-list localhost:9092 --topic test
첫번째 메세지
두번째 메세지
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;step-5-consumer-실행하기:50433a3ec3aee35119c9d3a0f7503755&#34;&gt;step 5: Consumer 실행하기&lt;/h3&gt;

&lt;p&gt;Kafka는 또한 커맨드 라인 툴로 consumer를 제공합니다. 이 툴은 표준 출력으로 메세지를 출력합니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;taewan@kafka_2.11-0.9.0.0 $bin/kafka-console-consumer.sh --zookeeper localhost:2181 --topic test --from-beginning
첫번째 메세지
두번째 메세지
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;각기 다른 터미널에 위 명령을 각각 실행하고, produder 터미널에서 메세지를 입력하면, consumer 터미널에서 앞에서 입력한 메세지와 동일한 메세지가 출력될 것 입니다.&lt;/p&gt;

&lt;p&gt;모든 컴맨드 라인 툴들은 추가적인 옵션을 갖습니다. 파라미터 없이 커맨드를 입력하면 이들 명령에 대한 자세한 사용법과 추가적인 정보가 출력 됩니다.&lt;/p&gt;

&lt;h3 id=&#34;복수-브로커-클러스터-설정하기:50433a3ec3aee35119c9d3a0f7503755&#34;&gt;복수 브로커 클러스터 설정하기&lt;/h3&gt;

&lt;p&gt;지금까지 우리는 하나의 브로커를 구동하는 것을 확인하였습니다 그러나 이러한 예제는 현실적이지 않습니다. Kafka  에서 단일 브러커는 사이즈가 1인 클러스터 입니다. 복수의 브로커를 구성할 때 많은 변경이 발생하는 것은 아닙니다. 이번에는 하나의 서버에 3개의 노드로 클러스터를 확장해 보겠습니다&lt;/p&gt;

&lt;p&gt;우선 브로커 별로 설정 파일을 생성합니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;taewan@kafka_2.11-0.9.0.0 $cp config/server.properties config/server-1.properties
taewan@kafka_2.11-0.9.0.0 $cp config/server.properties config/server-2.properties
taewan@kafka_2.11-0.9.0.0 $ls -al config/server*.properties
-rw-r--r--@ 1 taewan  staff  5589  4  8 19:44 config/server-1.properties
-rw-r--r--@ 1 taewan  staff  5589  4  8 19:44 config/server-2.properties
-rw-r--r--@ 1 taewan  staff  5589 11 21 09:53 config/server.properties
taewan@kafka_2.11-0.9.0.0 $

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;새로 만든 두 프로퍼티 파일을 편집하여 다음과 같이 수정합니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;config/server-1.properties:
    broker.id=1
    port=9093
    log.dir=/tmp/kafka-logs-1

config/server-2.properties:
    broker.id=2
    port=9094
    log.dir=/tmp/kafka-logs-2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;broker.id 프로퍼티는 클러스터의 각 노드의 유일하고 영구적인 이름을 설정합니다. 또한 포트 번호와 로그 디렉토리를 수정해야 합니다. 이 두 프로퍼티를 수정하는 이유는 현재 예제는 모두 하나의  머신에서 동작하기 때문이고 그리고 이 예제에서는 브로커가 동일한 포트를 등록하거나 서로이 데이터를 덮어쓰는 것으로 부터 브로커를 보호하길 원하기 때문입니다&lt;/p&gt;

&lt;p&gt;우리는 이미 ZooKeeper를 갖고 있고 하나의 노드를 시작한 상태입니다. 따라서 두 개의 새로운 노드를 시작해야 합니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; bin/kafka-server-start.sh config/server-1.properties &amp;amp;
&amp;gt; bin/kafka-server-start.sh config/server-2.properties &amp;amp;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;taewan@kafka_2.11-0.9.0.0 $bin/kafka-server-start.sh config/server-1.properties &amp;amp;
taewan@kafka_2.11-0.9.0.0 $bin/kafka-server-start.sh config/server-2.properties &amp;amp;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;복제 계수가 3인 새로운 토픽을 생성:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; bin/kafka-topics.sh --create --zookeeper localhost:2181 --replication-factor 3 --partitions 1 --topic my-replicated-topic
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이제 어떤 브로커가 어떻게 동작하는지를 클러스터로 부터 확인 하는 방법을 알아볼 차례입니다. 이러한 정보를 확인하기 위해서 descrive topic 명령을 사용합니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;bin/kafka-topics.sh --describe --zookeeper localhost:2181 --topic my-replicated-topic
Topic:my-replicated-topic	PartitionCount:1	ReplicationFactor:3	Configs:
	Topic: my-replicated-topic	Partition: 0	Leader: 1	Replicas: 1,2,0	Isr: 1,2,0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;describe 명령의 출력을 살펴보겠습니다. 첫번째 라인은 모든 파티션의 요약 정보를 제공합니다. 그 아래 추가된 라인은  파티션 단위의 정보입니다. 우리는 오직 하나의 파티션만을 갖도록 토픽을 만들었기 때문에 위 툴력 결과는 오직 하나의 라인만을 갖습니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;leader: 해당 파티션의 읽기와 쓸기를 책임지는 파티션 입니다. 모든 노드 중 랜덤으로 선택된 1개 노드는 leader가 될 것입니다.&lt;/li&gt;
&lt;li&gt;replicas: 해당 파티션 로그를 복제하는 노두의 목록으로, 나열된 목록은 leader의 여부, 현재 활성화 여부와 관계 없습니다.&lt;/li&gt;
&lt;li&gt;Isr: &amp;ldquo;in-sync&amp;rdquo; 복제의 집합입니다. 이는 replia 목록의 부분 집합으로 현재 활성화 되여 있고 리더로 리더인 목록입니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;예제에서 주의할 점은 node 1이 토픽의 유일한 파티션에 대한 리더라는 것입니다.&lt;/p&gt;

&lt;p&gt;앞에서 생성한 최초의 토픽에 대하여 동일한 명령을 실행하여 다음과 같은 결과를 확인 할 수 있습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;taewan@kafka_2.11-0.9.0.0 $bin/kafka-topics.sh --describe --zookeeper localhost:2181 --topic test
Topic:test	PartitionCount:1	ReplicationFactor:1	Configs:
	Topic: test	Partition: 0	Leader: 0	Replicas: 0	Isr: 0
taewan@kafka_2.11-0.9.0.0 $
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;test Topic이 복제목록이 없고 서버 0만이 존재하는 것은 당연한 것입니다.&lt;/p&gt;

&lt;p&gt;이제 새로운 topic에 새로운 메세지를 전달해 보겠습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;taewan@kafka_2.11-0.9.0.0 $bin/kafka-console-producer.sh --broker-list localhost:9092 --topic my-replicated-topic
첫번째 메세지
두번째 메세지

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이제 메세지를 소비해 보겠습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;taewan@kafka_2.11-0.9.0.0 $bin/kafka-console-consumer.sh --zookeeper localhost:2181 --from-beginning --topic my-replicated-topic
첫번째 메세지
두번째 메세지

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이제 장애 극북을 테스트해 보겠습니다. 현재 Broker 1이 리더로 활성화 되어 있습니다. 그럼 리더 Brokder를 프로세스 종료해 보겠습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;taewan@kafka_2.11-0.9.0.0 $ps | grep server-1.properties
19249 ttys005    1:07.13 /Library/Java/JavaVirtualMachines/jdk1.8.0_60.jdk/Contents/Home/bin/java -Xmx1G -Xms1G -server -XX:+UseG1GC -XX:MaxGCPauseMillis=20 -XX:InitiatingHeapOccupancyPercent=35 -XX:+DisableExplicitGC -Djava.awt.headless=true -Xloggc:/Users/taewan/temp/kafka/kafka_2.11-0.9.0.0/bin/../logs/kafkaServer-gc.log -verbose:gc -XX:+PrintGCDetails -XX:+PrintGCDateStamps -XX:+PrintGCTimeStamps -Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.authenticate=false -Dcom.sun.management.jmxremote.ssl=false -Dkafka.logs.dir=/Users/taewan/temp/kafka/kafka_2.11-0.9.0.0/bin/../logs -Dlog4j.configuration=file:bin/../config/log4j.properties -cp :/Users/taewan/temp/kafka/kafka_2.11-0.9.0.0/bin/../libs/* kafka.Kafka config/server-1.properties
35359 ttys008    0:00.00 grep server-1.properties
taewan@kafka_2.11-0.9.0.0 $kill -9 19249
taewan@kafka_2.11-0.9.0.0 $
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;leader는 슬레이브 중 하나로 변경되었습니다 그리고 node 1은 더 이상 &amp;ldquo;in-sync replica set&amp;rdquo;에 포함되지 않습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;taewan@kafka_2.11-0.9.0.0 $bin/kafka-topics.sh --describe --zookeeper localhost:2181 --topic my-replicated-topic
Topic:my-replicated-topic	PartitionCount:1	ReplicationFactor:3	Configs:
	Topic: my-replicated-topic	Partition: 0	Leader: 0	Replicas: 0,2,1	Isr: 2,0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;초기에 선출된 리더는 현재 다운상태이지만 메세지의 소비는 여전이 이용가능 합니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;aewan@kafka_2.11-0.9.0.0 $ bin/kafka-console-consumer.sh --zookeeper localhost:2181 --from-beginning --topic my-replicated-topic
첫번째 메세지
두번째 메세지

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Step 7: Kafka connect를 사용하여 데이터 임포트/익스포트 하기&lt;/p&gt;

&lt;p&gt;콘솔에 데이터를 작성하고 다시 콘솔에 데이터를 출력하는 것은 처음 시작할때에나 적합한 방식입니다. 아마도 다른 데이터 소스로 부터 데이터를 사용하거나 Kafka로 부터 다른 시스템에 데이터를 보내는 것을 원할 것입니다. 다른 시스템을 위하여 사용자 정의 통합 코드를 적성하는 것 대신에, 데이터를 임포트하고 익스포트 하는 용도로 kafka 커넥터를 사용할 수 있습니다. Kafka 커넥터는 kafka에 데이터를 임포트하고 익스포트하는 툴로 kafka 배포 패지키에 포함되어 있습니다. Kafka 커넥터는 외부 시스템과 함께 상호작용하기 위한 사용자 정의 로직을 구현하는 커넥터를 구동하는 확장 툴이다. 현재 &amp;ldquo;Quick Start&amp;rdquo; 절에서, 파일로 부터 데이터를 임포트하고 파일에 Topic의 파일을 익스포트하는 단순한 커넥터를 살펴보겠습니다. 먼저, 테스트를 위한 기본 데이터를 만들어 보겠습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;taewan@kafka_2.11-0.9.0.0 $echo -e &amp;quot;foo\nbar&amp;quot; &amp;gt; test.txt
taewan@kafka_2.11-0.9.0.0 $cat test.txt 
foo
bar
taewan@kafka_2.11-0.9.0.0 $
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;다음으로, 단일 구동 모드로 두 개의 커넥터를 시작시킬 것입니다. 즉 이 두 커넥터는 단일, 로컬, 전용 프로세스라는 것을 의미합니다. Kafka 베포 패지키에는 이 데모를 위한 설정 파일 3개를 파마미터로써 제공합니다. 첫번째 설정 파일은 Kafka 커텍터 프로세스를 위한 설정입니다. 일반적으로 kafka 브러커의 접속 정보와 데이터에 대한 직렬화 포멧 정보 들이 포함됩니다.  나머지 설정 파일은 커넥터 생성을 담당합니다. 이 파일들에는 유일한 커넥터 명, 초기화 커넥터 클래스 그리고 커넥터에 필요한 기타 설정이 포함됩니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;taewan@kafka_2.11-0.9.0.0 $bin/connect-standalone.sh config/connect-standalone.properties config/connect-file-source.properties config/connect-file-sink.properties
[2016-04-10 23:39:39,843] INFO StandaloneConfig values: 
//생략
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Kafka 배포 패키지에 포함되어 있는 샘플 설정 파일은 기본 로컬 클러스터 구성을 사용합니다. 그리고 두 개 커넥터를 생성합니다. 첫번째는 소스 커넥터이고 입력 파일로 부터 줄 단위로 읽어들입니다. 그리고 kafka topic에 전달합니다. 두 번째는 Sink 커넥터로 kafka topic으로 부터 kafka topic에서 메세지를 읽어서 출력 파일에 줄 단위로 출력합니다. 명령어를 시작하면 커넥터를 초기화하는 내용을 포함하는 몇 줄의 로그 세세지를 볼 것입니다. Kafka 커넥터 프로세스가 시작되면, 소스 커넥터는 test.txt로 부터 줄단위로 읽어 들이기 시작합니다. 그리고 topic 명이 connect-test에 메세지를 전달하면, sink 커넥터는 topic명이 connect-test에서 메세지를 읽어서 test.sink.txt에 저장합니다.&lt;/p&gt;

&lt;p&gt;출력 파일의 내용을 확인하는 것으로 예제 커넥터로 전체 파이프라인을 통해서 모든 데이터가 전달되는지는 점증할 수 있습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;taewan@kafka_2.11-0.9.0.0 $cat test.sink.txt 
foo
bar
taewan@kafka_2.11-0.9.0.0 $
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;데이터는 kafka Topic(connect-test)에 저장됩니다. 따라서 Topic에 저장되는 데이터를 살펴보는 목적으로 console consumer를 시작하거나 데이터 처리용도로 사용자 정의 코드를 시작할 수 있습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;taewan@kafka_2.11-0.9.0.0 $bin/kafka-console-consumer.sh --zookeeper localhost:2181 --topic connect-test --from-beginning
{&amp;quot;schema&amp;quot;:{&amp;quot;type&amp;quot;:&amp;quot;string&amp;quot;,&amp;quot;optional&amp;quot;:false},&amp;quot;payload&amp;quot;:&amp;quot;foo&amp;quot;}
{&amp;quot;schema&amp;quot;:{&amp;quot;type&amp;quot;:&amp;quot;string&amp;quot;,&amp;quot;optional&amp;quot;:false},&amp;quot;payload&amp;quot;:&amp;quot;bar&amp;quot;}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;커넥터는 지속적으로 데이터를 처리합니다. 따라서 입력 파일에 데이터를 추가하면 그 데이터는 파이프라인을 통해서 이동하게 됩니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; echo &amp;quot;Another line&amp;quot; &amp;gt;&amp;gt; test.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;추가된 데이터는 consumer consumer와 sink 파일에서 확인 가능합니다.&lt;/p&gt;

&lt;h2 id=&#34;1-4-ecosystem:50433a3ec3aee35119c9d3a0f7503755&#34;&gt;1.4 Ecosystem&lt;/h2&gt;

&lt;p&gt;Kafka 배포 패키지외에도 Kafkadㅘ 통합된 수 많은 툴들이 있습니다. &lt;a href=&#34;https://cwiki.apache.org/confluence/display/KAFKA/Ecosystem&#34;&gt;에코시스템 페이지&lt;/a&gt;에tjsms 이들에 대한 목록을 제공합니다. 대표적인 사용 분야는 스트림 프로세스 시스템, 하둡 통합, 모니터링, 배포툴 등입니다.&lt;/p&gt;

&lt;h2 id=&#34;1-5-이전-버전으로-부터의-업그레이드:50433a3ec3aee35119c9d3a0f7503755&#34;&gt;1.5 이전 버전으로 부터의 업그레이드&lt;/h2&gt;

&lt;h3 id=&#34;0-8-0-0-8-1-x-0-8-2-x에서-0-9-0-0로-업그데이드:50433a3ec3aee35119c9d3a0f7503755&#34;&gt;0.8.0, 0.8.1.X,0.8.2.X에서 0.9.0.0로 업그데이드&lt;/h3&gt;

&lt;p&gt;0.9.0.0은 잠재적으로 준단되는 변경사항(Potential Breaking Changes)이 있으므로 업그레이드 전에 확인이 필요합니다. 그리고 내부 브로커 프로토콜이 이전 버전으로 부터 변경되었습니다. 이것은 업그레이드된 브로커와 클라이언트가 이전 버전과 호환되지 않을 가능성 도 있습니다. 중요한 점은 바로 클라이언트를 업그레이드 하기 전에 kafka 클러스터를 업그레이드 해야 한다는 것입니다. 현재 MirrorMaker Downstream 클러스터를 사용하고 있다면, 우선 업글레이드 해야 합니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Roling 업그레이드&lt;/strong&gt;
- 모든 브로커의 server.properties파일을 업데이트하고 다음 프로퍼티를 추가
  - &lt;code&gt;inter.broker.protocol.version=0.8.2.X&lt;/code&gt;
- 브로커 업그레이드 수행, 업그레이드는 브로커를 다운시킨 상태에서 코드 업그레이드 후 재시작으로 완료됨
- 전체 클러스터를 업그레이드할 때, &lt;code&gt;inter.broker.protocol.version&lt;/code&gt;를 수정함으로써 프로토콜 버전 충돌 발생, 버전을 0.9.0.0으로 설정
- 새로운 프로토콜 버전을 적용하기 위해서 브로커를 하나씩 재시작&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;주의사항&lt;/strong&gt;: 다운타임이 허용된다면, 모든 브로커를 다운시키고 코드를 업뎅트하고 재시작하면됩니다. 재지삭된 클러스터는 기본적으로 새로운 프로토콜로 시작될 것입니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;주의사항&lt;/strong&gt;: 프로토콜 버전 교체와 재시작은 브로커를 업그레이드한 후에 수행될 수 있습니다.  이러한 절차가 업그레이드 후 즉시 수행될 필요는 없습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;잠재적 중지 변겨: 0.9.0.0&lt;/strong&gt;
- Java 1.6 지원 중단
- Scala 2.9 지원 중단
- 1000 이상의 Broker ID는 자동 할당되는 Broker ID로 예약됨. 클러스터의 기존 Broker ID가 임계값 이상이라면 브로커 설정 프로퍼티인&lt;code&gt;reserved.broker.max.id&lt;/code&gt; 속성을 증가하는 설정을 해야 합니다.
- 설정 파라미터 &lt;code&gt;replica.lag.max.messages&lt;/code&gt;는 제거되었습니다. 파티션 리더는 더 이상 복제가 진행중인지를 결정할 때 지연 메세지의 수를 더이상 고려하지 않습니다.
- 설정 파라미터 &lt;code&gt;replica.lag.time.max.ms&lt;/code&gt;는 복제로 부터 마지막 패치 요청이래로 경과 시간과 복제가 마지막 잡애낸 이후 경과 시간을 모두 포함합니다. 리더로 부터 메세지를 패치는 하지만 replica.lag.time.max.ms의 범위를 초과하여 최근 메세지를 잡지 못하는 복제는 동기화에 문제가 있는 것으로 평가합니다.
- 압축된 topic은 더이상 키가 없는 메세지를 허용하지 않습니다. 키가 없을 경우 proucer는 예외를 발생시킵니다. 0.8.x에서 키가 없는 메세지는 연속적인 이슈로 로그 압축의 위협을 발생시킵니다. 그리고 모든 압축 topic 압축이 중지됩니다.
- MirrorMaker는 더이상 복수 대상 클러스터를 지원하지 않습니다. 결고적으로 오직 하나의 단일 클러스터만을 수용합니다(consumer.config). 복수의 소스 클러스터를 미러링하기 위해서 최소한 소스 클러스터 별로 하나의 MirrorMaker 인스턴스가 필요합니다. 각각은 consumer 설정에 매칭됩니다.
- org.apache.kafka.clients.tools.* 패키지 아래의 툴은 org.apache.kafka.tools.*로 이동되었습니다. 관련 스크립트는 여전히 도일하게 동작합니다. 오로지 커스텀 코드에서 클래스 임포트 부분만 변경이 되었습니다.
- 기본  Kafka JVM 성능 옵션(KAFKA_JVM_PERFORMANCE&lt;em&gt;OPTS)은 kafka-run-class.sh에서 변경되었습니다.
- kafka-topics.sh 스크립트(kafka.admin.TopicCommand)은 장애에 대한 제로를 반환하지 않는  exit 코드입니다.
- kafka-topics.sh 스크립트(kafka.admin.TopicCommand)은 Topic명이 메크릭 충동과 위협할 때 경고를 출력합니다. 예를 들어서 &amp;ldquo;.&amp;rdquo; 혹은 &amp;ldquo;&lt;/em&gt;&amp;ldquo;를 사용할 topic 명으로 사용할 때 입니다. 실제 충돌이 발생할 경우에는 에러를 출력합니다.&lt;br /&gt;
- kafka-console-producer.sh 스크립트는 디폴트로 이전 버전 Producer가 아닌 새로운 버전의 producer를 사용할 것입니다. 이전 버전의 producer를 사용하기 위해서는 &lt;code&gt;old-producer&lt;/code&gt;를 지정해야 합니다&lt;br /&gt;
- 모든 커맨드 라인 툴은 모든 로그 메세지를 stdout이 아닌 stderrdㅔ 모든 모그 메세지를 출력합니다.&lt;/p&gt;

&lt;p&gt;__ 0.9.0.0.1 주목할 변화__
- 새로운 idrㅏ 생성되는 기능는 비활성화 처리됨.&lt;code&gt;broker.id.generation.enable&lt;/code&gt;의 기본 값은 false.
- &lt;code&gt;log.cleaner.enable&lt;/code&gt; 설정 파라미터의 기본 값은 true입니다. &lt;code&gt;cleanup.policy=compact&lt;/code&gt; 설정된 topic은 기본적으로 압축 됩니다. 기본 128MB의 힙이 cleaner 프로세스에 할당되어 있으며, 이 프로세스 사이즈는  &lt;code&gt;log.cleaner.dedupe.buffer.size&lt;/code&gt;에서  설정 가능합니다. 사용자는 압축된  topic의 사용에 근거한 log.cleaner.depupe.buffer.size와 log.cleaner 설정 값을 재검토하기를 원할 수 있습니다.&lt;br /&gt;
- 새로운 consumer에 대하여 fetch.min.bytes의 설정 파라미터의 기본 값은 현재 1입니다.&lt;/p&gt;

&lt;p&gt;__ 0.9.0.0에서 Deprecations된 변경__
- kafka-topics.sh 스크립트(kafka.admin.TopicCommand)로 부터 topic 설정을 변경하는 것은 deplecate되었습니다. 앞으로 topic 설정 변경을 하는 용도로 kafka-configs.sh 스크립트(kafka.admin.ConfigCommand)를 사용하는 것이 권고됩니다.&lt;br /&gt;
- kafka-consumer-offset-checker.sh(kafka.tools.ConsumerOffsetChecker)는 deplecate되었습니다. 앞으로 kafka-consumer-groups.sh(kafka.admin.ConsumerGroupCommand) 를 사용하는 것이 권장됩니다.
- kafka.tools.ProducerPerformance 클래스는 deplecate되었습니다. 앞으로 org.apache.kafka.tools.ProducerPerformance 사용할 것을 권고합니다. kafka-producer-perf-test.sh 역시 새로운 클래스로 변경될 것입니다.&lt;/p&gt;

&lt;h3 id=&#34;0-8-1에서-0-8-2로-업그레이드:50433a3ec3aee35119c9d3a0f7503755&#34;&gt;0.8.1에서 0.8.2로 업그레이드&lt;/h3&gt;

&lt;p&gt;0.8.2는 0.8.1과 하위 호환성을 지원합니다. 업그레이드는 한 브로커에서 수행되며, 비활성화,  코드 업그레이드, 재시작으로 완료됩니다.&lt;/p&gt;

&lt;h3 id=&#34;0-8-0에서-0-8-1로-업그레이드:50433a3ec3aee35119c9d3a0f7503755&#34;&gt;0.8.0에서 0.8.1로 업그레이드&lt;/h3&gt;

&lt;p&gt;0.8.1는 0.8.0과 하위 호환성을 지원합니다. 업그레이드는 한 브로커에서 수행되며, 비활성화, 코드 업그레이드, 재시작으로 완료됩니다.&lt;/p&gt;

&lt;h3 id=&#34;0-7로-부터-업그레이드:50433a3ec3aee35119c9d3a0f7503755&#34;&gt;0.7로 부터  업그레이드&lt;/h3&gt;

&lt;p&gt;릴리즈 0.7은 새로운 버전과 호환성을 제공하지 않습니다. 주요 변경은 복제 기능을 추가하기 위하여 API, ZooKeeper 데이터 스트럭처, 프로토콜 그리고 설정에 이루어 졌습니다. 0.7에서 이후 버전으로 업그레이드는 마이그레이션을 위햔 특별한 &lt;a href=&#34;https://cwiki.apache.org/confluence/display/KAFKA/Migrating+from+0.7+to+0.8&#34;&gt;툴&lt;/a&gt;이 필요합니다. 이 마이그레이션은 다운타임 없이 수행될 수 있습니다.&lt;/p&gt;

&lt;h1 id=&#34;2-api:50433a3ec3aee35119c9d3a0f7503755&#34;&gt;2. API&lt;/h1&gt;

&lt;p&gt;아파치 카프카는 새로운 자바 클라이언트를 포함하여 기존 scala 클라이언트를 부충한다는 의미입니다. 위치는 org.apache.kafka.clients입니다. 그러나 호환성을 위하여 기존 클라이언트도 공존합니다. 이들 클라이언트는 최소한의 의존서으로 별도의 jar로 이용가능합니다. 기존의 스칼라 클라이언트는 서버와 같은 패키지에 위치합니다.&lt;/p&gt;

&lt;h2 id=&#34;2-1-producer-api:50433a3ec3aee35119c9d3a0f7503755&#34;&gt;2.1 Producer API&lt;/h2&gt;

&lt;p&gt;새로운 자바 프로듀서를 사용하기 위해서 모든 새로운 개발이 요구되었습니다. 이 클라이언트는 검증된 제품으로 기본 스칼라 클라이언트 보다 더 빠르고 더 완전한 기능을 탑재하고 있습니다. 사용자는 다음과 같은 메이븐 관리 기능을 사용하여 클라이언트 jar의 의존성을 추가하여 사용할 수 있습니다. (새로운 버전이 릴리즈 되면 버전 넘버를 변경해야 합니다.)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;dependency&amp;gt;
	    &amp;lt;groupId&amp;gt;org.apache.kafka&amp;lt;/groupId&amp;gt;
	    &amp;lt;artifactId&amp;gt;kafka-clients&amp;lt;/artifactId&amp;gt;
	    &amp;lt;version&amp;gt;0.9.0.0&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;producer 를 사용하는 방법을 소개하는 예제는 다음 javadoc에서 확인 가능합니다. =&amp;gt; &lt;a href=&#34;http://kafka.apache.org/090/javadoc/index.html?org/apache/kafka/clients/producer/KafkaProducer.html&#34;&gt;예제코드&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;이전 버전의 scala producer api에 대하여 정보가 필요하다면 다음 링크를 이용하여 정보를 찾을 수 있습니다. : &lt;a href=&#34;http://kafka.apache.org/081/documentation.html#producerapi&#34;&gt;이전 버전&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;2-2-consumer-api:50433a3ec3aee35119c9d3a0f7503755&#34;&gt;2.2 Consumer API&lt;/h2&gt;

&lt;p&gt;0.9.0릴리즈 부터, 기존의 고수준 Zookeeper 기반 consumer와 저수준 Consumer API를 대체하기 위하여 새로운 자바 Consumer를 추가하였습니다. 이 클라이언트는 베타 품질이 적용되어 있습니다. 사용자의 원할한 업그레이드를 보장하기 위히서, 0.9 kafka 클러스터에서도 0.8 consumer 클라이언트를 유지할 수 있습니다. 다음 절에서 0.8 consumer (고수준 consumerConnector와 저수준 Simple Consumer)와 새로운 자바 consumer API를 각각 소개할 것입니다.&lt;/p&gt;

&lt;h3 id=&#34;2-2-1-이전-버전-고-수준-consumer-api:50433a3ec3aee35119c9d3a0f7503755&#34;&gt;2.2.1 이전 버전 고 수준 Consumer API&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;
class Consumer {
  /**
   *  Create a ConsumerConnector
   *
   *  @param config  at the minimum, need to specify the groupid of the consumer and the zookeeper
   *                 connection string zookeeper.connect.
   */
  public static kafka.javaapi.consumer.ConsumerConnector createJavaConsumerConnector(ConsumerConfig config);
}

/**
 *  V: type of the message
 *  K: type of the optional key assciated with the message
 */
public interface kafka.javaapi.consumer.ConsumerConnector {
  /**
   *  Create a list of message streams of type T for each topic.
   *
   *  @param topicCountMap  a map of (topic, #streams) pair
   *  @param decoder a decoder that converts from Message to T
   *  @return a map of (topic, list of  KafkaStream) pairs.
   *          The number of items in the list is #streams. Each stream supports
   *          an iterator over message/metadata pairs.
   */
  public &amp;lt;K,V&amp;gt; Map&amp;lt;String, List&amp;lt;KafkaStream&amp;lt;K,V&amp;gt;&amp;gt;&amp;gt;
    createMessageStreams(Map&amp;lt;String, Integer&amp;gt; topicCountMap, Decoder&amp;lt;K&amp;gt; keyDecoder, Decoder&amp;lt;V&amp;gt; valueDecoder);

  /**
   *  Create a list of message streams of type T for each topic, using the default decoder.
   */
  public Map&amp;lt;String, List&amp;lt;KafkaStream&amp;lt;byte[], byte[]&amp;gt;&amp;gt;&amp;gt; createMessageStreams(Map&amp;lt;String, Integer&amp;gt; topicCountMap);

  /**
   *  Create a list of message streams for topics matching a wildcard.
   *
   *  @param topicFilter a TopicFilter that specifies which topics to
   *                    subscribe to (encapsulates a whitelist or a blacklist).
   *  @param numStreams the number of message streams to return.
   *  @param keyDecoder a decoder that decodes the message key
   *  @param valueDecoder a decoder that decodes the message itself
   *  @return a list of KafkaStream. Each stream supports an
   *          iterator over its MessageAndMetadata elements.
   */
  public &amp;lt;K,V&amp;gt; List&amp;lt;KafkaStream&amp;lt;K,V&amp;gt;&amp;gt;
    createMessageStreamsByFilter(TopicFilter topicFilter, int numStreams, Decoder&amp;lt;K&amp;gt; keyDecoder, Decoder&amp;lt;V&amp;gt; valueDecoder);

  /**
   *  Create a list of message streams for topics matching a wildcard, using the default decoder.
   */
  public List&amp;lt;KafkaStream&amp;lt;byte[], byte[]&amp;gt;&amp;gt; createMessageStreamsByFilter(TopicFilter topicFilter, int numStreams);

  /**
   *  Create a list of message streams for topics matching a wildcard, using the default decoder, with one stream.
   */
  public List&amp;lt;KafkaStream&amp;lt;byte[], byte[]&amp;gt;&amp;gt; createMessageStreamsByFilter(TopicFilter topicFilter);

  /**
   *  Commit the offsets of all topic/partitions connected by this connector.
   */
  public void commitOffsets();

  /**
   *  Shut down the connector
   */
  public void shutdown();
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;다음 링크에서 이 consumer API를 사용하는 방법을 확인 할 수 있습니다. &lt;a href=&#34;https://cwiki.apache.org/confluence/display/KAFKA/Consumer+Group+Example&#34;&gt;관련 링크&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;2-2-2-old-simple-consumer-api:50433a3ec3aee35119c9d3a0f7503755&#34;&gt;2.2.2 Old Simple Consumer API&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class kafka.javaapi.consumer.SimpleConsumer {
  /**
   *  Fetch a set of messages from a topic.
   *
   *  @param request specifies the topic name, topic partition, starting byte offset, maximum bytes to be fetched.
   *  @return a set of fetched messages
   */
  public FetchResponse fetch(kafka.javaapi.FetchRequest request);

  /**
   *  Fetch metadata for a sequence of topics.
   *
   *  @param request specifies the versionId, clientId, sequence of topics.
   *  @return metadata for each topic in the request.
   */
  public kafka.javaapi.TopicMetadataResponse send(kafka.javaapi.TopicMetadataRequest request);

  /**
   *  Get a list of valid offsets (up to maxSize) before the given time.
   *
   *  @param request a [[kafka.javaapi.OffsetRequest]] object.
   *  @return a [[kafka.javaapi.OffsetResponse]] object.
   */
  public kafka.javaapi.OffsetResponse getOffsetsBefore(OffsetRequest request);

  /**
   * Close the SimpleConsumer.
   */
  public void close();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;대부분의 애플리케이션에서 고수준 Consumer API이면 충분합니다. 몇몇 애플리케이션은 고수준 Consumer API에서 지원하지 않는 기능을 요구하기도 합니다(예: consumer를 재시작할 때 초기 offset을 설정하고자 하는 기능). 이러한 애플리케이션에서는 저수준 SimpleConsumer API로 대체하면 됩니다. 로직이 조금더 복잡해 질 것입니다. 예제 코드는 다음 링크에서 확인 할 수 있습니다. &lt;a href=&#34;https://cwiki.apache.org/confluence/display/KAFKA/0.8.0+SimpleConsumer+Example&#34;&gt;(예제 코드 링크)&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;2-2-3-새버전의-consumer-api:50433a3ec3aee35119c9d3a0f7503755&#34;&gt;2.2.3 새버전의 Consumer API&lt;/h3&gt;

&lt;p&gt;새로 통합된 consumer API는 0.8 버전의 고수준 API와 저수준 API의 차이를 제거하고 있습니다.  사용자는 다음과 같은 메이븐 관리 기능을 사용하여 클라이언트 jar의 의존성을 추가하여 클라이언트를 사용할 수 있습니다. (새로운 버전이 릴리즈 되면 버전 넘버를 변경해야 합니다.)&lt;/p&gt;

&lt;p&gt;Consumer를 사용하는 방법에 대산 예제는 다음 JavaDoc 링크에서 확인 할 수 있습니다:&lt;a href=&#34;http://kafka.apache.org/090/javadoc/index.html?org/apache/kafka/clients/consumer/KafkaConsumer.html&#34;&gt;Javadoc 링크&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;설정:50433a3ec3aee35119c9d3a0f7503755&#34;&gt;설정&lt;/h1&gt;

&lt;p&gt;Kafka는 설정을 위해서 프로퍼티 파일 포멧에 키-값 형식을 사용합니다. 이러한 설정 값은 파일 포멧이나 프로그램적인 설정으로 제공될 수 있습니다.&lt;/p&gt;

&lt;h2 id=&#34;3-1-브로커-설정:50433a3ec3aee35119c9d3a0f7503755&#34;&gt;3.1 브로커 설정&lt;/h2&gt;

&lt;p&gt;주요 설정 항목은 다음과 같습니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;broker.id&lt;/li&gt;
&lt;li&gt;log.dirs&lt;/li&gt;
&lt;li&gt;zookeeper.connect&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;3-1-broker-config:50433a3ec3aee35119c9d3a0f7503755&#34;&gt;3.1 Broker Config&lt;/h2&gt;

&lt;p&gt;토픽 레벨 설정과 기본값은 아래에서 다루겠습니다.&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;이름&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;설명&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;타입&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;기본값&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;유효값&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;중요도&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;zookeeper.connect&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Zookeeper 호스팅 문자열&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;String&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;High&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;advertised.host.name&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Clinet가 사용할 수 있도록 ZooKeeper가 공개하는 호스트 명, IaaS 환경에서, broker가 바인드 된 인터페이스와 달라야 하는 경우도 존재합니다. 설정되어 있는 host.name의 값을 사용할 것입니다. host.name조차도 설정이 되어 있지 않다면 java.net.InetAddress().getCanonicalHostName()의 반환 값을 사용할 것입니다.&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;String&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;null&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;High&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;advertised.listeners&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;설정된 리스너와 다른 경우에 클라이언트가 사용할 수 있도록 Zookeeper에 공개된 리스너 정보, IaaS 환경에서 브로커가 바인드 되는 인터페이스와 달라지는 경우가 발생합니다. 이 속성이 설정되지 않는다면 listeners 속성값을 사용합니다.&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;String&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;null&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;High&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;advertised.port&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;클라이언트가 사용할 Zookeeper에 공개된 포트입니다. IaaS 환경에서 브로커가 바인드된 포트와 다른 경우가 발생할 수 있습니다. 이 값이 설정되어 있지 않는다면 브러커가 바인드 되는 포트값을 사용합니다.&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;int&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;null&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;High&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;auto.create.topics.enable&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;서버에 토픽 자동 생성을 활성화 함&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;boolean&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;true&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;High&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;auto.leader.rebalance.enable&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;지동 리더 밸런스 활성화. 백그라운드 쓰레드는 리터 밸런스를 체크하고 정해전 인터벌이 필요하다면 리더 밸런스를 트리거 함&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;boolean&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;true&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;High&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;background.threads&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;다양한 백그라운드 프로세스 작업을 수행하는 쓰레드의 갯수 지정&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;int&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;10&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;[1,&amp;hellip;]&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;high&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;broker.id&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;서버를 위한 브로커 아이디. Zookeeperrk 생성한 브러커 ID와 사용자가 설정한 브러커 아이디가 충돌하는 것을 방지하기 위해서 MaxReservedBrokerId 속성을 추가함. Zookeeper가 생성하는 순차 번호는 MaxReservedBrokerId+1로 부터 시작함.&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;int&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;-1&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;High&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;compression.type&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;지정한 토픽의 압축 타입을 지정함. 이 속성은 표준 압축 코텍을 수용(&amp;lsquo;gzip&amp;rsquo;, &amp;lsquo;snappy&amp;rsquo;, lz4). 추가적으로 &amp;lsquo;uncompressed&amp;rsquo;와 &amp;lsquo;producer&amp;rsquo; 를 수용함.&amp;lsquo;uncompressed&amp;rsquo;는 압축을 적용하지 않는 옵션임. &amp;lsquo;producer&amp;rsquo;는 프로듀서에 설정된 압축 코텍을 유지하겠다는 의미임&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Strng&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;producer&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;High&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;delete.topic.enable&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;토픽 삭제를 활성화. 이 설정이 비활성화 되어 있다면 관리 툴을 잉요한 토픽 삭제는 실제 영향을 미치지 않음&amp;rdquo;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;boolean&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;false&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;false&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;host.name&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;브로커의 호스트 명. 설정이 되어 있다면 이 주소에 바인드 됨. 설정이 되어있지 않는다면. 모든 인터페이스에 바인드 됨&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;String&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&amp;rdquo;&amp;rdquo;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;High&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;leader.imbalance.check.interval.seconds&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;컨트롤러가 트리거하는 파티션 리벨런스 체크의 주기&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;long&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;300&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;High&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;leader.imbalance.per.broker.percentage&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;브로커 별로 허용된 리더 불균형의 비율. 브러커에 설정된 이 속성은 백분률 단위임&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;int&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;10&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;High&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;listeners&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;리스너 목록으로 URI의 컴마 분리, hostname을 0.0.0.0으로 지정하는 것은 모든 인터페이스에 바인딩하는 것임. hostname을 공백으로 남기는 것은 기본 인터페이스에 바인딩하는 설정. 예제: PLAINTEXT://myhost:9092,TRACE://:9091&lt;br/&gt; PLAINTEXT://0.0.0.0:9092, TRACE://localhost:9093&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;String&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;null&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;High&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;log.dir&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;로그 데이터가 유지되는 디렉터리, log.dirs이 보조 속성&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;String&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;/tmp/kafka-logs&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;High&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;log.dirs&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;로그 데이터를 저장하는 디렉토리 목록, 이 파라미터를 설정하지 않을 경우, log.dir 파라미터를 사용.&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;String&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;null&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;High&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;log.flush.interval.messages&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;메세지가 디스크에&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;hr /&gt;

&lt;p&gt;주요 설정 속성은 다음과 같습니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;broker.id&lt;/li&gt;
&lt;li&gt;log.dirs&lt;/li&gt;
&lt;li&gt;zookeeper.connect&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Topic 관련 설정과 기본값은 이래에서 자세히 설명하겠스빈다.&lt;/p&gt;

&lt;p&gt;Broker 설정에 대한 더욱 자세한 정보는 kafka.server.KafkaConfig 스칼라 클래스에서 찾을 수 있습니다.&lt;/p&gt;

&lt;p&gt;Topic-Level Configuration: Topic 관련 설정은 글로벌 디폴트 뿐만와 선택적이며 Topic 별로 재정의되는 것 모두를 지원합니다. Topic 별 설정이 값이 제시되지 않는다면 글로벌 기본 값을 사용합니다. Topic을 생성할 때에 Topic 설정 값을 재정의를 할 수 있습니다. 이때 &amp;ndash;config 옵션을 사용하여 하나 이상의 값을 재정의 합니다. 다음 예제는 이름이 my-topic인 Topic을 생성하는 예입니다. 이 예제에서는 최대 메세지 사이즈와 플러쉬 율을 재정의 합니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;bin/kafka-topics.sh --zookeeper localhost:2181 --create --topic my-topic --partitions 1
 --replication-factor 1 --config max.message.bytes=64000 --config flush.messages=1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이렇게 재정의된 값은 나중에 topic 명령어인 alter를 사용하여 변경될 수 있습니다. 다음 명령은 my-topic의 max message size를 수정하는 예입니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;bin/kafka-topics.sh --zookeeper localhost:2181 --alter --topic my-topic
 --config max.message.bytes=128000
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이렇게 재정의된 설정 값을 제거할 수도 있습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; &amp;gt; bin/kafka-topics.sh --zookeeper localhost:2181 --alter --topic my-topic
    --deleteConfig max.message.bytes
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;다음은 topic-level configuration입니다. 각 프로퍼티에 대한 서버의 기본 설정은 &amp;ldquo;server default property&amp;rdquo;컬럼에서 확인 할 수 있습니다. 서버 설정으로 적용된 기본값은 변경이 가능합니다.&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;프로퍼티&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;디폴트&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;Server Default Property&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;설명&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;cleanup.policy&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;delete&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;log.cleanup.policy&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&amp;ldquo;delete&amp;rdquo;와 &amp;ldquo;compact&amp;rdquo; 중 하나의 문자열. 이 문자열은 오래된 로그 세그먼트에 적용할 보관 정책을 결정하는 문자열임. 기본 정책은 &amp;ldquo;delete&amp;rdquo;로 보관 시간 혹은 사이즈 제한을 초과 할 때 오래된 세그먼트를 폐기합니다. &amp;ldquo;compact&amp;rdquo;로 설정하면 토픽에 로그를 압축합니다.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;delete.retention.ms&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;86400000,&lt;br/&gt;24 시간&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;log.cleaner.delete.retention.ms&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;flush.messages&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;None&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;log.flush.interval.messages&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;flush.ms&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;None&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;log.flush.interval.ms&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;index.interval.bytes&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;4096&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;log.index.interval.bytes&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;max.message.bytes&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;1,000,000&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;message.max.bytes&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;min.cleanable.dirty.ratio&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;0.5&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;log.cleaner.min.cleanable.ratio&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;min.insync.replicas&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;min.insync.replicas&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;retention.bytes&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;None&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;log.retention.bytes&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;retention.ms&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;7 days&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;log.retention.minutes&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;segment.bytes&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;1 GB&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;log.segment.bytes&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;segment.index.bytes&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;10 MB&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;log.index.size.max.bytes&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;segment.ms&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;7 days&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;log.roll.hours&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;segment.jitter.ms&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;log.roll.jitter.{ms,hours}&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h1 id=&#34;todo:50433a3ec3aee35119c9d3a0f7503755&#34;&gt;todo&lt;/h1&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:50433a3ec3aee35119c9d3a0f7503755:log-retaintion&#34;&gt;설정 명인지 확인하고 번역여부 다시 평가
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:50433a3ec3aee35119c9d3a0f7503755:log-retaintion&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>[막번역] Apache Kafka 0.9.0 Documentation</title>
      <link>http://taewan.kim/documents/translation/oracle_big_data_sql.html</link>
      <pubDate>Tue, 12 Apr 2016 14:56:13 +0900</pubDate>
      
      <guid>http://taewan.kim/documents/translation/oracle_big_data_sql.html</guid>
      <description>

&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;출처: &lt;a href=&#34;http://kafka.apache.org/documentation.html#introduction&#34;&gt;http://kafka.apache.org/documentation.html#introduction&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;버전: 0.90&lt;/li&gt;
&lt;li&gt;최종 업데이티:2016.04.06&lt;/li&gt;
&lt;li&gt;친척률: 5%&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;1-시작:02db276f177c9ea394e0f74e7b2c213a&#34;&gt;1. 시작&lt;/h1&gt;

&lt;h2 id=&#34;1-1-소개:02db276f177c9ea394e0f74e7b2c213a&#34;&gt;1.1 소개&lt;/h2&gt;

&lt;p&gt;Kafka는 커밋 로그 서비스로 분산, 파티션, 복제의 특징을 갖는다. Kafka는 메세징 시스템 기능을 제공하며, 아주 특이한 디자인을 포함합니다.&lt;/p&gt;

&lt;p&gt;이것이 무슨 의미일까요?&lt;/p&gt;

&lt;p&gt;우선 몇 가지 기본 메세징 용어를 살펴보겠습니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Topic: Kafka는 토픽이라고 불리는 메세지 저장소를 유지한다.&lt;/li&gt;
&lt;li&gt;Producer: Kafka 토픽에 메세지를 발행(저장)하는 프로세스&lt;/li&gt;
&lt;li&gt;Consumer: 토픽을 구독하고 발행된 메세지를 소비하는 프로세스&lt;/li&gt;
&lt;li&gt;Broker: Kafka는 하나 혹은 다수의 서버로 구성된 클러스터로 동작함. 클러스터를 구성하는 서버를 Broker라고 함&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Producer는 네트웍을 통해서 Kafka 클러스터에 메세지를 전달한다. Kafka 클러스터는 다시 메세지를 Consumer에 다음과 같이 전달됩니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://kafka.apache.org/images/producer_consumer.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;클라이언트와 서버사이의 통신은 단순한 고성능 TCP 프로토콜을 이용합니다. 이 TCP 프로토콜은 언어 중립적입니다. Apache Kafka는 Kafka 자바 클라이어트를 제공합니다. 그러나 다수의 언어에서 이용 가능한 클라이언트를 이용 가능합니다.  &lt;a href=&#34;https://cwiki.apache.org/confluence/display/KAFKA/Clients&#34;&gt;https://cwiki.apache.org/confluence/display/KAFKA/Clients&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;토픽과-로그:02db276f177c9ea394e0f74e7b2c213a&#34;&gt;토픽과 로그&lt;/h3&gt;

&lt;p&gt;토픽은 발행된 메세지의 카테고리명 혹은 피드명입니다. 각 토픽에 Kafka 클러스터는 분할된 로그를 다음과 같이 저장합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://kafka.apache.org/images/log_anatomy.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;각 파티션은 순차적이며 불변의 메세지를 저장하는 연속체(시퀀스)로 지속적으로 커밋 로그가 추가됩니다. 이 파티션의 메세지에는 개별적으로 순차적으로 증가하는 id (숫자)가 할당됩니다. 이 id를 &amp;ldquo;offset&amp;rdquo;이라고 하며 파티션에서 각 메세지를 유일하게 식별합니다.&lt;/p&gt;

&lt;p&gt;Kafka 클러스터는 모든 발행된 메세지를 설정된 기간동안 보관 합니다. 메세지의 소비 여부는 보관 결정에 관여하지 않습니다. 예를 들어서 log retaintion(로그 보관 주기 &lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:02db276f177c9ea394e0f74e7b2c213a:log-retaintion&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:02db276f177c9ea394e0f74e7b2c213a:log-retaintion&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;)이 2일로 설정되었다면 메세지가 발행된 후 이틀동안 해당 메세지는 소비될 수 있습니다. 그리고 이틀 후에는 저장 공간 확보를 위해서 폐기됩니다. Kafka 성능은 데이터 사이즈에 큰 영햐을 받지 않고 일정하게 유지됩니다. 따라서 많은 데이터를 보관하는 것이 문제가 되지는 않습니다.&lt;/p&gt;

&lt;p&gt;consumer에서 관리되는 유일한 메타데이터는 로그에서의 Consumer의 위치 다시 말해 offset 입니다. 이 offset은 consumer가 관리합니다. 일반적으로 Consumer는 메세지를 읽을때 마다 자신의 offset을 선형적으로 증가시킵니다. 그러나 이 위치 정보는  Consumer가 관리 합니다. 그리고 원하는 순서대로 메세지를 읽어갈 수 있습니다. 예를 들어서 Consumer는 데이터 재처리를 위해서 오래된 offset으로 재설정할 수 있습니다.&lt;/p&gt;

&lt;p&gt;이러한 특징들로 인하여 Kafka Consumer는 매우 저렴한 비용으로 관리 가능합니다. 또한 클러스터 혹은 다른 Consumer에 큰 영향을 미치지 않고 앞/뒤로 이동할 수 있습니다. 예를 들어서 기존 consumer가 어디까지 소비되었는지를 고려할 필요 없이, 모든 토픽의 내용을 &amp;ldquo;tail&amp;rdquo;하는 명령어를 사용할 수 있습니다. (역자주: 기존 Message Queue 방식에서는 불가능했던 오퍼레이션입니다. )&lt;/p&gt;

&lt;p&gt;로그를 파티셔닝하는 것은 몇 가지 의도가 있습니다. 첫 번째, 파티셔닝을 통해서 로그를 확장 할 수 있습니다. 이러한 확장은 단일 서버의 규모를 넘어선 확장이 가능하게 합니다. 각 개별적인 파티션은 구동하는 호스트에 적합해야 합니다. 하나의 Topic은 여러개의 파티션을 갖을 수 있고 결고적으로 대규모 데이터를 처리할 수 있습니다. 두 번째는 파티션은 어느정도 병렬처리의 단위로써 작동합니다.&lt;/p&gt;

&lt;h3 id=&#34;distribution:02db276f177c9ea394e0f74e7b2c213a&#34;&gt;Distribution&lt;/h3&gt;

&lt;p&gt;로그 파티션은 kafka 클러스터의 여러 서버에 분산되어 있습니다. 클러스터의 각 서버는 데이터 처리하며 파티션의 공유를 요청합니다. 파티션은 설정된 수 만큼의 서버에 복제하여 장애 극복(Fault Tolerance)을 지원합니다.&lt;/p&gt;

&lt;p&gt;각 파티션은 리더로써 동작하는 하나의 서버를 갖고 0개 혹은 그 아상 서버는 &amp;ldquo;follower&amp;rdquo;로 동작합니다. 리더는 파티션의 모든 읽기와 쓰기 요청을 처리합니다. 동시에 follower는 리더를 복제합니다. 리더에 장애가 발생하면 follower 중에 하나가 새로운 리더가 되며 이러한 처리는 자동화 되어 있습니다. 새로 선출된 그 리더는 해당 파티션에 대한 모든 읽기와 쓰기 요청을 처리합니다. 각 서버는 자신의 파티션의 일부에 대해서는 리더로 동작하고, 나머지 일부에 대해서는 follower로 동작합니다. 클러스터 내부에서 부하는 귱형을 맞추게 됩니다.&lt;/p&gt;

&lt;h3 id=&#34;producers:02db276f177c9ea394e0f74e7b2c213a&#34;&gt;Producers&lt;/h3&gt;

&lt;p&gt;Producer는 데이터를 자신이 선택한 토픽에 발행합니다. Producer는어떤 메세지를 토픽의 어떤 파티션에 저장할지를 결정하는 것을 전담합니다. 이러한 것은 부하를 분산하기 위해서 단순히 Round-robin 방식으로 동작되기도 하고 몇 가지 시멘틱 파티션 기능(메세지으 어떤 키를 기준으로 결정하는 바식)으로 동적합니다. 파티션을 사용에 관해서는 잠시후에 다루도록 하겠습니다.&lt;/p&gt;

&lt;h3 id=&#34;consumers:02db276f177c9ea394e0f74e7b2c213a&#34;&gt;Consumers&lt;/h3&gt;

&lt;p&gt;전통적인 메세징에서는 Queue와 Publish-subscribe 두 가지 모델있습니다. Queue 모델에서는 일련의 Consumer들로 풀(pool)을 구성하고 서버로 부터 메세지를 읽어습니다. 각 메세지는 consumer 풀중에 하나로 이동하게 됩니다. Publish-subscribe모델에서는 메세지는 모든 Consumer에 전달됩니다 (Broadcast). Kafka는 이 두가지 모델을 일반화한 하나의 consumer 모델인 &amp;ldquo;consumer group&amp;rdquo;을 제공합니다.&lt;/p&gt;

&lt;p&gt;Consumer는 Consumer 그룹 명으로 스스로를 분류합니다. Topic에 발행된 각 메세지는 각 구독 consumer 그룹의 1개 consumer 인스턴스에 전달됩니다. Consumer 인스턴스는 독립된 프로세스이거나 별도의 서버에 위치 할 수 있습니다.&lt;/p&gt;

&lt;p&gt;모든 consumer 인스턴스가 동일한 consumer 그룹을 갖는 상황이라면, 이러한 방식으로 작동하는 것은 전통적인 Queue 환경에서 여러 consumer에 부하를 분산하는 것과 유사하게 보입니다.&lt;/p&gt;

&lt;p&gt;반대로 모든 consumer 인스턴스가 모두 다른 consumer 그룹을 갖는다면, 이러한 구성은 publish-subscribe 모델과 같이 동작합니다. 모든 메세지는 모든 consumer에 전달됩니다 (Broadcast)&lt;/p&gt;

&lt;p&gt;일반적으로 Topic은 몇개의 consumer 그룹을 갖습니다. 각 그룹은 논리적인 구독자(subscriber)입니다. 각 그룹은 확장성과 장애 극복(Fault tolerance)을 위하여 복수의 consumer 인스턴스로 구성됩니다. 사실 이러한 구성은 구독자가 하나의 프로셋가 아닌 consumer 클러스터 형태인 publish-subscribe 시멘틱 구성과 같은 것 입니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&#34;http://kafka.apache.org/images/consumer-groups.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;그림 설명: 두 개의 kafka 클러스터는 4개의 파티셔닝(P0-P3)을 갖고 있으며, 2개의 consumer 그룹으로 구성되어 있습니다. Consumer 그룹 A는 두 개의 인스턴스를 갖고있고, Consumer 그룹 B는 4개의 consumer 인스턴스로 구성됩니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Kafka는 전통적인 메세징 시스템보다 더 강력하게 순서를 보장합니다.&lt;/p&gt;

&lt;p&gt;전통적인 Queue는 서버에 순서대로 메세지를 보관합니다. 복수의 consumer가 queue로 부터 메세지를 요청하면 서버는 메세지가 저장된 순서대로 consumer에 분해합니다. 그러나 서버가 순서대로 메세지를 Consumer에 분배하기는 했지만, 메세지는 consumer에 비동기적으로 전달됩니다. 따라서 메세지는 다른 consumer에 순서가 바뀌여 도착할 수 있습니다. 이는 사실상 메세지의 순서는 병렬처리에서는 무의미해 진다는 것을 의미합니다. 메세징 시스템은 종종 &amp;ldquo;배타적 Consumer(exclusive consumer)&amp;ldquo;의 개념으로 이러한 문제를 우회하기도 합니다. 배타적 consumer란 오직 queue로 부터 메세지를 소비하는 하나의 프로세스만을 허용하는 개념입니다. 그러나 이 방법은 병령 처리의 개념이 존재하지 않는 극단적인 편법입니다.&lt;/p&gt;

&lt;p&gt;Kafka는 이 방법보다 개선된 방식을 제공합니다. 토픽내에 병렬 파티션 개념을 사용합니다. Kafka는 순서를 보장하면서 consumer 프로세스 풀에 부하를 분산시킬 수 있습니다. 이는 토픽의 파티션에 consumer 그룹의 consumer를 할당하여 완성됩니다. 이러한 구성을 통해서 consumer는 파티션의 유일한 리더되고 순서대로 데이터를 소비하게 됩니다. 많은 파티션이 존재하기 때문에 다수의 consumer 인스턴스로 부하술 분산하게 됩니다. 주의할 점은  consumer 그룹의  consumer 인스턴스의 갯수는 파티션 보다 많을 수 없습니다.&lt;/p&gt;

&lt;p&gt;Kafka는 하나의 파티션내에서 메세지의 순서를 보장합니다. 토픽의 다른 파티션 사이에서는 순서를 보장하지 않습니다. 파티션 내에서 순서와 키를 기준으로한 파티션 데이터에 기능을 결합한다면 대부분 애플리케이션에 충족할 것 입니다. 그러나 메세지에 대한 전체 순서를 보장해야 하는 상황이라면 kafka를 하나 파티션만을 갖는 topic으로 구현할 수 있습니다. 물론 이 방식은 하나의 consumer 인스턴스만을 갖는 consumer 그룹을 사용해야 한다는 것을 의미합니다.&lt;/p&gt;

&lt;h3 id=&#34;kafaka가-보장하는-것:02db276f177c9ea394e0f74e7b2c213a&#34;&gt;Kafaka가 보장하는 것&lt;/h3&gt;

&lt;p&gt;Kafka는 다음과 같은 내용을 보자합니다.
- Producer가 특정 토픽 파티션에 전달한 메세지는 메세지가 전달된 순서대로 보일 것입니다. 즉 메세지 M1과 M2가 동일한 Proucer가 제출한 메세지이고 M1이 먼저 제출된 것이라면, M1에게는 M2보나 작은 offset이 할당되고 로그에서 앞에 위치하게 됩니다.
- consumer 인스턴스는 메세지가 로그에 저장된 순서대로 메세지가 보입니다.
- 복제 계수 N인 Topic에서 N-1개 서버 장애까지 로그에 저장된 메세지의 손실 없이 장애 극복 가능합니다.&lt;/p&gt;

&lt;p&gt;Kafka가 보장하는 더 자세한 내용은 이 문서의 디자인 섹션에서 다루겠습니다.&lt;/p&gt;

&lt;h2 id=&#34;1-2-use-cases:02db276f177c9ea394e0f74e7b2c213a&#34;&gt;1.2 Use Cases&lt;/h2&gt;

&lt;p&gt;이 절에서는 아파치 Kafka의 유명한 사용 사례를 설명합니다. 추가적인 설명은 다음 블러그를 참조하시기 바랍니다. &lt;a href=&#34;http://engineering.linkedin.com/distributed-systems/log-what-every-software-engineer-should-know-about-real-time-datas-unifying&#34;&gt;Linkedin  Technical Blog&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;messaging:02db276f177c9ea394e0f74e7b2c213a&#34;&gt;Messaging&lt;/h3&gt;

&lt;p&gt;Kafka는 다수의 전통적인 메세지 브로커를 대체하고 있습니다. Message Broker가 사용되는 이유는 다양합니다 (데이터 Producer로 부터 프로세스을 이원화고 처리되지 않은 메시지를 버퍼합니다.) 대부분의 메세지 시스템과 비교해 볼 때, Kafka는 더 좋은 처리량을 제공합니다. 또한 내장 파티션, 복제 그리고 장애 극복을 더 잘 제공합니다. Kafka는 대규모 확장 메세지 처리 애플리케이션에 적합한 솔루션입니다.&lt;/p&gt;

&lt;p&gt;경험적으로 메세징 사용은 종종 상태적으로 낮은 처리량을 보인다. 그러나 낮은 대기 지연을 요구할 수 도 있다. 그리고 종종 Kafka가 제공하는 강력한 영속성 ㅂ장에 의존하기도 한다.&lt;/p&gt;

&lt;p&gt;이 도메인에서 Kafka는 전통적인 메세징 시스템 (ActiveMQ와 RobbitMQ)와 비교할 수 있습니다.&lt;/p&gt;

&lt;h3 id=&#34;website-activity-tracking:02db276f177c9ea394e0f74e7b2c213a&#34;&gt;Website Activity Tracking&lt;/h3&gt;

&lt;p&gt;Kafka는 본래 실시간 publish-subscrive으로써 사용자 액티비티를 투적하는 파이프라인을 재구축할 수 있도록 하는 것 입니다. 이것은 사용자 액티비티(페이지뷰, 검색 혹은 다른 사용자가 취하는 움직임)를 액티비티 유형 별로 할당된 Topic를 갖는 중앙  Topic에 메세지를 발해하는 것을 의미합니다. 이러한 메세지 전달 방식은 실시간 프로세싱, 실시간 모니터링 그리고 하둡과 오프라인 데이터 웹어하우스 시스템으로 데이터 로딩하여 오프라인 프로세싱과 리포팅을 포함하는 다양한 범위에 응용할 수 있습니다.&lt;/p&gt;

&lt;p&gt;사용자 페이지 뷰를 위한 다수의 액티비티 메세지를 생성하기 때문에 액티비티 트래킹은 종종 매우 높은 규모를 보입니다.&lt;/p&gt;

&lt;h3 id=&#34;metrics:02db276f177c9ea394e0f74e7b2c213a&#34;&gt;Metrics&lt;/h3&gt;

&lt;p&gt;Kafka는 종종 운영 모니티러이 데이터로 사용됩니다. 분산된 애플리케이션으로 부터 집계 통계를 구현하여 운영 데이터에 중앙 집중하된 데이터 전달을 만들 수 있습니다.&lt;/p&gt;

&lt;h3 id=&#34;log-aggregation:02db276f177c9ea394e0f74e7b2c213a&#34;&gt;Log Aggregation&lt;/h3&gt;

&lt;p&gt;대다수의 사람들은 Kafka를 로그 수집 솔루션를 위한 대안으로 Kafka를 사용합니다. 로그 수집은 전통적으로 외부 서버에 위치한 물리적 로그 파일을 수집하고 로그를 처리하기 위채서 중앙 저장소에 저장합니다. 중앙 저장소로는 파일서버나 HDFS가 이용됩니다. Kafka는 파일의 세부 정보로 부터 분리되고 로그 혹은 메세지 스트림 같은 이벤트 데이터에 대한 더 명확한 추상화를 제공합니다. 따라서 더 낮은 지연 처리와 복수 데이터 소스와 분산 데이터 소비에 대한 더 쉬운 지원을 가능하게 합니다. Scrive 혹은 Flume과 같은 로그 중심 시스템과 비교해 볼 때, Kafka는 상당히 좋은 성능, 복제에 기인한 더 강력한 데이터 연속성 보장, 더 낮은 지연 처리 시간을 제공합니다.&lt;/p&gt;

&lt;h3 id=&#34;stream-processing:02db276f177c9ea394e0f74e7b2c213a&#34;&gt;Stream Processing&lt;/h3&gt;

&lt;p&gt;많은 사용자는 Topic의 미처리 데이터(raw data)로 부터 소비한 데이터를 단계적인 프로세스로 처리하게 됩니다. 미 처리 데이터를 읽어서 합계를 내고, 데이터를 보강하고 혹은 추가적인 전달을 위해서 변환하여 새로운 Kafka topic에 전달합니다. 예를 들어서 기사 추천(article recommendation)용 프로세스 흐름은 RSS로 부터 기사 내용을 크롤링(Crawl)하고 그 데이터를 article topic에 전달합니다. 추가적인 프로세스는 데이터를 정규화하거나 깨끗한 기사 내용을 위하셔 컨텐츠를 정재하는 작업을 수행합니다. 마지막 단계에서 사용자에게 이 컨텐츠를 매칭합니다. 이러한 방식은 개별적인 topic으로 부터 실시간 데이터 프름의 그래프를 생성합니다.  이러한 종류의 변환을 구현하는 가장 유명한 프레임웍은  &lt;a href=&#34;https://storm.apache.org&#34;&gt;Storm&lt;/a&gt;과 &lt;a href=&#34;http://samza.apache.org&#34;&gt;Samza&lt;/a&gt; 입니다.&lt;/p&gt;

&lt;h3 id=&#34;event-sourcing:02db276f177c9ea394e0f74e7b2c213a&#34;&gt;Event Sourcing&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://martinfowler.com/eaaDev/EventSourcing.html&#34;&gt;Event Sourcing&lt;/a&gt;은 상태 변경이 시간 순서대로 레코드로 기록되는 애플리케이션 디자인 스타일입니다. 이러한 대규모 로그 데이터 저장 기능을 제공하는 kafka는 Enent Sourcing 스타일의 애플리케이션의 훌령한 백엔드 입니다.&lt;/p&gt;

&lt;h3 id=&#34;commit-log:02db276f177c9ea394e0f74e7b2c213a&#34;&gt;Commit Log&lt;/h3&gt;

&lt;p&gt;Kafka는 분산 시스템을 위한 외부 커밋-로그의 한가지 형태로 동작합니다. 로그는 노드들 사이에 데이터 복제되고 장애난 노드의 재동기화 매카니즘으로 동작하며 결과적으로 데이터를 복구합니다. Kafka에서 로그 데이터 압축 기능은 이러한 것들을 돕습니다. Commit Log 방식에서는 Kafka가 Apache BookKeeper와 유사하게 이용됩니다. .&lt;/p&gt;

&lt;h2 id=&#34;1-3-quick-start:02db276f177c9ea394e0f74e7b2c213a&#34;&gt;1.3 Quick Start&lt;/h2&gt;

&lt;p&gt;본 튜토리얼은 kafka를 처음 시작하고 기존에  kafka와 Zookeeper 데이터가 존재하지 않나고 가정합니다.&lt;/p&gt;

&lt;h3 id=&#34;step-1-코드-다운로드:02db276f177c9ea394e0f74e7b2c213a&#34;&gt;Step 1: 코드 다운로드&lt;/h3&gt;

&lt;p&gt;Apache Kafka 0.9.0.0 버전 [다운로드] 및 압축 풀기&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;taewan@kafka $tar -xvf kafka_2.11-0.9.0.0.tgz 
x kafka_2.11-0.9.0.0/
x kafka_2.11-0.9.0.0/LICENSE
//로그생략
x kafka_2.11-0.9.0.0/libs/lz4-1.2.0.jar
taewan@kafka $cd kafka_2.11-0.9.0.0
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;step-2-서버-시작:02db276f177c9ea394e0f74e7b2c213a&#34;&gt;step 2: 서버 시작&lt;/h3&gt;

&lt;p&gt;Kafka는 Zookeeper를 사용합니다. 따라서 가장 먼저 Zookeeper 서버를 시작해야 합니다. 이 글을 읽는 독자중 현재 사용하고 있는 Zookeeper가 없는 상황이라면, Kafka 패키지에 포함된 스크립트를 사용하여 단일 노드로 구성된 Zookeeper 인스턴스를 바로 시작할 수 있습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;taewan@kafka_2.11-0.9.0.0 $bin/zookeeper-server-start.sh config/zookeeper.properties 

[2016-04-08 17:19:31,254] INFO Reading configuration from: config/zookeeper.properties (org.apache.zookeeper.server.quorum.QuorumPeerConfig)
//로그 생량
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이제는 kafka 서버를 시작합니다. (역자주: 별도의 터니멀을 오픈하여 kafka 서버를 시작합니다. )&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;taewan@kafka_2.11-0.9.0.0 $pwd
/Users/taewan/temp/kafka/kafka_2.11-0.9.0.0
taewan@kafka_2.11-0.9.0.0 $bin/kafka-server-start.sh config/server.properties 
[2016-04-08 17:21:54,625] INFO KafkaConfig values: 
	advertised.host.name = null
	metric.reporters = []
//로그 생략
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;topic-생성하기:02db276f177c9ea394e0f74e7b2c213a&#34;&gt;Topic 생성하기&lt;/h3&gt;

&lt;p&gt;Topic 명이 &amp;ldquo;test&amp;rdquo;이고 단일 파티션과 단일 복제를 갖는 Topic을 생성합니다.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;bin/kafka-topics.sh &amp;ndash;create &amp;ndash;zookeeper localhost:2181 &amp;ndash;replication-factor 1 &amp;ndash;partitions 1 &amp;ndash;topic test&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;taewan@kafka_2.11-0.9.0.0 $bin/kafka-topics.sh --create --zookeeper localhost:2181 --replication-factor 1 --partitions 1 --topic test
Created topic &amp;quot;test&amp;quot;.
taewan@kafka_2.11-0.9.0.0 $
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;list 명령을 사용하여 topic의 목록을 확인 할 수 있습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;taewan@kafka_2.11-0.9.0.0 $bin/kafka-topics.sh --list --zookeeper localhost:2181
test
taewan@kafka_2.11-0.9.0.0 $
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;수작업으로 topic을 생성하지 않고 메세지를 발행하는 topic이 존재하지 않을때 topic이 자동으로 생성되도록 broker를 구성할 수 있습니다.&lt;/p&gt;

&lt;h3 id=&#34;step-4-메세지-전달하기:02db276f177c9ea394e0f74e7b2c213a&#34;&gt;Step 4: 메세지 전달하기&lt;/h3&gt;

&lt;p&gt;Kafka는 파일 혹은 표준 입력으로 부터 입력을 받아 메세지를 kafka 클러스터에 전달하는 커맨드 라인 클라이언트를 제공합니다. 각 라인이 개별적인 메세지로 전송됩니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;taewan@kafka_2.11-0.9.0.0 $bin/kafka-console-producer.sh --broker-list localhost:9092 --topic test
첫번째 메세지
두번째 메세지
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;step-5-consumer-실행하기:02db276f177c9ea394e0f74e7b2c213a&#34;&gt;step 5: Consumer 실행하기&lt;/h3&gt;

&lt;p&gt;Kafka는 또한 커맨드 라인 툴로 consumer를 제공합니다. 이 툴은 표준 출력으로 메세지를 출력합니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;taewan@kafka_2.11-0.9.0.0 $bin/kafka-console-consumer.sh --zookeeper localhost:2181 --topic test --from-beginning
첫번째 메세지
두번째 메세지
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;각기 다른 터미널에 위 명령을 각각 실행하고, produder 터미널에서 메세지를 입력하면, consumer 터미널에서 앞에서 입력한 메세지와 동일한 메세지가 출력될 것 입니다.&lt;/p&gt;

&lt;p&gt;모든 컴맨드 라인 툴들은 추가적인 옵션을 갖습니다. 파라미터 없이 커맨드를 입력하면 이들 명령에 대한 자세한 사용법과 추가적인 정보가 출력 됩니다.&lt;/p&gt;

&lt;h3 id=&#34;복수-브로커-클러스터-설정하기:02db276f177c9ea394e0f74e7b2c213a&#34;&gt;복수 브로커 클러스터 설정하기&lt;/h3&gt;

&lt;p&gt;지금까지 우리는 하나의 브로커를 구동하는 것을 확인하였습니다 그러나 이러한 예제는 현실적이지 않습니다. Kafka  에서 단일 브러커는 사이즈가 1인 클러스터 입니다. 복수의 브로커를 구성할 때 많은 변경이 발생하는 것은 아닙니다. 이번에는 하나의 서버에 3개의 노드로 클러스터를 확장해 보겠습니다&lt;/p&gt;

&lt;p&gt;우선 브로커 별로 설정 파일을 생성합니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;taewan@kafka_2.11-0.9.0.0 $cp config/server.properties config/server-1.properties
taewan@kafka_2.11-0.9.0.0 $cp config/server.properties config/server-2.properties
taewan@kafka_2.11-0.9.0.0 $ls -al config/server*.properties
-rw-r--r--@ 1 taewan  staff  5589  4  8 19:44 config/server-1.properties
-rw-r--r--@ 1 taewan  staff  5589  4  8 19:44 config/server-2.properties
-rw-r--r--@ 1 taewan  staff  5589 11 21 09:53 config/server.properties
taewan@kafka_2.11-0.9.0.0 $

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;새로 만든 두 프로퍼티 파일을 편집하여 다음과 같이 수정합니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;config/server-1.properties:
    broker.id=1
    port=9093
    log.dir=/tmp/kafka-logs-1

config/server-2.properties:
    broker.id=2
    port=9094
    log.dir=/tmp/kafka-logs-2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;broker.id 프로퍼티는 클러스터의 각 노드의 유일하고 영구적인 이름을 설정합니다. 또한 포트 번호와 로그 디렉토리를 수정해야 합니다. 이 두 프로퍼티를 수정하는 이유는 현재 예제는 모두 하나의  머신에서 동작하기 때문이고 그리고 이 예제에서는 브로커가 동일한 포트를 등록하거나 서로이 데이터를 덮어쓰는 것으로 부터 브로커를 보호하길 원하기 때문입니다&lt;/p&gt;

&lt;p&gt;우리는 이미 ZooKeeper를 갖고 있고 하나의 노드를 시작한 상태입니다. 따라서 두 개의 새로운 노드를 시작해야 합니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; bin/kafka-server-start.sh config/server-1.properties &amp;amp;
&amp;gt; bin/kafka-server-start.sh config/server-2.properties &amp;amp;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;taewan@kafka_2.11-0.9.0.0 $bin/kafka-server-start.sh config/server-1.properties &amp;amp;
taewan@kafka_2.11-0.9.0.0 $bin/kafka-server-start.sh config/server-2.properties &amp;amp;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;복제 계수가 3인 새로운 토픽을 생성:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; bin/kafka-topics.sh --create --zookeeper localhost:2181 --replication-factor 3 --partitions 1 --topic my-replicated-topic
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이제 어떤 브로커가 어떻게 동작하는지를 클러스터로 부터 확인 하는 방법을 알아볼 차례입니다. 이러한 정보를 확인하기 위해서 descrive topic 명령을 사용합니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;bin/kafka-topics.sh --describe --zookeeper localhost:2181 --topic my-replicated-topic
Topic:my-replicated-topic	PartitionCount:1	ReplicationFactor:3	Configs:
	Topic: my-replicated-topic	Partition: 0	Leader: 1	Replicas: 1,2,0	Isr: 1,2,0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;describe 명령의 출력을 살펴보겠습니다. 첫번째 라인은 모든 파티션의 요약 정보를 제공합니다. 그 아래 추가된 라인은  파티션 단위의 정보입니다. 우리는 오직 하나의 파티션만을 갖도록 토픽을 만들었기 때문에 위 툴력 결과는 오직 하나의 라인만을 갖습니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;leader: 해당 파티션의 읽기와 쓸기를 책임지는 파티션 입니다. 모든 노드 중 랜덤으로 선택된 1개 노드는 leader가 될 것입니다.&lt;/li&gt;
&lt;li&gt;replicas: 해당 파티션 로그를 복제하는 노두의 목록으로, 나열된 목록은 leader의 여부, 현재 활성화 여부와 관계 없습니다.&lt;/li&gt;
&lt;li&gt;Isr: &amp;ldquo;in-sync&amp;rdquo; 복제의 집합입니다. 이는 replia 목록의 부분 집합으로 현재 활성화 되여 있고 리더로 리더인 목록입니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;예제에서 주의할 점은 node 1이 토픽의 유일한 파티션에 대한 리더라는 것입니다.&lt;/p&gt;

&lt;p&gt;앞에서 생성한 최초의 토픽에 대하여 동일한 명령을 실행하여 다음과 같은 결과를 확인 할 수 있습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;taewan@kafka_2.11-0.9.0.0 $bin/kafka-topics.sh --describe --zookeeper localhost:2181 --topic test
Topic:test	PartitionCount:1	ReplicationFactor:1	Configs:
	Topic: test	Partition: 0	Leader: 0	Replicas: 0	Isr: 0
taewan@kafka_2.11-0.9.0.0 $
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;test Topic이 복제목록이 없고 서버 0만이 존재하는 것은 당연한 것입니다.&lt;/p&gt;

&lt;p&gt;이제 새로운 topic에 새로운 메세지를 전달해 보겠습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;taewan@kafka_2.11-0.9.0.0 $bin/kafka-console-producer.sh --broker-list localhost:9092 --topic my-replicated-topic
첫번째 메세지
두번째 메세지

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이제 메세지를 소비해 보겠습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;taewan@kafka_2.11-0.9.0.0 $bin/kafka-console-consumer.sh --zookeeper localhost:2181 --from-beginning --topic my-replicated-topic
첫번째 메세지
두번째 메세지

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이제 장애 극북을 테스트해 보겠습니다. 현재 Broker 1이 리더로 활성화 되어 있습니다. 그럼 리더 Brokder를 프로세스 종료해 보겠습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;taewan@kafka_2.11-0.9.0.0 $ps | grep server-1.properties
19249 ttys005    1:07.13 /Library/Java/JavaVirtualMachines/jdk1.8.0_60.jdk/Contents/Home/bin/java -Xmx1G -Xms1G -server -XX:+UseG1GC -XX:MaxGCPauseMillis=20 -XX:InitiatingHeapOccupancyPercent=35 -XX:+DisableExplicitGC -Djava.awt.headless=true -Xloggc:/Users/taewan/temp/kafka/kafka_2.11-0.9.0.0/bin/../logs/kafkaServer-gc.log -verbose:gc -XX:+PrintGCDetails -XX:+PrintGCDateStamps -XX:+PrintGCTimeStamps -Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.authenticate=false -Dcom.sun.management.jmxremote.ssl=false -Dkafka.logs.dir=/Users/taewan/temp/kafka/kafka_2.11-0.9.0.0/bin/../logs -Dlog4j.configuration=file:bin/../config/log4j.properties -cp :/Users/taewan/temp/kafka/kafka_2.11-0.9.0.0/bin/../libs/* kafka.Kafka config/server-1.properties
35359 ttys008    0:00.00 grep server-1.properties
taewan@kafka_2.11-0.9.0.0 $kill -9 19249
taewan@kafka_2.11-0.9.0.0 $
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;leader는 슬레이브 중 하나로 변경되었습니다 그리고 node 1은 더 이상 &amp;ldquo;in-sync replica set&amp;rdquo;에 포함되지 않습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;taewan@kafka_2.11-0.9.0.0 $bin/kafka-topics.sh --describe --zookeeper localhost:2181 --topic my-replicated-topic
Topic:my-replicated-topic	PartitionCount:1	ReplicationFactor:3	Configs:
	Topic: my-replicated-topic	Partition: 0	Leader: 0	Replicas: 0,2,1	Isr: 2,0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;초기에 선출된 리더는 현재 다운상태이지만 메세지의 소비는 여전이 이용가능 합니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;aewan@kafka_2.11-0.9.0.0 $ bin/kafka-console-consumer.sh --zookeeper localhost:2181 --from-beginning --topic my-replicated-topic
첫번째 메세지
두번째 메세지

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Step 7: Kafka connect를 사용하여 데이터 임포트/익스포트 하기&lt;/p&gt;

&lt;p&gt;콘솔에 데이터를 작성하고 다시 콘솔에 데이터를 출력하는 것은 처음 시작할때에나 적합한 방식입니다. 아마도 다른 데이터 소스로 부터 데이터를 사용하거나 Kafka로 부터 다른 시스템에 데이터를 보내는 것을 원할 것입니다. 다른 시스템을 위하여 사용자 정의 통합 코드를 적성하는 것 대신에, 데이터를 임포트하고 익스포트 하는 용도로 kafka 커넥터를 사용할 수 있습니다. Kafka 커넥터는 kafka에 데이터를 임포트하고 익스포트하는 툴로 kafka 배포 패지키에 포함되어 있습니다. Kafka 커넥터는 외부 시스템과 함께 상호작용하기 위한 사용자 정의 로직을 구현하는 커넥터를 구동하는 확장 툴이다. 현재 &amp;ldquo;Quick Start&amp;rdquo; 절에서, 파일로 부터 데이터를 임포트하고 파일에 Topic의 파일을 익스포트하는 단순한 커넥터를 살펴보겠습니다. 먼저, 테스트를 위한 기본 데이터를 만들어 보겠습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;taewan@kafka_2.11-0.9.0.0 $echo -e &amp;quot;foo\nbar&amp;quot; &amp;gt; test.txt
taewan@kafka_2.11-0.9.0.0 $cat test.txt 
foo
bar
taewan@kafka_2.11-0.9.0.0 $
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;다음으로, 단일 구동 모드로 두 개의 커넥터를 시작시킬 것입니다. 즉 이 두 커넥터는 단일, 로컬, 전용 프로세스라는 것을 의미합니다. Kafka 베포 패지키에는 이 데모를 위한 설정 파일 3개를 파마미터로써 제공합니다. 첫번째 설정 파일은 Kafka 커텍터 프로세스를 위한 설정입니다. 일반적으로 kafka 브러커의 접속 정보와 데이터에 대한 직렬화 포멧 정보 들이 포함됩니다.  나머지 설정 파일은 커넥터 생성을 담당합니다. 이 파일들에는 유일한 커넥터 명, 초기화 커넥터 클래스 그리고 커넥터에 필요한 기타 설정이 포함됩니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;taewan@kafka_2.11-0.9.0.0 $bin/connect-standalone.sh config/connect-standalone.properties config/connect-file-source.properties config/connect-file-sink.properties
[2016-04-10 23:39:39,843] INFO StandaloneConfig values: 
//생략
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Kafka 배포 패키지에 포함되어 있는 샘플 설정 파일은 기본 로컬 클러스터 구성을 사용합니다. 그리고 두 개 커넥터를 생성합니다. 첫번째는 소스 커넥터이고 입력 파일로 부터 줄 단위로 읽어들입니다. 그리고 kafka topic에 전달합니다. 두 번째는 Sink 커넥터로 kafka topic으로 부터 kafka topic에서 메세지를 읽어서 출력 파일에 줄 단위로 출력합니다. 명령어를 시작하면 커넥터를 초기화하는 내용을 포함하는 몇 줄의 로그 세세지를 볼 것입니다. Kafka 커넥터 프로세스가 시작되면, 소스 커넥터는 test.txt로 부터 줄단위로 읽어 들이기 시작합니다. 그리고 topic 명이 connect-test에 메세지를 전달하면, sink 커넥터는 topic명이 connect-test에서 메세지를 읽어서 test.sink.txt에 저장합니다.&lt;/p&gt;

&lt;p&gt;출력 파일의 내용을 확인하는 것으로 예제 커넥터로 전체 파이프라인을 통해서 모든 데이터가 전달되는지는 점증할 수 있습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;taewan@kafka_2.11-0.9.0.0 $cat test.sink.txt 
foo
bar
taewan@kafka_2.11-0.9.0.0 $
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;데이터는 kafka Topic(connect-test)에 저장됩니다. 따라서 Topic에 저장되는 데이터를 살펴보는 목적으로 console consumer를 시작하거나 데이터 처리용도로 사용자 정의 코드를 시작할 수 있습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;taewan@kafka_2.11-0.9.0.0 $bin/kafka-console-consumer.sh --zookeeper localhost:2181 --topic connect-test --from-beginning
{&amp;quot;schema&amp;quot;:{&amp;quot;type&amp;quot;:&amp;quot;string&amp;quot;,&amp;quot;optional&amp;quot;:false},&amp;quot;payload&amp;quot;:&amp;quot;foo&amp;quot;}
{&amp;quot;schema&amp;quot;:{&amp;quot;type&amp;quot;:&amp;quot;string&amp;quot;,&amp;quot;optional&amp;quot;:false},&amp;quot;payload&amp;quot;:&amp;quot;bar&amp;quot;}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;커넥터는 지속적으로 데이터를 처리합니다. 따라서 입력 파일에 데이터를 추가하면 그 데이터는 파이프라인을 통해서 이동하게 됩니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; echo &amp;quot;Another line&amp;quot; &amp;gt;&amp;gt; test.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;추가된 데이터는 consumer consumer와 sink 파일에서 확인 가능합니다.&lt;/p&gt;

&lt;h2 id=&#34;1-4-ecosystem:02db276f177c9ea394e0f74e7b2c213a&#34;&gt;1.4 Ecosystem&lt;/h2&gt;

&lt;p&gt;Kafka 배포 패키지외에도 Kafkadㅘ 통합된 수 많은 툴들이 있습니다. &lt;a href=&#34;https://cwiki.apache.org/confluence/display/KAFKA/Ecosystem&#34;&gt;에코시스템 페이지&lt;/a&gt;에tjsms 이들에 대한 목록을 제공합니다. 대표적인 사용 분야는 스트림 프로세스 시스템, 하둡 통합, 모니터링, 배포툴 등입니다.&lt;/p&gt;

&lt;h2 id=&#34;1-5-이전-버전으로-부터의-업그레이드:02db276f177c9ea394e0f74e7b2c213a&#34;&gt;1.5 이전 버전으로 부터의 업그레이드&lt;/h2&gt;

&lt;h3 id=&#34;0-8-0-0-8-1-x-0-8-2-x에서-0-9-0-0로-업그데이드:02db276f177c9ea394e0f74e7b2c213a&#34;&gt;0.8.0, 0.8.1.X,0.8.2.X에서 0.9.0.0로 업그데이드&lt;/h3&gt;

&lt;p&gt;0.9.0.0은 잠재적으로 준단되는 변경사항(Potential Breaking Changes)이 있으므로 업그레이드 전에 확인이 필요합니다. 그리고 내부 브로커 프로토콜이 이전 버전으로 부터 변경되었습니다. 이것은 업그레이드된 브로커와 클라이언트가 이전 버전과 호환되지 않을 가능성 도 있습니다. 중요한 점은 바로 클라이언트를 업그레이드 하기 전에 kafka 클러스터를 업그레이드 해야 한다는 것입니다. 현재 MirrorMaker Downstream 클러스터를 사용하고 있다면, 우선 업글레이드 해야 합니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Roling 업그레이드&lt;/strong&gt;
- 모든 브로커의 server.properties파일을 업데이트하고 다음 프로퍼티를 추가
  - &lt;code&gt;inter.broker.protocol.version=0.8.2.X&lt;/code&gt;
- 브로커 업그레이드 수행, 업그레이드는 브로커를 다운시킨 상태에서 코드 업그레이드 후 재시작으로 완료됨
- 전체 클러스터를 업그레이드할 때, &lt;code&gt;inter.broker.protocol.version&lt;/code&gt;를 수정함으로써 프로토콜 버전 충돌 발생, 버전을 0.9.0.0으로 설정
- 새로운 프로토콜 버전을 적용하기 위해서 브로커를 하나씩 재시작&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;주의사항&lt;/strong&gt;: 다운타임이 허용된다면, 모든 브로커를 다운시키고 코드를 업뎅트하고 재시작하면됩니다. 재지삭된 클러스터는 기본적으로 새로운 프로토콜로 시작될 것입니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;주의사항&lt;/strong&gt;: 프로토콜 버전 교체와 재시작은 브로커를 업그레이드한 후에 수행될 수 있습니다.  이러한 절차가 업그레이드 후 즉시 수행될 필요는 없습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;잠재적 중지 변겨: 0.9.0.0&lt;/strong&gt;
- Java 1.6 지원 중단
- Scala 2.9 지원 중단
- 1000 이상의 Broker ID는 자동 할당되는 Broker ID로 예약됨. 클러스터의 기존 Broker ID가 임계값 이상이라면 브로커 설정 프로퍼티인&lt;code&gt;reserved.broker.max.id&lt;/code&gt; 속성을 증가하는 설정을 해야 합니다.
- 설정 파라미터 &lt;code&gt;replica.lag.max.messages&lt;/code&gt;는 제거되었습니다. 파티션 리더는 더 이상 복제가 진행중인지를 결정할 때 지연 메세지의 수를 더이상 고려하지 않습니다.
- 설정 파라미터 &lt;code&gt;replica.lag.time.max.ms&lt;/code&gt;는 복제로 부터 마지막 패치 요청이래로 경과 시간과 복제가 마지막 잡애낸 이후 경과 시간을 모두 포함합니다. 리더로 부터 메세지를 패치는 하지만 replica.lag.time.max.ms의 범위를 초과하여 최근 메세지를 잡지 못하는 복제는 동기화에 문제가 있는 것으로 평가합니다.
- 압축된 topic은 더이상 키가 없는 메세지를 허용하지 않습니다. 키가 없을 경우 proucer는 예외를 발생시킵니다. 0.8.x에서 키가 없는 메세지는 연속적인 이슈로 로그 압축의 위협을 발생시킵니다. 그리고 모든 압축 topic 압축이 중지됩니다.
- MirrorMaker는 더이상 복수 대상 클러스터를 지원하지 않습니다. 결고적으로 오직 하나의 단일 클러스터만을 수용합니다(consumer.config). 복수의 소스 클러스터를 미러링하기 위해서 최소한 소스 클러스터 별로 하나의 MirrorMaker 인스턴스가 필요합니다. 각각은 consumer 설정에 매칭됩니다.
- org.apache.kafka.clients.tools.* 패키지 아래의 툴은 org.apache.kafka.tools.*로 이동되었습니다. 관련 스크립트는 여전히 도일하게 동작합니다. 오로지 커스텀 코드에서 클래스 임포트 부분만 변경이 되었습니다.
- 기본  Kafka JVM 성능 옵션(KAFKA_JVM_PERFORMANCE&lt;em&gt;OPTS)은 kafka-run-class.sh에서 변경되었습니다.
- kafka-topics.sh 스크립트(kafka.admin.TopicCommand)은 장애에 대한 제로를 반환하지 않는  exit 코드입니다.
- kafka-topics.sh 스크립트(kafka.admin.TopicCommand)은 Topic명이 메크릭 충동과 위협할 때 경고를 출력합니다. 예를 들어서 &amp;ldquo;.&amp;rdquo; 혹은 &amp;ldquo;&lt;/em&gt;&amp;ldquo;를 사용할 topic 명으로 사용할 때 입니다. 실제 충돌이 발생할 경우에는 에러를 출력합니다.&lt;br /&gt;
- kafka-console-producer.sh 스크립트는 디폴트로 이전 버전 Producer가 아닌 새로운 버전의 producer를 사용할 것입니다. 이전 버전의 producer를 사용하기 위해서는 &lt;code&gt;old-producer&lt;/code&gt;를 지정해야 합니다&lt;br /&gt;
- 모든 커맨드 라인 툴은 모든 로그 메세지를 stdout이 아닌 stderrdㅔ 모든 모그 메세지를 출력합니다.&lt;/p&gt;

&lt;p&gt;__ 0.9.0.0.1 주목할 변화__
- 새로운 idrㅏ 생성되는 기능는 비활성화 처리됨.&lt;code&gt;broker.id.generation.enable&lt;/code&gt;의 기본 값은 false.
- &lt;code&gt;log.cleaner.enable&lt;/code&gt; 설정 파라미터의 기본 값은 true입니다. &lt;code&gt;cleanup.policy=compact&lt;/code&gt; 설정된 topic은 기본적으로 압축 됩니다. 기본 128MB의 힙이 cleaner 프로세스에 할당되어 있으며, 이 프로세스 사이즈는  &lt;code&gt;log.cleaner.dedupe.buffer.size&lt;/code&gt;에서  설정 가능합니다. 사용자는 압축된  topic의 사용에 근거한 log.cleaner.depupe.buffer.size와 log.cleaner 설정 값을 재검토하기를 원할 수 있습니다.&lt;br /&gt;
- 새로운 consumer에 대하여 fetch.min.bytes의 설정 파라미터의 기본 값은 현재 1입니다.&lt;/p&gt;

&lt;p&gt;__ 0.9.0.0에서 Deprecations된 변경__
- kafka-topics.sh 스크립트(kafka.admin.TopicCommand)로 부터 topic 설정을 변경하는 것은 deplecate되었습니다. 앞으로 topic 설정 변경을 하는 용도로 kafka-configs.sh 스크립트(kafka.admin.ConfigCommand)를 사용하는 것이 권고됩니다.&lt;br /&gt;
- kafka-consumer-offset-checker.sh(kafka.tools.ConsumerOffsetChecker)는 deplecate되었습니다. 앞으로 kafka-consumer-groups.sh(kafka.admin.ConsumerGroupCommand) 를 사용하는 것이 권장됩니다.
- kafka.tools.ProducerPerformance 클래스는 deplecate되었습니다. 앞으로 org.apache.kafka.tools.ProducerPerformance 사용할 것을 권고합니다. kafka-producer-perf-test.sh 역시 새로운 클래스로 변경될 것입니다.&lt;/p&gt;

&lt;h3 id=&#34;0-8-1에서-0-8-2로-업그레이드:02db276f177c9ea394e0f74e7b2c213a&#34;&gt;0.8.1에서 0.8.2로 업그레이드&lt;/h3&gt;

&lt;p&gt;0.8.2는 0.8.1과 하위 호환성을 지원합니다. 업그레이드는 한 브로커에서 수행되며, 비활성화,  코드 업그레이드, 재시작으로 완료됩니다.&lt;/p&gt;

&lt;h3 id=&#34;0-8-0에서-0-8-1로-업그레이드:02db276f177c9ea394e0f74e7b2c213a&#34;&gt;0.8.0에서 0.8.1로 업그레이드&lt;/h3&gt;

&lt;p&gt;0.8.1는 0.8.0과 하위 호환성을 지원합니다. 업그레이드는 한 브로커에서 수행되며, 비활성화, 코드 업그레이드, 재시작으로 완료됩니다.&lt;/p&gt;

&lt;h3 id=&#34;0-7로-부터-업그레이드:02db276f177c9ea394e0f74e7b2c213a&#34;&gt;0.7로 부터  업그레이드&lt;/h3&gt;

&lt;p&gt;릴리즈 0.7은 새로운 버전과 호환성을 제공하지 않습니다. 주요 변경은 복제 기능을 추가하기 위하여 API, ZooKeeper 데이터 스트럭처, 프로토콜 그리고 설정에 이루어 졌습니다. 0.7에서 이후 버전으로 업그레이드는 마이그레이션을 위햔 특별한 &lt;a href=&#34;https://cwiki.apache.org/confluence/display/KAFKA/Migrating+from+0.7+to+0.8&#34;&gt;툴&lt;/a&gt;이 필요합니다. 이 마이그레이션은 다운타임 없이 수행될 수 있습니다.&lt;/p&gt;

&lt;h1 id=&#34;2-api:02db276f177c9ea394e0f74e7b2c213a&#34;&gt;2. API&lt;/h1&gt;

&lt;p&gt;아파치 카프카는 새로운 자바 클라이언트를 포함하여 기존 scala 클라이언트를 부충한다는 의미입니다. 위치는 org.apache.kafka.clients입니다. 그러나 호환성을 위하여 기존 클라이언트도 공존합니다. 이들 클라이언트는 최소한의 의존서으로 별도의 jar로 이용가능합니다. 기존의 스칼라 클라이언트는 서버와 같은 패키지에 위치합니다.&lt;/p&gt;

&lt;h2 id=&#34;2-1-producer-api:02db276f177c9ea394e0f74e7b2c213a&#34;&gt;2.1 Producer API&lt;/h2&gt;

&lt;p&gt;새로운 자바 프로듀서를 사용하기 위해서 모든 새로운 개발이 요구되었습니다. 이 클라이언트는 검증된 제품으로 기본 스칼라 클라이언트 보다 더 빠르고 더 완전한 기능을 탑재하고 있습니다. 사용자는 다음과 같은 메이븐 관리 기능을 사용하여 클라이언트 jar의 의존성을 추가하여 사용할 수 있습니다. (새로운 버전이 릴리즈 되면 버전 넘버를 변경해야 합니다.)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;dependency&amp;gt;
	    &amp;lt;groupId&amp;gt;org.apache.kafka&amp;lt;/groupId&amp;gt;
	    &amp;lt;artifactId&amp;gt;kafka-clients&amp;lt;/artifactId&amp;gt;
	    &amp;lt;version&amp;gt;0.9.0.0&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;producer 를 사용하는 방법을 소개하는 예제는 다음 javadoc에서 확인 가능합니다. =&amp;gt; &lt;a href=&#34;http://kafka.apache.org/090/javadoc/index.html?org/apache/kafka/clients/producer/KafkaProducer.html&#34;&gt;예제코드&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;이전 버전의 scala producer api에 대하여 정보가 필요하다면 다음 링크를 이용하여 정보를 찾을 수 있습니다. : &lt;a href=&#34;http://kafka.apache.org/081/documentation.html#producerapi&#34;&gt;이전 버전&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;2-2-consumer-api:02db276f177c9ea394e0f74e7b2c213a&#34;&gt;2.2 Consumer API&lt;/h2&gt;

&lt;p&gt;0.9.0릴리즈 부터, 기존의 고수준 Zookeeper 기반 consumer와 저수준 Consumer API를 대체하기 위하여 새로운 자바 Consumer를 추가하였습니다. 이 클라이언트는 베타 품질이 적용되어 있습니다. 사용자의 원할한 업그레이드를 보장하기 위히서, 0.9 kafka 클러스터에서도 0.8 consumer 클라이언트를 유지할 수 있습니다. 다음 절에서 0.8 consumer (고수준 consumerConnector와 저수준 Simple Consumer)와 새로운 자바 consumer API를 각각 소개할 것입니다.&lt;/p&gt;

&lt;h3 id=&#34;2-2-1-이전-버전-고-수준-consumer-api:02db276f177c9ea394e0f74e7b2c213a&#34;&gt;2.2.1 이전 버전 고 수준 Consumer API&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;
class Consumer {
  /**
   *  Create a ConsumerConnector
   *
   *  @param config  at the minimum, need to specify the groupid of the consumer and the zookeeper
   *                 connection string zookeeper.connect.
   */
  public static kafka.javaapi.consumer.ConsumerConnector createJavaConsumerConnector(ConsumerConfig config);
}

/**
 *  V: type of the message
 *  K: type of the optional key assciated with the message
 */
public interface kafka.javaapi.consumer.ConsumerConnector {
  /**
   *  Create a list of message streams of type T for each topic.
   *
   *  @param topicCountMap  a map of (topic, #streams) pair
   *  @param decoder a decoder that converts from Message to T
   *  @return a map of (topic, list of  KafkaStream) pairs.
   *          The number of items in the list is #streams. Each stream supports
   *          an iterator over message/metadata pairs.
   */
  public &amp;lt;K,V&amp;gt; Map&amp;lt;String, List&amp;lt;KafkaStream&amp;lt;K,V&amp;gt;&amp;gt;&amp;gt;
    createMessageStreams(Map&amp;lt;String, Integer&amp;gt; topicCountMap, Decoder&amp;lt;K&amp;gt; keyDecoder, Decoder&amp;lt;V&amp;gt; valueDecoder);

  /**
   *  Create a list of message streams of type T for each topic, using the default decoder.
   */
  public Map&amp;lt;String, List&amp;lt;KafkaStream&amp;lt;byte[], byte[]&amp;gt;&amp;gt;&amp;gt; createMessageStreams(Map&amp;lt;String, Integer&amp;gt; topicCountMap);

  /**
   *  Create a list of message streams for topics matching a wildcard.
   *
   *  @param topicFilter a TopicFilter that specifies which topics to
   *                    subscribe to (encapsulates a whitelist or a blacklist).
   *  @param numStreams the number of message streams to return.
   *  @param keyDecoder a decoder that decodes the message key
   *  @param valueDecoder a decoder that decodes the message itself
   *  @return a list of KafkaStream. Each stream supports an
   *          iterator over its MessageAndMetadata elements.
   */
  public &amp;lt;K,V&amp;gt; List&amp;lt;KafkaStream&amp;lt;K,V&amp;gt;&amp;gt;
    createMessageStreamsByFilter(TopicFilter topicFilter, int numStreams, Decoder&amp;lt;K&amp;gt; keyDecoder, Decoder&amp;lt;V&amp;gt; valueDecoder);

  /**
   *  Create a list of message streams for topics matching a wildcard, using the default decoder.
   */
  public List&amp;lt;KafkaStream&amp;lt;byte[], byte[]&amp;gt;&amp;gt; createMessageStreamsByFilter(TopicFilter topicFilter, int numStreams);

  /**
   *  Create a list of message streams for topics matching a wildcard, using the default decoder, with one stream.
   */
  public List&amp;lt;KafkaStream&amp;lt;byte[], byte[]&amp;gt;&amp;gt; createMessageStreamsByFilter(TopicFilter topicFilter);

  /**
   *  Commit the offsets of all topic/partitions connected by this connector.
   */
  public void commitOffsets();

  /**
   *  Shut down the connector
   */
  public void shutdown();
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;다음 링크에서 이 consumer API를 사용하는 방법을 확인 할 수 있습니다. &lt;a href=&#34;https://cwiki.apache.org/confluence/display/KAFKA/Consumer+Group+Example&#34;&gt;관련 링크&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;2-2-2-old-simple-consumer-api:02db276f177c9ea394e0f74e7b2c213a&#34;&gt;2.2.2 Old Simple Consumer API&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class kafka.javaapi.consumer.SimpleConsumer {
  /**
   *  Fetch a set of messages from a topic.
   *
   *  @param request specifies the topic name, topic partition, starting byte offset, maximum bytes to be fetched.
   *  @return a set of fetched messages
   */
  public FetchResponse fetch(kafka.javaapi.FetchRequest request);

  /**
   *  Fetch metadata for a sequence of topics.
   *
   *  @param request specifies the versionId, clientId, sequence of topics.
   *  @return metadata for each topic in the request.
   */
  public kafka.javaapi.TopicMetadataResponse send(kafka.javaapi.TopicMetadataRequest request);

  /**
   *  Get a list of valid offsets (up to maxSize) before the given time.
   *
   *  @param request a [[kafka.javaapi.OffsetRequest]] object.
   *  @return a [[kafka.javaapi.OffsetResponse]] object.
   */
  public kafka.javaapi.OffsetResponse getOffsetsBefore(OffsetRequest request);

  /**
   * Close the SimpleConsumer.
   */
  public void close();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;대부분의 애플리케이션에서 고수준 Consumer API이면 충분합니다. 몇몇 애플리케이션은 고수준 Consumer API에서 지원하지 않는 기능을 요구하기도 합니다(예: consumer를 재시작할 때 초기 offset을 설정하고자 하는 기능). 이러한 애플리케이션에서는 저수준 SimpleConsumer API로 대체하면 됩니다. 로직이 조금더 복잡해 질 것입니다. 예제 코드는 다음 링크에서 확인 할 수 있습니다. &lt;a href=&#34;https://cwiki.apache.org/confluence/display/KAFKA/0.8.0+SimpleConsumer+Example&#34;&gt;(예제 코드 링크)&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;2-2-3-새버전의-consumer-api:02db276f177c9ea394e0f74e7b2c213a&#34;&gt;2.2.3 새버전의 Consumer API&lt;/h3&gt;

&lt;p&gt;새로 통합된 consumer API는 0.8 버전의 고수준 API와 저수준 API의 차이를 제거하고 있습니다.  사용자는 다음과 같은 메이븐 관리 기능을 사용하여 클라이언트 jar의 의존성을 추가하여 클라이언트를 사용할 수 있습니다. (새로운 버전이 릴리즈 되면 버전 넘버를 변경해야 합니다.)&lt;/p&gt;

&lt;p&gt;Consumer를 사용하는 방법에 대산 예제는 다음 JavaDoc 링크에서 확인 할 수 있습니다:&lt;a href=&#34;http://kafka.apache.org/090/javadoc/index.html?org/apache/kafka/clients/consumer/KafkaConsumer.html&#34;&gt;Javadoc 링크&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;설정:02db276f177c9ea394e0f74e7b2c213a&#34;&gt;설정&lt;/h1&gt;

&lt;p&gt;Kafka는 설정을 위해서 프로퍼티 파일 포멧에 키-값 형식을 사용합니다. 이러한 설정 값은 파일 포멧이나 프로그램적인 설정으로 제공될 수 있습니다.&lt;/p&gt;

&lt;h2 id=&#34;3-1-브로커-설정:02db276f177c9ea394e0f74e7b2c213a&#34;&gt;3.1 브로커 설정&lt;/h2&gt;

&lt;p&gt;주요 설정 항목은 다음과 같습니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;broker.id&lt;/li&gt;
&lt;li&gt;log.dirs&lt;/li&gt;
&lt;li&gt;zookeeper.connect&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;3-1-broker-config:02db276f177c9ea394e0f74e7b2c213a&#34;&gt;3.1 Broker Config&lt;/h2&gt;

&lt;p&gt;토픽 레벨 설정과 기본값은 아래에서 다루겠습니다.&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;이름&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;설명&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;타입&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;기본값&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;유효값&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;중요도&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;zookeeper.connect&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Zookeeper 호스팅 문자열&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;String&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;High&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;advertised.host.name&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Clinet가 사용할 수 있도록 ZooKeeper가 공개하는 호스트 명, IaaS 환경에서, broker가 바인드 된 인터페이스와 달라야 하는 경우도 존재합니다. 설정되어 있는 host.name의 값을 사용할 것입니다. host.name조차도 설정이 되어 있지 않다면 java.net.InetAddress().getCanonicalHostName()의 반환 값을 사용할 것입니다.&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;String&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;null&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;High&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;advertised.listeners&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;설정된 리스너와 다른 경우에 클라이언트가 사용할 수 있도록 Zookeeper에 공개된 리스너 정보, IaaS 환경에서 브로커가 바인드 되는 인터페이스와 달라지는 경우가 발생합니다. 이 속성이 설정되지 않는다면 listeners 속성값을 사용합니다.&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;String&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;null&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;High&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;advertised.port&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;클라이언트가 사용할 Zookeeper에 공개된 포트입니다. IaaS 환경에서 브로커가 바인드된 포트와 다른 경우가 발생할 수 있습니다. 이 값이 설정되어 있지 않는다면 브러커가 바인드 되는 포트값을 사용합니다.&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;int&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;null&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;High&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;auto.create.topics.enable&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;서버에 토픽 자동 생성을 활성화 함&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;boolean&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;true&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;High&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;auto.leader.rebalance.enable&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;지동 리더 밸런스 활성화. 백그라운드 쓰레드는 리터 밸런스를 체크하고 정해전 인터벌이 필요하다면 리더 밸런스를 트리거 함&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;boolean&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;true&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;High&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;background.threads&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;다양한 백그라운드 프로세스 작업을 수행하는 쓰레드의 갯수 지정&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;int&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;10&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;[1,&amp;hellip;]&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;high&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;broker.id&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;서버를 위한 브로커 아이디. Zookeeperrk 생성한 브러커 ID와 사용자가 설정한 브러커 아이디가 충돌하는 것을 방지하기 위해서 MaxReservedBrokerId 속성을 추가함. Zookeeper가 생성하는 순차 번호는 MaxReservedBrokerId+1로 부터 시작함.&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;int&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;-1&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;High&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;compression.type&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;지정한 토픽의 압축 타입을 지정함. 이 속성은 표준 압축 코텍을 수용(&amp;lsquo;gzip&amp;rsquo;, &amp;lsquo;snappy&amp;rsquo;, lz4). 추가적으로 &amp;lsquo;uncompressed&amp;rsquo;와 &amp;lsquo;producer&amp;rsquo; 를 수용함.&amp;lsquo;uncompressed&amp;rsquo;는 압축을 적용하지 않는 옵션임. &amp;lsquo;producer&amp;rsquo;는 프로듀서에 설정된 압축 코텍을 유지하겠다는 의미임&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Strng&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;producer&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;High&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;delete.topic.enable&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;토픽 삭제를 활성화. 이 설정이 비활성화 되어 있다면 관리 툴을 잉요한 토픽 삭제는 실제 영향을 미치지 않음&amp;rdquo;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;boolean&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;false&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;false&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;host.name&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;브로커의 호스트 명. 설정이 되어 있다면 이 주소에 바인드 됨. 설정이 되어있지 않는다면. 모든 인터페이스에 바인드 됨&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;String&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&amp;rdquo;&amp;rdquo;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;High&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;leader.imbalance.check.interval.seconds&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;컨트롤러가 트리거하는 파티션 리벨런스 체크의 주기&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;long&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;300&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;High&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;leader.imbalance.per.broker.percentage&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;브로커 별로 허용된 리더 불균형의 비율. 브러커에 설정된 이 속성은 백분률 단위임&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;int&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;10&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;High&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;listeners&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;리스너 목록으로 URI의 컴마 분리, hostname을 0.0.0.0으로 지정하는 것은 모든 인터페이스에 바인딩하는 것임. hostname을 공백으로 남기는 것은 기본 인터페이스에 바인딩하는 설정. 예제: PLAINTEXT://myhost:9092,TRACE://:9091&lt;br/&gt; PLAINTEXT://0.0.0.0:9092, TRACE://localhost:9093&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;String&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;null&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;High&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;log.dir&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;로그 데이터가 유지되는 디렉터리, log.dirs이 보조 속성&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;String&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;/tmp/kafka-logs&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;High&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;log.dirs&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;로그 데이터를 저장하는 디렉토리 목록, 이 파라미터를 설정하지 않을 경우, log.dir 파라미터를 사용.&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;String&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;null&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;High&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;log.flush.interval.messages&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;메세지가 디스크에&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;hr /&gt;

&lt;p&gt;주요 설정 속성은 다음과 같습니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;broker.id&lt;/li&gt;
&lt;li&gt;log.dirs&lt;/li&gt;
&lt;li&gt;zookeeper.connect&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Topic 관련 설정과 기본값은 이래에서 자세히 설명하겠스빈다.&lt;/p&gt;

&lt;p&gt;Broker 설정에 대한 더욱 자세한 정보는 kafka.server.KafkaConfig 스칼라 클래스에서 찾을 수 있습니다.&lt;/p&gt;

&lt;p&gt;Topic-Level Configuration: Topic 관련 설정은 글로벌 디폴트 뿐만와 선택적이며 Topic 별로 재정의되는 것 모두를 지원합니다. Topic 별 설정이 값이 제시되지 않는다면 글로벌 기본 값을 사용합니다. Topic을 생성할 때에 Topic 설정 값을 재정의를 할 수 있습니다. 이때 &amp;ndash;config 옵션을 사용하여 하나 이상의 값을 재정의 합니다. 다음 예제는 이름이 my-topic인 Topic을 생성하는 예입니다. 이 예제에서는 최대 메세지 사이즈와 플러쉬 율을 재정의 합니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;bin/kafka-topics.sh --zookeeper localhost:2181 --create --topic my-topic --partitions 1
 --replication-factor 1 --config max.message.bytes=64000 --config flush.messages=1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이렇게 재정의된 값은 나중에 topic 명령어인 alter를 사용하여 변경될 수 있습니다. 다음 명령은 my-topic의 max message size를 수정하는 예입니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;bin/kafka-topics.sh --zookeeper localhost:2181 --alter --topic my-topic
 --config max.message.bytes=128000
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이렇게 재정의된 설정 값을 제거할 수도 있습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; &amp;gt; bin/kafka-topics.sh --zookeeper localhost:2181 --alter --topic my-topic
    --deleteConfig max.message.bytes
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;다음은 topic-level configuration입니다. 각 프로퍼티에 대한 서버의 기본 설정은 &amp;ldquo;server default property&amp;rdquo;컬럼에서 확인 할 수 있습니다. 서버 설정으로 적용된 기본값은 변경이 가능합니다.&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;프로퍼티&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;디폴트&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;Server Default Property&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;설명&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;cleanup.policy&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;delete&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;log.cleanup.policy&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&amp;ldquo;delete&amp;rdquo;와 &amp;ldquo;compact&amp;rdquo; 중 하나의 문자열. 이 문자열은 오래된 로그 세그먼트에 적용할 보관 정책을 결정하는 문자열임. 기본 정책은 &amp;ldquo;delete&amp;rdquo;로 보관 시간 혹은 사이즈 제한을 초과 할 때 오래된 세그먼트를 폐기합니다. &amp;ldquo;compact&amp;rdquo;로 설정하면 토픽에 로그를 압축합니다.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;delete.retention.ms&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;86400000,&lt;br/&gt;24 시간&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;log.cleaner.delete.retention.ms&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;flush.messages&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;None&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;log.flush.interval.messages&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;flush.ms&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;None&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;log.flush.interval.ms&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;index.interval.bytes&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;4096&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;log.index.interval.bytes&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;max.message.bytes&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;1,000,000&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;message.max.bytes&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;min.cleanable.dirty.ratio&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;0.5&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;log.cleaner.min.cleanable.ratio&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;min.insync.replicas&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;min.insync.replicas&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;retention.bytes&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;None&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;log.retention.bytes&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;retention.ms&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;7 days&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;log.retention.minutes&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;segment.bytes&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;1 GB&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;log.segment.bytes&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;segment.index.bytes&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;10 MB&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;log.index.size.max.bytes&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;segment.ms&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;7 days&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;log.roll.hours&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;segment.jitter.ms&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;log.roll.jitter.{ms,hours}&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h1 id=&#34;todo:02db276f177c9ea394e0f74e7b2c213a&#34;&gt;todo&lt;/h1&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:02db276f177c9ea394e0f74e7b2c213a:log-retaintion&#34;&gt;설정 명인지 확인하고 번역여부 다시 평가
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:02db276f177c9ea394e0f74e7b2c213a:log-retaintion&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Scala for the Impatient: ch01. the Basics</title>
      <link>http://taewan.kim/documents/scala4impatient/ch01.html</link>
      <pubDate>Thu, 07 Apr 2016 19:24:30 +0900</pubDate>
      
      <guid>http://taewan.kim/documents/scala4impatient/ch01.html</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;최종 업데이트: 2016.04.07&lt;/li&gt;
&lt;li&gt;돌아가기: &lt;a href=&#34;http://taewan.kim/documents/scala4theimpatient.html&#34;&gt;Index&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h1 id=&#34;ch01-the-basics:1997847a940b2d3ade5fb5268bbdd076&#34;&gt;Ch01. The Basics&lt;/h1&gt;

&lt;h2 id=&#34;주요-내용-정리:1997847a940b2d3ade5fb5268bbdd076&#34;&gt;주요 내용 정리&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;import scala.math._&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;import 문에서 scala로 시작하는 패키지는 scala 생략 가능

&lt;ul&gt;
&lt;li&gt;다음 import는 동일한 결과&lt;/li&gt;
&lt;li&gt;&lt;code&gt;import scala.math._&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;import math._&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;static 메서드가 없음

&lt;ul&gt;
&lt;li&gt;Companion Object에 자바이 static 메서드 정의 가능&lt;/li&gt;
&lt;li&gt;인자가 없는 스칼라 메서드는 일반적으로 괄호를 사용하지 않는다.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;apply 메서드

&lt;ul&gt;
&lt;li&gt;apply메소드는 다음과 같은 상황헤서 묵시적으로 호출됨&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;quot;Hello&amp;quot;(4)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;BigInt(&amp;quot;1234567890&amp;quot;)&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;apply 메서드는 Companion Object에 정의됨&lt;/li&gt;
&lt;li&gt;new 연산자 없이 객체 생성&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;exercises:1997847a940b2d3ade5fb5268bbdd076&#34;&gt;Exercises&lt;/h2&gt;

&lt;h3 id=&#34;1-스칼라-repl에서-3을-입력하고-tab키를-입력할-것-어떤-메서드를-볼-수-있나:1997847a940b2d3ade5fb5268bbdd076&#34;&gt;1. 스칼라 REPL에서 3을 입력하고 Tab키를 입력할 것. 어떤 메서드를 볼 수 있나?&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;scala&amp;gt; 3.
%   +   &amp;gt;    &amp;gt;&amp;gt;&amp;gt;            isInstanceOf   toDouble   toLong     unary_+   |   
&amp;amp;   -   &amp;gt;=   ^              toByte         toFloat    toShort    unary_-       
*   /   &amp;gt;&amp;gt;   asInstanceOf   toChar         toInt      toString   unary_~       

scala&amp;gt; 3.
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;2-스칼라-repl에서-3의-제곱근을-계산하고-그-값을-제곱하라-결과가-3과-얼마나-차이가-나는가:1997847a940b2d3ade5fb5268bbdd076&#34;&gt;2. 스칼라 REPL에서 3의 제곱근을 계산하고 그 값을 제곱하라. 결과가 3과 얼마나 차이가 나는가?&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;scala&amp;gt; import math._
import math._

scala&amp;gt; sqrt(3)
res2: Double = 1.7320508075688772

scala&amp;gt; pow(res2, 2)
res3: Double = 2.9999999999999996

scala&amp;gt; 3 -  res3
res4: Double = 4.440892098500626E-16
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;3-res-변수는-val인가-var-인가:1997847a940b2d3ade5fb5268bbdd076&#34;&gt;3. res 변수는 val인가? var 인가?&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Answer: val&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;scala&amp;gt; 3+3
res5: Int = 6

scala&amp;gt; res5 = 7
&amp;lt;console&amp;gt;:14: error: reassignment to val
       res5 = 7
            ^
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;4-스칼라에서는-문자열을-숫자로-곱할-수-있다-crazy-3-을-repl에서-수행해-보라-이-연산은-무엇을-하나-스칼라-독-어디에서-찾을-수-있나:1997847a940b2d3ade5fb5268bbdd076&#34;&gt;4. 스칼라에서는 문자열을 숫자로 곱할 수 있다. &lt;code&gt;&amp;quot;crazy&amp;quot;*3&lt;/code&gt; 을 REPL에서 수행해 보라. 이 연산은 무엇을 하나? 스칼라 독 어디에서 찾을 수 있나?&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;scala&amp;gt; &amp;quot;crazy&amp;quot;*3
res0: String = crazycrazycrazy

scala&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;StringOps: &lt;a href=&#34;http://www.scala-lang.org/api/2.11.8/#scala.collection.immutable.StringOps&#34;&gt;http://www.scala-lang.org/api/2.11.8/#scala.collection.immutable.StringOps&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;def *(n: Int): String&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;5-10-max-2는-무엇을-의미하나-max-메서드는-어느-클래스에-정의되어-있나:1997847a940b2d3ade5fb5268bbdd076&#34;&gt;5. 10 max 2는 무엇을 의미하나? max 메서드는 어느 클래스에 정의되어 있나?&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;scala&amp;gt; 10 max 2
res7: Int = 10

scala&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.scala-lang.org/api/current/#scala.runtime.RichInt&#34;&gt;http://www.scala-lang.org/api/current/#scala.runtime.RichInt&lt;/a&gt;&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;scala.runtime.RichInt&lt;/li&gt;
&lt;li&gt;&lt;code&gt;def max(that: Int): Int&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;6-bitint를-사용하여-2-1024를-계산하시오:1997847a940b2d3ade5fb5268bbdd076&#34;&gt;6. BitInt를 사용하여 2^1024를 계산하시오.&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;scala&amp;gt; BigInt(2) pow 1024
res10: scala.math.BigInt = 179769313486231590772930519078902473361797697894230657273430081157732675805500963132708477322407536021120113879871393357658789768814416622492847430639474124377767893424865485276302219601246094119453082952085005768838150682342462881473913110540827237163350510684586298239947245938479716304835356329624224137216  

scala&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;7-probableprime과-random에-아무런-식별자-없이-probableprime-100-random-으로-임의의-소수를-얻으려면-어떻게-해야-하는가:1997847a940b2d3ade5fb5268bbdd076&#34;&gt;7. probablePrime과 Random에 아무런 식별자 없이 probablePrime(100, Random)으로 임의의 소수를 얻으려면 어떻게 해야 하는가?&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;scala&amp;gt; import BigInt._
import BigInt._

scala&amp;gt; import util._
import util._

scala&amp;gt; probablePrime(100, Random)
res0: scala.math.BigInt = 807294085848679373168091165161

scala&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;8-임의의-파일-혹은-디렉터리-이름을-생성하는-방법-중-하나는-임의의-bigint를-생성하고-있을-36진법으로-변환하여-qsnvbevtomcj38o06kul-같은-문자열을-얻는-것이다-스칼라-독을-뒤져서-방법을-찾으시오:1997847a940b2d3ade5fb5268bbdd076&#34;&gt;8. 임의의 파일 혹은 디렉터리 이름을 생성하는 방법 중 하나는 임의의 BigInt를 생성하고 있을 36진법으로 변환하여 &amp;ldquo;qsnvbevtomcj38o06kul&amp;rdquo; 같은 문자열을 얻는 것이다. 스칼라 독을 뒤져서 방법을 찾으시오.&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;scala&amp;gt; import BigInt._
import BigInt._

scala&amp;gt; import util._
import util._


scala&amp;gt;  probablePrime(100, Random)
res6: scala.math.BigInt = 972061358937142327172244809173

scala&amp;gt; res6.toString(36)
res8: String = 2m8qszj9v05sqltjr4d1
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;9-scala에서-문자열의-첫문자를-어떻게-얻는가-마지막-문자는-어떻게-얻는가:1997847a940b2d3ade5fb5268bbdd076&#34;&gt;9. scala에서 문자열의 첫문자를 어떻게 얻는가? 마지막 문자는 어떻게 얻는가?&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;scala&amp;gt; &amp;quot;meorng&amp;quot;(0)
res9: Char = m

scala&amp;gt; &amp;quot;meorng&amp;quot;.head
res10: Char = m

scala&amp;gt; &amp;quot;meorng&amp;quot;.last
res11: Char = g

scala&amp;gt; &amp;quot;meorng&amp;quot;.reverse
res12: String = gnroem

scala&amp;gt; &amp;quot;meorng&amp;quot;.reverse.head
res13: Char = g

scala&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;10-문자열의-take-drop-takeright-dropright는-무엇을-하나-substring을-사용하는-것에-비교해-장점과-단점은-무엇인가:1997847a940b2d3ade5fb5268bbdd076&#34;&gt;10. 문자열의 take, drop, takeRight, dropRight는 무엇을 하나? subString을 사용하는 것에 비교해 장점과 단점은 무엇인가?&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;scala&amp;gt; &amp;quot;merong&amp;quot; take 3
res16: String = mer

scala&amp;gt; &amp;quot;merong&amp;quot; drop 3
res17: String = ong

scala&amp;gt; &amp;quot;merong&amp;quot; takeRight 3
res18: String = ong

scala&amp;gt; &amp;quot;merong&amp;quot; dropRight 3
res19: String = mer
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;ul&gt;
&lt;li&gt;돌아가기: &lt;a href=&#34;http://taewan.kim/documents/scala4theimpatient.html&#34;&gt;Index&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Scala for The Imaptient - 정리</title>
      <link>http://taewan.kim/documents/scala4theimpatient.html</link>
      <pubDate>Thu, 07 Apr 2016 17:25:40 +0900</pubDate>
      
      <guid>http://taewan.kim/documents/scala4theimpatient.html</guid>
      <description>&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;http://taewan.kim/documents/scala4impatient/ch01.html&#34;&gt;The Basics&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Control Structures and Functions&lt;/li&gt;
&lt;li&gt;Working with Arrays&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>extjs 2.2 다운로드 URL</title>
      <link>http://taewan.kim/blog/2016/04/06/extjs_2.2_download/</link>
      <pubDate>Wed, 06 Apr 2016 10:07:25 +0900</pubDate>
      
      <guid>http://taewan.kim/blog/2016/04/06/extjs_2.2_download/</guid>
      <description>&lt;p&gt;하둡 에코에서 Batch Job 및 워크플로우를 담당하는 Apache Oozie는 Web Console기능을 제공합니다. Oozie Web Console은 ExtJS 2.2버전으로 개발되어 있습니다. 그러나 라이센스 문제로 Oozie 배포 패키지에는 ExtJS 2.2 버전이 포함되어 있지 않습니다.&lt;/p&gt;

&lt;p&gt;ExtJS 2.2 파일(zip파일)을 다운로드 받아 Oozie Server가 동작하는 &amp;ldquo;/var/lib/oozie&amp;rdquo;에 저장하고 oozie-site.xml에 &amp;ldquo;Enable Oozie Server Web Console&amp;rdquo;을 &amp;ldquo;true&amp;rdquo;로 설정하고 Oozie 서버를 재시작하면 Oozie Web Console이 구동됩니다.&lt;/p&gt;

&lt;p&gt;ExtJS 2.2는 sencha.com에서 관리하지 않는 버전의 라이브러리로 현재 sencha.com에서는 링크를 찾기 어렵습니다. 이런 상황에서 typo3.org를 사용하는 편리합니다. typo3.org는 오픈소스 CMS(Contents Management System)입니다. ExtJS 2.2의 오픈소스 버전은 다음 typo3.org에서 다운로드 받을 수 있습니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ExtJS 2.2 다운로드 URL: &lt;a href=&#34;https://typo3.org/extensions/repository/view/extjs&#34;&gt;https://typo3.org/extensions/repository/view/extjs&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;http://cdn.infoq.com/statics_s2_20160405-0343u1/resource/articles/introductionOozie/en/resources/Figure2%20small.jpg&#34; alt=&#34;&#34; title=&#34;Ooozie Web Console&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>마크다운 사용법 정리</title>
      <link>http://taewan.kim/blog/2016/04/04/markdown/</link>
      <pubDate>Mon, 04 Apr 2016 13:47:07 +0900</pubDate>
      
      <guid>http://taewan.kim/blog/2016/04/04/markdown/</guid>
      <description>

&lt;p&gt;taewan.kim은 대부분의 내용을 markdown으로 관리하고 있습니다. markdown은 직관적이고 간단한 문법으로 컨텐츠 관리에 매우 효과적입니다. markdown에서 주로 이용되는 테그는 15개정도 입니다. 혼동되는 주요 테그를 정리하겠습니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;ul&gt;
&lt;li&gt;목차 &lt;a id=&#34;top&#34;&gt;&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#header&#34;&gt;헤더&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#hr&#34;&gt;수평선&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#text&#34;&gt;텍스트 출력&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#em&#34;&gt;텍스트 강조&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#quotation&#34;&gt;인용&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#list&#34;&gt;목록&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#code&#34;&gt;코드&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#table&#34;&gt;테이블&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#link&#34;&gt;링크&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#image&#34;&gt;이미지&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#comment&#34;&gt;주석&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#footnote&#34;&gt;각주&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;헤더-a-id-header-a-top-top:d59f7b4dfecd890f0583fb0bac5a436e&#34;&gt;헤더 &lt;a id=&#34;header&#34;&gt;&lt;/a&gt; &lt;a href=&#34;#top&#34;&gt;(top)&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;H1 ~ H6까지 테그를 #으로 표현&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;# 헤더 스타일 (h1)
## 헤더 스타일 (h2)
### 헤더 스타일 (h3)
#### 헤더 스타일 (h4)
##### 헤더 스타일 (h5)
###### 헤더 스타일 (h6)
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;출력 결과&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;헤더-스타일-h1:d59f7b4dfecd890f0583fb0bac5a436e&#34;&gt;헤더 스타일 (h1)&lt;/h1&gt;

&lt;h2 id=&#34;헤더-스타일-h2:d59f7b4dfecd890f0583fb0bac5a436e&#34;&gt;헤더 스타일 (h2)&lt;/h2&gt;

&lt;h3 id=&#34;헤더-스타일-h3:d59f7b4dfecd890f0583fb0bac5a436e&#34;&gt;헤더 스타일 (h3)&lt;/h3&gt;

&lt;h4 id=&#34;헤더-스타일-h4:d59f7b4dfecd890f0583fb0bac5a436e&#34;&gt;헤더 스타일 (h4)&lt;/h4&gt;

&lt;h5 id=&#34;헤더-스타일-h5:d59f7b4dfecd890f0583fb0bac5a436e&#34;&gt;헤더 스타일 (h5)&lt;/h5&gt;

&lt;h6 id=&#34;헤더-스타일-h6:d59f7b4dfecd890f0583fb0bac5a436e&#34;&gt;헤더 스타일 (h6)&lt;/h6&gt;

&lt;ul&gt;
&lt;li&gt;효과: 다음과 같은 코드와 동일한 결과가 됨&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;h1&amp;gt;헤더 스타일 (h1)&amp;lt;/h1&amp;gt;
&amp;lt;h2&amp;gt;헤더 스타일 (h2)&amp;lt;/h2&amp;gt;
&amp;lt;h3&amp;gt;헤더 스타일 (h3)&amp;lt;/h3&amp;gt;
&amp;lt;h4&amp;gt;헤더 스타일 (h4)&amp;lt;/h4&amp;gt;
&amp;lt;h5&amp;gt;헤더 스타일 (h5)&amp;lt;/h5&amp;gt;
&amp;lt;h6&amp;gt;헤더 스타일 (h6)&amp;lt;/h6&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;수평선-a-id-hr-a-top-top:d59f7b4dfecd890f0583fb0bac5a436e&#34;&gt;수평선 &lt;a id=&#34;hr&#34;&gt;&lt;/a&gt; &lt;a href=&#34;#top&#34;&gt;(top)&lt;/a&gt;&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&amp;lt;hr /&amp;gt;와 동일한 결과를 출력&lt;/li&gt;
&lt;li&gt;&amp;rsquo;-&amp;lsquo;, &amp;lsquo;*&amp;lsquo;, &amp;lsquo;_&amp;lsquo;을 세개 이상 나열하면 수평선을 만듦&lt;/li&gt;
&lt;li&gt;단락 나누기 용도로 많이 사용.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;***
___
___
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;출력 결과&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;hr /&gt;

&lt;hr /&gt;

&lt;hr /&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;텍스트-출력-a-id-text-a-top-top:d59f7b4dfecd890f0583fb0bac5a436e&#34;&gt;텍스트 출력 &lt;a id=&#34;text&#34;&gt;&lt;/a&gt; &lt;a href=&#34;#top&#34;&gt;(top)&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;별도의 테그 없이 입력된 내용은 &amp;lt;p&amp;gt; ~ &amp;lt;\p&amp;gt; 처리가 됨&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;markdown은 직관적이고 간단한 문법으로 컨텐츠 관리에 매우 효과적입니다.
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;효과: 다음과 같은 코드와 동일한 결과가 됨&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;p&amp;gt;markdown은 직관적이고 간단한 문법으로 컨텐츠 관리에 매우 효과적입니다.&amp;lt;/p&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;텍스트-강조-a-id-em-a-top-top:d59f7b4dfecd890f0583fb0bac5a436e&#34;&gt;텍스트 강조 &lt;a id=&#34;em&#34;&gt;&lt;/a&gt; &lt;a href=&#34;#top&#34;&gt;(top)&lt;/a&gt;&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;*single asterisks* - 기울임체
_single underscores_ - 기울임체
**double asterisks** - 굵은글씨체 
__double underscores__ - 기울임체/굵은글씨체
***triple underscores*** - 기울임체/굵은글씨체
~~cancelline~~ - 취소줄 
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;결과 출력&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;em&gt;single asterisks&lt;/em&gt; - 기울임체&lt;br/&gt;
&lt;em&gt;single underscores&lt;/em&gt; - 기울임체&lt;br/&gt;
&lt;strong&gt;double asterisks&lt;/strong&gt; - 굵은글씨체 &lt;br/&gt;
&lt;strong&gt;double underscores&lt;/strong&gt; - 기울임체/굵은글씨체&lt;br/&gt;
&lt;strong&gt;&lt;em&gt;triple underscores&lt;/em&gt;&lt;/strong&gt; - 기울임체/굵은글씨체 &lt;br/&gt;
&lt;del&gt;cancelline&lt;/del&gt; - 취소줄&lt;br/&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;인용-a-id-quotation-a-top-top:d59f7b4dfecd890f0583fb0bac5a436e&#34;&gt;인용 &lt;a id=&#34;quotation&#34;&gt;&lt;/a&gt; &lt;a href=&#34;#top&#34;&gt;(top)&lt;/a&gt;&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;분문 중 인용된 글을 표시할 때 사용하며, &amp;ldquo;&amp;gt;&amp;rdquo; 기호를 모든 줄 앞에 붙임.&lt;/li&gt;
&lt;li&gt;&amp;rdquo;&amp;gt;&amp;rdquo; 기호의 개수에 따라 들여쓰기 레벨 조정 가능&lt;/li&gt;
&lt;li&gt;인용 블록 안에서 다른 마크다운 테그를 포함할 수 있음&lt;/li&gt;
&lt;li&gt;인용 블록 안에서 중첩 인용 표기 가능&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;인용-예제-1-기본-스타일:d59f7b4dfecd890f0583fb0bac5a436e&#34;&gt;인용 예제 1: 기본 스타일&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;&amp;gt; 인용되는 글입니다. 
&amp;gt; 인용되는 글의 두 번째 줄. 
&amp;gt; 인용되는 글의 세 번째 줄. 
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;출력 결과&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;인용되는 글입니다. &lt;br/&gt;
인용되는 글의 두 번째 줄.&lt;br/&gt;
인용되는 글의 세 번째 줄. &lt;br/&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;인용문의 레벨을 설정 할 수 있음&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;인용-예제-2-중첩-인용-및-스타일-적용:d59f7b4dfecd890f0583fb0bac5a436e&#34;&gt;인용 예제 2: 중첩 인용 및 스타일 적용&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; 인용되는 첫 번째 줄입니다.
&amp;gt;&amp;gt; 인용되는 내용 안에서 다시 인용되는 부분입니다. 
&amp;gt; (인용 수준을 변경할 때 이렇게 빈 줄 하나 넣어주세요) 
&amp;gt; 꺽쇠 한 번만 쓰면 다시 상위 수준으로 표시됩니다. 
&amp;gt; ###### 인용문 내부 헤더
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;인용되는 첫 번째 줄입니다.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;인용되는 내용 안에서 다시 인용되는 부분입니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;(인용 수준을 변경할 때 이렇게 빈 줄 하나 넣어주세요)&lt;/p&gt;

&lt;p&gt;꺽쇠 한 번만 쓰면 다시 상위 수준으로 표시됩니다.&lt;/p&gt;

&lt;h6 id=&#34;인용문-내부-헤더:d59f7b4dfecd890f0583fb0bac5a436e&#34;&gt;인용문 내부 헤더&lt;/h6&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;인용-예제-2-tab-을-적용한-인용:d59f7b4dfecd890f0583fb0bac5a436e&#34;&gt;인용 예제 2: tab 을 적용한 인용&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;인용 기호 앞에 tab을 입력하면 인용문의 들여 쓰기를 작성 가능.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;	&amp;gt; 인용되는 글입니다. 
	&amp;gt; 인용되는 글의 두 번째 줄. 
	&amp;gt; 인용되는 글의 세 번째 줄. 
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;출력 결과&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;인용되는 글입니다. &lt;br/&gt;
인용되는 글의 두 번째 줄.&lt;br/&gt;
인용되는 글의 세 번째 줄. &lt;br/&gt;
인용문의 레벨을 설정 할 수 있음&lt;br/&gt;&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;목록-a-id-list-a-top-top:d59f7b4dfecd890f0583fb0bac5a436e&#34;&gt;목록 &lt;a id=&#34;list&#34;&gt;&lt;/a&gt; &lt;a href=&#34;#top&#34;&gt;(top)&lt;/a&gt;&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;MarkDown으로 숫자 리스트, 블릿 리스트를 표현할 수 있음.&lt;/li&gt;
&lt;li&gt;순차가 없는 리스트를 표현할 때는 &amp;lsquo;*&amp;lsquo;, &amp;lsquo;+&amp;rsquo;, &amp;lsquo;-&amp;rdquo; 기호 사용 가능.&lt;/li&gt;
&lt;li&gt;순차가 있는 리스트를 표현할 때 &amp;lsquo;숫자&amp;rsquo; 사용용&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;* 리스트1
+ 리스트2
    * 서브 리스트1
    * 서브리스트 2
- 리스트3
    1. 순차 리스트1
    2. 순차 리스트2
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;출력 결과&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;리스트1&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;리스트2&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;서브 리스트1&lt;/li&gt;
&lt;li&gt;서브리스트 2&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;리스트3&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;순차 리스트1&lt;/li&gt;
&lt;li&gt;순차 리스트2&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;코드-a-id-code-a-top-top:d59f7b4dfecd890f0583fb0bac5a436e&#34;&gt;코드 &lt;a id=&#34;code&#34;&gt;&lt;/a&gt; &lt;a href=&#34;#top&#34;&gt;(top)&lt;/a&gt;&lt;/h2&gt;

&lt;h3 id=&#34;코드-유형-1-공백:d59f7b4dfecd890f0583fb0bac5a436e&#34;&gt;코드 유형 1: 공백&lt;/h3&gt;

&lt;p&gt;4개의 공백 또는 하나의 탭으로 들여쓰기를 만나면 변환되기 시작하여 들여쓰지 않은 행을 만날때까지 변환이 계속됨.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;공백 없이 바로 시작...

    스페이스 4개로 시작
    스페이스 4개로 시작

공백 없이 바로 시작...
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;출력 결과&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;공백 없이 바로 시작&amp;hellip;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;스페이스 4개로 시작
스페이스 4개로 시작
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;공백 없이 바로 시작&amp;hellip;&lt;/p&gt;

&lt;h3 id=&#34;코드-유형-2-코드-블록:d59f7b4dfecd890f0583fb0bac5a436e&#34;&gt;코드 유형 2: 코드 블록&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;코드 첫라인 앞과 마지막 라인 다음에 &amp;ldquo;```&amp;rdquo; (fense) 설치&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;코드-유형-3-인라인-코드:d59f7b4dfecd890f0583fb0bac5a436e&#34;&gt;코드 유형 3: 인라인 코드&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;스칼라에서는 `val a:Int = 3`과 같은 형식으로 변수를 선언합니다.
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;출력 결과&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;스칼라에서는 &lt;code&gt;val a:Int = 3&lt;/code&gt;과 같은 형식으로 변수를 선언합니다.&lt;/p&gt;

&lt;h2 id=&#34;테이블-a-id-table-a-top-top:d59f7b4dfecd890f0583fb0bac5a436e&#34;&gt;테이블 &lt;a id=&#34;table&#34;&gt;&lt;/a&gt; &lt;a href=&#34;#top&#34;&gt;(top)&lt;/a&gt;&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;| 이름   | 설명  | 나이 |
| ----- | ---- | --- | 
| 김태완  | 아빠  | 40 |
| 임선영  | 엄마  | 30 |
| 김민수  | 아들  | 2  |
&lt;/code&gt;&lt;/pre&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;이름&lt;/th&gt;
&lt;th&gt;설명&lt;/th&gt;
&lt;th&gt;나이&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;김태완&lt;/td&gt;
&lt;td&gt;아빠&lt;/td&gt;
&lt;td&gt;40&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;임선영&lt;/td&gt;
&lt;td&gt;엄마&lt;/td&gt;
&lt;td&gt;30&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;김민수&lt;/td&gt;
&lt;td&gt;아들&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&#34;테이블-정렬:d59f7b4dfecd890f0583fb0bac5a436e&#34;&gt;테이블 정렬&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;테이블 정렬: 헤더와 row 구분 자에 적용

&lt;ul&gt;
&lt;li&gt;오른쪽 정렬&lt;/li&gt;
&lt;li&gt;&amp;mdash;-:&lt;/li&gt;
&lt;li&gt;왼쪽 정렬&lt;/li&gt;
&lt;li&gt;:&amp;mdash;-&lt;/li&gt;
&lt;li&gt;가운데 정렬&lt;/li&gt;
&lt;li&gt;:&amp;mdash;-:&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;| 이름   | 설명  | 나이 |
| :----- | ----: | :---: | 
| 김태완  | 아빠  | 40 |
| 임선영  | 엄마  | 30 |
| 김민수  | 아들  | 2  |
&lt;/code&gt;&lt;/pre&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;이름&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;설명&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;나이&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;김태완&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;아빠&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;40&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;임선영&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;엄마&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;30&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;김민수&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;아들&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;2&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;링크-a-id-link-a-top-top:d59f7b4dfecd890f0583fb0bac5a436e&#34;&gt;링크 &lt;a id=&#34;link&#34;&gt;&lt;/a&gt; &lt;a href=&#34;#top&#34;&gt;(top)&lt;/a&gt;&lt;/h2&gt;

&lt;h3 id=&#34;기본-링크:d59f7b4dfecd890f0583fb0bac5a436e&#34;&gt;기본 링크&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;기본 문법: [링크걸 문구](http://주소)&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;[taewan.kim](http://taewan.kim)
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;HTML 변환 결과&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;a href=&amp;quot;http://taewan.kim&amp;quot;&amp;gt;taewan.kim&amp;lt;/a&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;출력 결과&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;http://taewan.kim&#34;&gt;taewan.kim&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;타이틀을-포함하는-링크:d59f7b4dfecd890f0583fb0bac5a436e&#34;&gt;타이틀을 포함하는 링크&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;기본 문법: [링크걸 문구](http://주소 &amp;ldquo;타이틀 문구&amp;rdquo;)&lt;/li&gt;
&lt;li&gt;&amp;ldquo;타이틀 문구&amp;rdquo;는 툴팁으로 표현 됨&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;[taewan.kim](http://taewan.kim &amp;quot;김태완 블러그&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;HTML 변환 결과&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;a href=&amp;quot;https://taewan.kim&amp;quot; title=&amp;quot;김태완 블러그&amp;quot;&amp;gt;taewan.kim&amp;lt;/a&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;출력 결과&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;http://taewan.kim&#34; title=&#34;김태완 블러그&#34;&gt;taewan.kim&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;참조-링크:d59f7b4dfecd890f0583fb0bac5a436e&#34;&gt;참조 링크&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;주소를 id로 참조&lt;/li&gt;
&lt;li&gt;[id] 형식으로 지정&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;    [구글][1]
    [1]: http://www.google.com
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;출력 결과&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;http://www.google.com&#34;&gt;구글&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;주소만으로-링크:d59f7b4dfecd890f0583fb0bac5a436e&#34;&gt;주소만으로 링크&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;주소를 &amp;ldquo;&amp;lt;&amp;ldquo;와 &amp;ldquo;&amp;gt;&amp;ldquo;기호로 감싸서 사용&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;http://taewan.kim&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;HTML 변환 결과&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;a href=&amp;quot;https://taewan.kim&amp;quot;&amp;gt;http://taewan.kim&amp;lt;/a&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;출력 결과&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;http://taewan.kim&#34;&gt;http://taewan.kim&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;네임드-앵커:d59f7b4dfecd890f0583fb0bac5a436e&#34;&gt;네임드 앵커&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;네임드 앵커는 특정 앵커로 점프하는 용도로 적합.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;
### 테이블 구성
  * [1장](#chapter-1)
  * [2장](#chapter-2)
  * [3장](#chapter-3)

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;###### 1장 &amp;lt;a id=&amp;quot;chapter-1&amp;quot;&amp;gt;&amp;lt;/a&amp;gt;
1장의 내용은.....

###### 2장 &amp;lt;a id=&amp;quot;chapter-2&amp;quot;&amp;gt;&amp;lt;/a&amp;gt;
2장의 내용은.....

###### 3장 &amp;lt;a id=&amp;quot;chapter-3&amp;quot;&amp;gt;&amp;lt;/a&amp;gt;
3장의 내용은.....
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;출력 결과&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;테이블-구성:d59f7b4dfecd890f0583fb0bac5a436e&#34;&gt;테이블 구성&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#chapter-1&#34;&gt;1장&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#chapter-2&#34;&gt;2장&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#chapter-3&#34;&gt;3장&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h6 id=&#34;1장-a-id-chapter-1-a:d59f7b4dfecd890f0583fb0bac5a436e&#34;&gt;1장 &lt;a id=&#34;chapter-1&#34;&gt;&lt;/a&gt;&lt;/h6&gt;

&lt;p&gt;1장의 내용은&amp;hellip;..&lt;/p&gt;

&lt;h6 id=&#34;2장-a-id-chapter-2-a:d59f7b4dfecd890f0583fb0bac5a436e&#34;&gt;2장 &lt;a id=&#34;chapter-2&#34;&gt;&lt;/a&gt;&lt;/h6&gt;

&lt;p&gt;2장의 내용은&amp;hellip;..&lt;/p&gt;

&lt;h6 id=&#34;3장-a-id-chapter-3-a:d59f7b4dfecd890f0583fb0bac5a436e&#34;&gt;3장 &lt;a id=&#34;chapter-3&#34;&gt;&lt;/a&gt;&lt;/h6&gt;

&lt;p&gt;3장의 내용은&amp;hellip;..&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;이미지-a-id-image-a-top-top:d59f7b4dfecd890f0583fb0bac5a436e&#34;&gt;이미지 &lt;a id=&#34;image&#34;&gt;&lt;/a&gt; &lt;a href=&#34;#top&#34;&gt;(top)&lt;/a&gt;&lt;/h2&gt;

&lt;h3 id=&#34;기본-이미지:d59f7b4dfecd890f0583fb0bac5a436e&#34;&gt;기본 이미지&lt;/h3&gt;

&lt;p&gt;문법: &lt;code&gt;![사진이름](사진경로)&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;![Minion](http://octodex.github.com/images/minion.png)
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;HTML 변환 결과&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;img src=&amp;quot;http://octodex.github.com/images/minion.png&amp;quot; alt=&amp;quot;Minion&amp;quot; /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;출력 결과&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;http://octodex.github.com/images/minion.png&#34; alt=&#34;Minion&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;타이클을-포함하는-이미지:d59f7b4dfecd890f0583fb0bac5a436e&#34;&gt;타이클을 포함하는 이미지&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;툴팁으로 타이틀이 출력 됨&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;![Alt text](http://octodex.github.com/images/stormtroopocat.jpg &amp;quot;The Stormtroopocat&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;HTML 변환 결과&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;img src=&amp;quot;http://octodex.github.com/images/stormtroopocat.jpg&amp;quot; alt=&amp;quot;Alt text&amp;quot; title=&amp;quot;The Stormtroopocat&amp;quot; /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;출력 결과&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;http://octodex.github.com/images/stormtroopocat.jpg&#34; alt=&#34;Alt text&#34; title=&#34;The Stormtroopocat&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;주소-참조-이미지:d59f7b4dfecd890f0583fb0bac5a436e&#34;&gt;주소 참조 이미지&lt;/h3&gt;

&lt;p&gt;링크와 같이 참조 주소를 갖는 이미지&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    ![Alt text][10]
    [10]: http://octodex.github.com/images/dojocat.jpg  &amp;quot;The Dojocat&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;출력 결과&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;http://octodex.github.com/images/dojocat.jpg&#34; alt=&#34;Alt text&#34; title=&#34;The Dojocat&#34; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;주석-a-id-comment-a-top-top:d59f7b4dfecd890f0583fb0bac5a436e&#34;&gt;주석 &lt;a id=&#34;comment&#34;&gt;&lt;/a&gt; &lt;a href=&#34;#top&#34;&gt;(top)&lt;/a&gt;&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;!--
마크다운으로 주석 처리 가능
--&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;출력결과 (출력 결과가 노출되지 않습니다.)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;HTML 변환 결과&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;!--
마크다운으로 주석 처리 가능
--&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;각주-a-id-footnote-a-top-top:d59f7b4dfecd890f0583fb0bac5a436e&#34;&gt;각주 &lt;a id=&#34;footnote&#34;&gt;&lt;/a&gt; &lt;a href=&#34;#top&#34;&gt;(top)&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;본문의 어떤 부분을 설명하거나 보충하기 위해 본문 아래쪽에 별도로 작성하는 간단한 설명문으로서 주로 내용의 출처를 밝힐 때 사용됩니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;최근 스칼라는 매우 인기가 높은 언어이다.[^scala]

\[^scala]: 스칼라는 마틴 오더시크가 개발한 함수형 언어이다. 
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;주의사항: 각주 두번째 라인의 역슬레쉬는 hugo의 코드 블록의  제약 사항으로 부득이하게 입력한 것입니다.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;출력 결과&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;최근 스칼라는 매우 인기가 높은 언어이다.&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:d59f7b4dfecd890f0583fb0bac5a436e:scala&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:d59f7b4dfecd890f0583fb0bac5a436e:scala&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:d59f7b4dfecd890f0583fb0bac5a436e:scala&#34;&gt;스칼라는 마틴 오더시크가 개발한 함수형 언어이다.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:d59f7b4dfecd890f0583fb0bac5a436e:scala&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>10.sets</title>
      <link>http://taewan.kim/documents/47degree4scala/10.sets.html</link>
      <pubDate>Thu, 31 Mar 2016 01:25:02 +0900</pubDate>
      
      <guid>http://taewan.kim/documents/47degree4scala/10.sets.html</guid>
      <description></description>
    </item>
    
  </channel>
</rss>