<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Scala on taewan&#39;s blog</title>
    <link>http://taewan.kim/categories/scala.html</link>
    <description>Recent content in Scala on taewan&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 07 Apr 2016 19:24:30 +0900</lastBuildDate>
    <atom:link href="http://taewan.kim/categories/scala.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Scala for the Impatient: ch01. the Basics</title>
      <link>http://taewan.kim/documents/scala4impatient/ch01.html</link>
      <pubDate>Thu, 07 Apr 2016 19:24:30 +0900</pubDate>
      
      <guid>http://taewan.kim/documents/scala4impatient/ch01.html</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;최종 업데이트: 2016.04.07&lt;/li&gt;
&lt;li&gt;돌아가기: &lt;a href=&#34;http://taewan.kim/documents/scala4theimpatient.html&#34;&gt;Index&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h1 id=&#34;ch01-the-basics:1997847a940b2d3ade5fb5268bbdd076&#34;&gt;Ch01. The Basics&lt;/h1&gt;

&lt;h2 id=&#34;주요-내용-정리:1997847a940b2d3ade5fb5268bbdd076&#34;&gt;주요 내용 정리&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;import scala.math._&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;import 문에서 scala로 시작하는 패키지는 scala 생략 가능

&lt;ul&gt;
&lt;li&gt;다음 import는 동일한 결과&lt;/li&gt;
&lt;li&gt;&lt;code&gt;import scala.math._&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;import math._&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;static 메서드가 없음

&lt;ul&gt;
&lt;li&gt;Companion Object에 자바이 static 메서드 정의 가능&lt;/li&gt;
&lt;li&gt;인자가 없는 스칼라 메서드는 일반적으로 괄호를 사용하지 않는다.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;apply 메서드

&lt;ul&gt;
&lt;li&gt;apply메소드는 다음과 같은 상황헤서 묵시적으로 호출됨&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;quot;Hello&amp;quot;(4)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;BigInt(&amp;quot;1234567890&amp;quot;)&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;apply 메서드는 Companion Object에 정의됨&lt;/li&gt;
&lt;li&gt;new 연산자 없이 객체 생성&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;exercises:1997847a940b2d3ade5fb5268bbdd076&#34;&gt;Exercises&lt;/h2&gt;

&lt;h3 id=&#34;1-스칼라-repl에서-3을-입력하고-tab키를-입력할-것-어떤-메서드를-볼-수-있나:1997847a940b2d3ade5fb5268bbdd076&#34;&gt;1. 스칼라 REPL에서 3을 입력하고 Tab키를 입력할 것. 어떤 메서드를 볼 수 있나?&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;scala&amp;gt; 3.
%   +   &amp;gt;    &amp;gt;&amp;gt;&amp;gt;            isInstanceOf   toDouble   toLong     unary_+   |   
&amp;amp;   -   &amp;gt;=   ^              toByte         toFloat    toShort    unary_-       
*   /   &amp;gt;&amp;gt;   asInstanceOf   toChar         toInt      toString   unary_~       

scala&amp;gt; 3.
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;2-스칼라-repl에서-3의-제곱근을-계산하고-그-값을-제곱하라-결과가-3과-얼마나-차이가-나는가:1997847a940b2d3ade5fb5268bbdd076&#34;&gt;2. 스칼라 REPL에서 3의 제곱근을 계산하고 그 값을 제곱하라. 결과가 3과 얼마나 차이가 나는가?&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;scala&amp;gt; import math._
import math._

scala&amp;gt; sqrt(3)
res2: Double = 1.7320508075688772

scala&amp;gt; pow(res2, 2)
res3: Double = 2.9999999999999996

scala&amp;gt; 3 -  res3
res4: Double = 4.440892098500626E-16
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;3-res-변수는-val인가-var-인가:1997847a940b2d3ade5fb5268bbdd076&#34;&gt;3. res 변수는 val인가? var 인가?&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Answer: val&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;scala&amp;gt; 3+3
res5: Int = 6

scala&amp;gt; res5 = 7
&amp;lt;console&amp;gt;:14: error: reassignment to val
       res5 = 7
            ^
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;4-스칼라에서는-문자열을-숫자로-곱할-수-있다-crazy-3-을-repl에서-수행해-보라-이-연산은-무엇을-하나-스칼라-독-어디에서-찾을-수-있나:1997847a940b2d3ade5fb5268bbdd076&#34;&gt;4. 스칼라에서는 문자열을 숫자로 곱할 수 있다. &lt;code&gt;&amp;quot;crazy&amp;quot;*3&lt;/code&gt; 을 REPL에서 수행해 보라. 이 연산은 무엇을 하나? 스칼라 독 어디에서 찾을 수 있나?&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;scala&amp;gt; &amp;quot;crazy&amp;quot;*3
res0: String = crazycrazycrazy

scala&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;StringOps: &lt;a href=&#34;http://www.scala-lang.org/api/2.11.8/#scala.collection.immutable.StringOps&#34;&gt;http://www.scala-lang.org/api/2.11.8/#scala.collection.immutable.StringOps&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;def *(n: Int): String&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;5-10-max-2는-무엇을-의미하나-max-메서드는-어느-클래스에-정의되어-있나:1997847a940b2d3ade5fb5268bbdd076&#34;&gt;5. 10 max 2는 무엇을 의미하나? max 메서드는 어느 클래스에 정의되어 있나?&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;scala&amp;gt; 10 max 2
res7: Int = 10

scala&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.scala-lang.org/api/current/#scala.runtime.RichInt&#34;&gt;http://www.scala-lang.org/api/current/#scala.runtime.RichInt&lt;/a&gt;&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;scala.runtime.RichInt&lt;/li&gt;
&lt;li&gt;&lt;code&gt;def max(that: Int): Int&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;6-bitint를-사용하여-2-1024를-계산하시오:1997847a940b2d3ade5fb5268bbdd076&#34;&gt;6. BitInt를 사용하여 2^1024를 계산하시오.&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;scala&amp;gt; BigInt(2) pow 1024
res10: scala.math.BigInt = 179769313486231590772930519078902473361797697894230657273430081157732675805500963132708477322407536021120113879871393357658789768814416622492847430639474124377767893424865485276302219601246094119453082952085005768838150682342462881473913110540827237163350510684586298239947245938479716304835356329624224137216  

scala&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;7-probableprime과-random에-아무런-식별자-없이-probableprime-100-random-으로-임의의-소수를-얻으려면-어떻게-해야-하는가:1997847a940b2d3ade5fb5268bbdd076&#34;&gt;7. probablePrime과 Random에 아무런 식별자 없이 probablePrime(100, Random)으로 임의의 소수를 얻으려면 어떻게 해야 하는가?&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;scala&amp;gt; import BigInt._
import BigInt._

scala&amp;gt; import util._
import util._

scala&amp;gt; probablePrime(100, Random)
res0: scala.math.BigInt = 807294085848679373168091165161

scala&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;8-임의의-파일-혹은-디렉터리-이름을-생성하는-방법-중-하나는-임의의-bigint를-생성하고-있을-36진법으로-변환하여-qsnvbevtomcj38o06kul-같은-문자열을-얻는-것이다-스칼라-독을-뒤져서-방법을-찾으시오:1997847a940b2d3ade5fb5268bbdd076&#34;&gt;8. 임의의 파일 혹은 디렉터리 이름을 생성하는 방법 중 하나는 임의의 BigInt를 생성하고 있을 36진법으로 변환하여 &amp;ldquo;qsnvbevtomcj38o06kul&amp;rdquo; 같은 문자열을 얻는 것이다. 스칼라 독을 뒤져서 방법을 찾으시오.&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;scala&amp;gt; import BigInt._
import BigInt._

scala&amp;gt; import util._
import util._


scala&amp;gt;  probablePrime(100, Random)
res6: scala.math.BigInt = 972061358937142327172244809173

scala&amp;gt; res6.toString(36)
res8: String = 2m8qszj9v05sqltjr4d1
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;9-scala에서-문자열의-첫문자를-어떻게-얻는가-마지막-문자는-어떻게-얻는가:1997847a940b2d3ade5fb5268bbdd076&#34;&gt;9. scala에서 문자열의 첫문자를 어떻게 얻는가? 마지막 문자는 어떻게 얻는가?&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;scala&amp;gt; &amp;quot;meorng&amp;quot;(0)
res9: Char = m

scala&amp;gt; &amp;quot;meorng&amp;quot;.head
res10: Char = m

scala&amp;gt; &amp;quot;meorng&amp;quot;.last
res11: Char = g

scala&amp;gt; &amp;quot;meorng&amp;quot;.reverse
res12: String = gnroem

scala&amp;gt; &amp;quot;meorng&amp;quot;.reverse.head
res13: Char = g

scala&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;10-문자열의-take-drop-takeright-dropright는-무엇을-하나-substring을-사용하는-것에-비교해-장점과-단점은-무엇인가:1997847a940b2d3ade5fb5268bbdd076&#34;&gt;10. 문자열의 take, drop, takeRight, dropRight는 무엇을 하나? subString을 사용하는 것에 비교해 장점과 단점은 무엇인가?&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;scala&amp;gt; &amp;quot;merong&amp;quot; take 3
res16: String = mer

scala&amp;gt; &amp;quot;merong&amp;quot; drop 3
res17: String = ong

scala&amp;gt; &amp;quot;merong&amp;quot; takeRight 3
res18: String = ong

scala&amp;gt; &amp;quot;merong&amp;quot; dropRight 3
res19: String = mer
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;ul&gt;
&lt;li&gt;돌아가기: &lt;a href=&#34;http://taewan.kim/documents/scala4theimpatient.html&#34;&gt;Index&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Scala for The Imaptient - 정리</title>
      <link>http://taewan.kim/documents/scala4theimpatient.html</link>
      <pubDate>Thu, 07 Apr 2016 17:25:40 +0900</pubDate>
      
      <guid>http://taewan.kim/documents/scala4theimpatient.html</guid>
      <description>&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;http://taewan.kim/documents/scala4impatient/ch01.html&#34;&gt;The Basics&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Control Structures and Functions&lt;/li&gt;
&lt;li&gt;Working with Arrays&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>01. asserts</title>
      <link>http://taewan.kim/documents/47degree4scala/01.asserts.html</link>
      <pubDate>Thu, 31 Mar 2016 01:21:52 +0900</pubDate>
      
      <guid>http://taewan.kim/documents/47degree4scala/01.asserts.html</guid>
      <description>

&lt;h1 id=&#34;단정-함수:28be12209e2f94f4a685e9d6518a6d60&#34;&gt;단정 함수&lt;/h1&gt;

&lt;p&gt;ScalaTest는 3개의 단정문을 제공하며, 이 단정문은 모든 trait에서 기본적으로 사용 가능하다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;assert: 범용적 단정문&lt;/li&gt;
&lt;li&gt;assertResult: 실제 값과 예상 값을 식별&lt;/li&gt;
&lt;li&gt;intercept: 코드가 예고한 예외를 던지는 것을 확인&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;모든 스칼라 프로그램에서 assert 메서드를 호출 할 수 있다. 이 메서드는 Boolean형을 파라미터로 취한다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;val left = 2
val right = 1
assert(left == right)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;전단한 표현식의 true이면 assert 메서드는 정상적으로 종료되지만, 반대로 false라면 assert 메서드는 AssertionError를 발생시키고 종료될 것이다. 이렇게 동작하는 assert 메서드는 Predef 객체에 정의되어 있다. Predef에 정의된 모든 멤버는 명시적으로 임포트하지 않아서 모든 스칼라 소스 파일이 기본적으로 임포트된다.&lt;/p&gt;

&lt;p&gt;ScalaTest는 DSL(Domain Specific Language)를 제공한다. 이 DSL을 사용하여 &amp;ldquo;should&amp;rdquo; 같은 단어를 사용하여 단정문을 표현 할 수 있다. ScalaTest의 동일성을 체크하는 다섯가지 방법을 제공한다. 이 각각의 방법은 각각 다른 요구사항을 해결하기 위해서 디자인 되었다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;result should equal (3) // Equality를 커스터마이징 할 수 있음
result should === (3)   // Equality를 커스터마이징 하고 타입 제약을 강제함
result should be (3)    // Equality를 커스터마이징 할 수 없음. 따라서 컴파일이 가장 빠름
result shouldEqual 3    // Equality를 커스터마이징 할 수 있음. 괄호가 필요 없음
result shouldBe 3       // Equality를 커스터마이징 할 수 없음. 따라서 컴파일이 가장 빠름. 괄호 필요 없음
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Problem NintyNine for Scala</title>
      <link>http://taewan.kim/documents/Problem-NintyNine4Scala.html</link>
      <pubDate>Fri, 25 Mar 2016 17:57:42 +0900</pubDate>
      
      <guid>http://taewan.kim/documents/Problem-NintyNine4Scala.html</guid>
      <description>

&lt;p&gt;prolog 학습 자료인 &amp;ldquo;P-99: Ninety-Nine Prolog Problems&amp;rdquo;의 스칼라 버전 입니다.
&amp;ldquo;P-99: Ninety-Nine Prolog Problems&amp;rdquo;는 Prolog의 학습을 지원하기 위한 연습문제 성격입니다.
Prolog버전의 연습문제를 Scala 버전으로 변경하여 제공하는 내용을 정리하는 페이지 입니다.
&amp;ldquo;P-99: Ninety-Nine Prolog Problems&amp;rdquo;은 홈페이지는 다음과 같습니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://sites.google.com/site/prologsite/prolog-problems&#34;&gt;https://sites.google.com/site/prologsite/prolog-problems&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&amp;ldquo;P-99: Ninety-Nine Prolog Problems&amp;rdquo;은 7개 카테고리로 구성되며, 스칼라 버전의 변환은
aperiodic.net을 참조하여 정리하였습니다.&lt;/p&gt;

&lt;h2 id=&#34;해당-문제의-답안은-문제-번호에-설정된-링크로-확인-할-수-있습니다:08dbffc5775114b4d4832a173849c143&#34;&gt;해당 문제의 답안은 문제 번호에 설정된 링크로 확인 할 수 있습니다.&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;카테고리 구성

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#list&#34;&gt;List&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#arithmetic&#34;&gt;Arithmetic&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#logic&#34;&gt;Logic and Codes&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#binarytrees&#34;&gt;Binary Trees&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#multiwaytrees&#34;&gt;Multiway Trees&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#graphs&#34;&gt;Graphs&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#miscellaneous&#34;&gt;Miscellaneous&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;a id=&#34;list&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;1-list:08dbffc5775114b4d4832a173849c143&#34;&gt;1. List&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://taewan.kim/documents/prolog99/problem-01.html&#34;&gt;S-01&lt;/a&gt;: 리스트의 마지막 엘리먼트를 구하시오?

&lt;ul&gt;
&lt;li&gt;예제 코드&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;scala&amp;gt; last(List(1, 1, 2, 3, 5, 8))
res0: Int = 8
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://taewan.kim/documents/prolog99/problem-02.html&#34;&gt;S-02&lt;/a&gt;: 리스트의 끝에서 두번째 엘리먼트를 구하시오?

&lt;ul&gt;
&lt;li&gt;예제 코드&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;scala&amp;gt; penultimate(List(1, 1, 2, 3, 5, 8))
res0: Int = 5
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://taewan.kim/documents/prolog99/problem-NotYet.html&#34;&gt;S-03&lt;/a&gt;: 리스트의 k번째 엘리먼트를 구하시오?

&lt;ul&gt;
&lt;li&gt;리스트의 첫 번째 엘리먼트는 0.&lt;/li&gt;
&lt;li&gt;예제 코드&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;scala&amp;gt; nth(2, List(1, 1, 2, 3, 5, 8))
res0: Int = 2
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://taewan.kim/documents/prolog99/problem-NotYet.html&#34;&gt;S-04&lt;/a&gt;: 리스트의 엔리먼트 사이즈를 구하시오?

&lt;ul&gt;
&lt;li&gt;예제 코드&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;scala&amp;gt; length(List(1, 1, 2, 3, 5, 8))
res0: Int = 6
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://taewan.kim/documents/prolog99/problem-NotYet.html&#34;&gt;S-05&lt;/a&gt;: 리스트를 리버스로 변환하시오?

&lt;ul&gt;
&lt;li&gt;예제 코드&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;scala&amp;gt; reverse(List(1, 1, 2, 3, 5, 8))
res0: List[Int] = List(8, 5, 3, 2, 1, 1)
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;a id=&#34;arithmetic&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;2-arithmetic:08dbffc5775114b4d4832a173849c143&#34;&gt;2. Arithmetic&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;a id=&#34;logic&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;3-logic:08dbffc5775114b4d4832a173849c143&#34;&gt;3. Logic&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;a id=&#34;binarytrees&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;4-binary-trees:08dbffc5775114b4d4832a173849c143&#34;&gt;4. Binary Trees&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;a id=&#34;multiwaytrees&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;5-multiway-trees:08dbffc5775114b4d4832a173849c143&#34;&gt;5. Multiway Trees&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;a id=&#34;graphs&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;6-graphs:08dbffc5775114b4d4832a173849c143&#34;&gt;6. Graphs&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;a id=&#34;miscellaneous&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;7-miscellaneous:08dbffc5775114b4d4832a173849c143&#34;&gt;7. Miscellaneous&lt;/h2&gt;
</description>
    </item>
    
    <item>
      <title>Scala Exercises - Series (1)</title>
      <link>http://taewan.kim/blog/2016/03/18/prog-problems-01/</link>
      <pubDate>Fri, 18 Mar 2016 01:18:18 +0900</pubDate>
      
      <guid>http://taewan.kim/blog/2016/03/18/prog-problems-01/</guid>
      <description>

&lt;h2 id=&#34;문서상태:da945fcb0d0477d4f89828ad0783ee93&#34;&gt;문서상태&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;현재 작업중&amp;hellip;..&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;시작하며:da945fcb0d0477d4f89828ad0783ee93&#34;&gt;시작하며&lt;/h2&gt;

&lt;p&gt;스위스의 Bern University에서는 Prolog의 교육을 목적으로 99개의 문제와 각 문제에 대한 풀이법을 제공합니다. (&lt;a href=&#34;https://sites.google.com/site/prologsite/&#34;&gt;https://sites.google.com/site/prologsite/&lt;/a&gt;) 이 사이트에서 제공하는 99개의 문제를 풀어가는 과정은 Prolog에대한 이해를 높이고 친숙해지는 가장 효율적인 방법이라고 생각됩니다. 최근에 Scala를 처음 접하는 과정에서 스칼라를 언어적으로 연습하고 연마할 적절한  대상이 부족하다는 아쉬움이 많았습니다. 최근에 Prolog 99을 스칼라 버전으로 변환한 &lt;a href=&#34;http://aperiodic.net을&#34;&gt;http://aperiodic.net을&lt;/a&gt; 발견하였습니다. 이 사이트에서는 Prolog 99을 스칼라 버전으로 변환한 문제와 풀이를 제공합니다. 이 사이트에서 제공하는 스칼라 버전의 Prolog 99은 스칼라 학습 및 연습에 유용하게 사용될 수 있있습니다. 이 문제 풀이는 스칼라에 대한 이해를 높일 수 있는 효과적인 컨텐츠 입니다.&lt;/p&gt;

&lt;h3 id=&#34;prolog-problems의-구성:da945fcb0d0477d4f89828ad0783ee93&#34;&gt;Prolog Problems의 구성&lt;/h3&gt;

&lt;p&gt;&amp;ldquo;P-99: Ninety-Nine Prolog Problems&amp;rdquo;는 7개의 카테고리 99개 문제로 구성되어 있습니다. 7개의 카테고리는 다음과 같습니다&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Prolog Lists (28개)&lt;/li&gt;
&lt;li&gt;Arithmetic (11개)&lt;/li&gt;
&lt;li&gt;Logic and codes (5개)&lt;/li&gt;
&lt;li&gt;Binary Trees (18개)&lt;/li&gt;
&lt;li&gt;Multiway Trees (6개)&lt;/li&gt;
&lt;li&gt;Graphs (11개)&lt;/li&gt;
&lt;li&gt;Miscellaneous (9개)&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;prolog-lists:da945fcb0d0477d4f89828ad0783ee93&#34;&gt;Prolog Lists&lt;/h2&gt;

&lt;h3 id=&#34;1-01:da945fcb0d0477d4f89828ad0783ee93&#34;&gt;1.01&lt;/h3&gt;

&lt;p&gt;1&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>[47 Degrees] scala exercises</title>
      <link>http://taewan.kim/documents/47degrees4scala.html</link>
      <pubDate>Fri, 20 Mar 2015 11:49:56 +0900</pubDate>
      
      <guid>http://taewan.kim/documents/47degrees4scala.html</guid>
      <description>

&lt;p&gt;47 Degrees(47deg.com)에서 운영하는 Scala Exercise(&lt;a href=&#34;http://scala-exercises.47deg.com/)에&#34;&gt;http://scala-exercises.47deg.com/)에&lt;/a&gt; 대한 정리입니다. Scala Exercise는 42개 목록으로 구성되어 있습니다. 각 타이틀에 대한 번역과 코드를 별도 프로젝트로 정리하겠습니다. 각 항목에 대한 정리 내용은 현재 페이지에서 링크로 정리하겠습니다.&lt;/p&gt;

&lt;h2 id=&#34;scala-exercise:9020bfc57ece2aa04d15d84b97c920a4&#34;&gt;Scala Exercise&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;Assets

&lt;ul&gt;
&lt;li&gt;번역:&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Val and Var&lt;/li&gt;
&lt;li&gt;Classes&lt;/li&gt;
&lt;li&gt;Options&lt;/li&gt;
&lt;li&gt;Objects&lt;/li&gt;
&lt;li&gt;Tuples&lt;/li&gt;
&lt;li&gt;High Order Functions&lt;/li&gt;
&lt;li&gt;Lists&lt;/li&gt;
&lt;li&gt;Maps&lt;/li&gt;
&lt;li&gt;Sets&lt;/li&gt;
&lt;li&gt;Formatting&lt;/li&gt;
&lt;li&gt;Pattern Matching&lt;/li&gt;
&lt;li&gt;Case Classes&lt;/li&gt;
&lt;li&gt;Range&lt;/li&gt;
&lt;li&gt;Partially Applied Functions&lt;/li&gt;
&lt;li&gt;Implicits&lt;/li&gt;
&lt;li&gt;Traits&lt;/li&gt;
&lt;li&gt;For Expressions&lt;/li&gt;
&lt;li&gt;Infix, Prefix and Postfix&lt;/li&gt;
&lt;li&gt;Operators&lt;/li&gt;
&lt;li&gt;Infix Types&lt;/li&gt;
&lt;li&gt;Mutable Maps&lt;/li&gt;
&lt;li&gt;Mutable Sets&lt;/li&gt;
&lt;li&gt;Sequences and Arrays&lt;/li&gt;
&lt;li&gt;Iterables&lt;/li&gt;
&lt;li&gt;Traversables&lt;/li&gt;
&lt;li&gt;Named and Default Arguments&lt;/li&gt;
&lt;li&gt;Mainfests&lt;/li&gt;
&lt;li&gt;Preconditions&lt;/li&gt;
&lt;li&gt;Extrators&lt;/li&gt;
&lt;li&gt;ByName Parameter&lt;/li&gt;
&lt;li&gt;Repeated Parameters&lt;/li&gt;
&lt;li&gt;Parent Classes&lt;/li&gt;
&lt;li&gt;Empty Values&lt;/li&gt;
&lt;li&gt;Type Signatures&lt;/li&gt;
&lt;li&gt;Uniform Access Principle&lt;/li&gt;
&lt;li&gt;Literal Booleans&lt;/li&gt;
&lt;li&gt;Literal Numbers&lt;/li&gt;
&lt;li&gt;Literal Strings&lt;/li&gt;
&lt;li&gt;Type Variance&lt;/li&gt;
&lt;li&gt;Enumerations&lt;/li&gt;
&lt;li&gt;Constructions&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>[47 Degrees] scala exercises</title>
      <link>http://taewan.kim/blog/2015/03/20/scala_exercises/</link>
      <pubDate>Fri, 20 Mar 2015 11:49:56 +0900</pubDate>
      
      <guid>http://taewan.kim/blog/2015/03/20/scala_exercises/</guid>
      <description>

&lt;p&gt;47 Degrees(47deg.com)에서 운영하는 Scala Exercise에 대한 정리입니다. Scala Exercise는 42개 목록으로 구성되어 있습니다. 각 타이틀에 대한 요약을 remark.js와 worksheet 프로젝트로 정리하겠습니다. 각 항목에 대한 정리 내용은 현재 페이지에서 링크로 정리하겠습니다.&lt;/p&gt;

&lt;h2 id=&#34;변경-로그:164bfe7ab04dfe68df0663755834b87d&#34;&gt;변경 로그&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;2016.03.20: 정리 시작&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;scala-exercise:164bfe7ab04dfe68df0663755834b87d&#34;&gt;Scala Exercise&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;Assets: summary, code&lt;/li&gt;
&lt;li&gt;Val and Var&lt;/li&gt;
&lt;li&gt;Classes&lt;/li&gt;
&lt;li&gt;Options&lt;/li&gt;
&lt;li&gt;Objects&lt;/li&gt;
&lt;li&gt;Tuples&lt;/li&gt;
&lt;li&gt;High Order Functions&lt;/li&gt;
&lt;li&gt;Lists&lt;/li&gt;
&lt;li&gt;Maps&lt;/li&gt;
&lt;li&gt;Sets&lt;/li&gt;
&lt;li&gt;Formatting&lt;/li&gt;
&lt;li&gt;Pattern Matching&lt;/li&gt;
&lt;li&gt;Case Classes&lt;/li&gt;
&lt;li&gt;Range&lt;/li&gt;
&lt;li&gt;Partially Applied Functions&lt;/li&gt;
&lt;li&gt;Implicits&lt;/li&gt;
&lt;li&gt;Traits&lt;/li&gt;
&lt;li&gt;For Expressions&lt;/li&gt;
&lt;li&gt;Infix, Prefix and Postfix&lt;/li&gt;
&lt;li&gt;Operators&lt;/li&gt;
&lt;li&gt;Infix Types&lt;/li&gt;
&lt;li&gt;Mutable Maps&lt;/li&gt;
&lt;li&gt;Mutable Sets&lt;/li&gt;
&lt;li&gt;Sequences and Arrays&lt;/li&gt;
&lt;li&gt;Iterables&lt;/li&gt;
&lt;li&gt;Traversables&lt;/li&gt;
&lt;li&gt;Named and Default Arguments&lt;/li&gt;
&lt;li&gt;Mainfests&lt;/li&gt;
&lt;li&gt;Preconditions&lt;/li&gt;
&lt;li&gt;Extrators&lt;/li&gt;
&lt;li&gt;ByName Parameter&lt;/li&gt;
&lt;li&gt;Repeated Parameters&lt;/li&gt;
&lt;li&gt;Parent Classes&lt;/li&gt;
&lt;li&gt;Empty Values&lt;/li&gt;
&lt;li&gt;Type Signatures&lt;/li&gt;
&lt;li&gt;Uniform Access Principle&lt;/li&gt;
&lt;li&gt;Literal Booleans&lt;/li&gt;
&lt;li&gt;Literal Numbers&lt;/li&gt;
&lt;li&gt;Literal Strings&lt;/li&gt;
&lt;li&gt;Type Variance&lt;/li&gt;
&lt;li&gt;Enumerations&lt;/li&gt;
&lt;li&gt;Constructions&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
  </channel>
</rss>